
tomcat内存修改      -Xms256M   -Xmx512M   -XX:PermSize=128M   -XX:MaxPermSize=1024M

lock 和synchronized的区别   这个后面简单的讲了 ，可以作为备份

javac编译器

minor GC触发条件：当eden区没有足够的空间进行分配的时候

full gc 的触发条件：1.当老年代满了的时候就需要对老年代进行垃圾回收，老年代的垃圾回收称作Full GC
					2.发生minor gc时，虚拟机会检测之前每次晋升到老年代中的平均大小是否大于老年代的剩余空间大小，若大于，则改为直接进行一次full gc

					
1）调用System.gc时，系统建议执行Full GC，但是不必然执行
（2）老年代空间不足
（3）方法区空间不足
（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。


	这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（一次minorgc，将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中，永远有一个survivor space是空的，放不下就直接进入老年代）

					
					
操作数栈

jvm补充
	线程是操作系统最小的调度单位，进程是资源（比如：内存）分配的最小单位
	
	程序计数器
		当被挂起的线程重新运行，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，
		在JVM中，通过程序计数器来记录某个线程的字节码执行位置。
		因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。
		
		
	虚拟机栈
		剩下的内存都分配给了共享区和线程独享区，也就是堆内存+方法区内存+线程栈内存(程序计数器忽略不及)，那么不论堆内存和方法区内存占的内存空间有多小，线程栈内存的大小总是有限制的，
		由于java虚拟机会为每个线程分配一块内存，如果线程数量足够多，当再申请新的内存时，发现无内存可用了，就会抛出OutofMemoryError
		
		每当启动一个新线程时，Java虚拟机都会为它分配一个Java栈。虚拟机只会直接对Java栈执行两种操作，以帧为单位的压栈和出栈。生命周期和线程相同
		每个方法被执行会创建一个栈帧（ 当有一个方法被调用的时候  会产生一些跟这个方法相关的信息  如方法名，参数，中间变量等等  这些叫做栈帧）
		方法调用，对应一个栈帧在虚拟机中从入栈到出栈（栈的特性——后进先出。压栈，弹出）
		
		测试栈的OOM异常，那么，以通过不断创建线程的方法，在这种情况下，为每个线程分配的内存越大，就会越容易产生OOM异常。
		
		当一个方法执行完毕  这个栈帧才会从栈顶pop掉  你递归的话  会一直向栈里push栈帧  而这个java栈是有一定的长度或深度的  当栈满了  无法再进行push的时候 就出现你上面的异常了
		一般的for是调用完方法就出栈了
		
		堆栈：
		stackoverflowerror：纵向无法分配，即无法分配新的栈帧
		oom：横向无法分配，无法建立新的线程
		
		***栈的特性——后进先出。***
		当前正运行的函数在数据区必须在栈顶
		函数的嵌套调用在很大程度上由栈的大小决定，栈越大，函数可以支持的嵌套调用次数就越多，
		
		
		当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。
		
		栈内存溢出(StackOverflowError)：程序所要求的栈深度过大导致。
		堆内存溢出(OutOfMemoryError:java heap space)： 分清 内存泄露还是 内存容量不足。泄露则看对象如何被 GC Root 引用。不足则通过 调大 -Xms，-Xmx参数。
		持久带内存溢出(OutOfMemoryError: PermGen space)：Class对象未被释放，Class对象占用信息过多，有过多的Class对象。
		(永久代的作用是存储每个类的信息，如类加载器引用、运行池常量池、字段数据、方法数据、方法代码、方法字节码等)
		无法创建本地线程：总容量不变，堆内存，非堆内存设置过大，会导致能给线程的内存不足。
		
		
		方法区和永久带还是不同的。一个是标准一个是实现。这就相当于你将java中的接口和接口的实现等同对待了一样。 永久带来实现方法区，两者很相近
		
		
	常量池
		字符串常量池（编译期间产生）是运行时常量池（可以动态扩展）的一部分，运行时常量池只有一个，
		Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。

		所谓静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。

		而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。
		
		必须要关注编译期的行为，才能更好的理解常量池。

        运行时常量池中的常量，基本来源于各个class文件中的常量池。

        程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。
		
	对象的访问 
		我们使用的HotSpot虚拟机 的对象访问方式是指针访问的方式
		Object obj=new object()
		Object obj存在栈的本地变量表中，作为refernce类型数据出现
		new object() 在堆中开辟了空间存放实例
		相应的对象类型数据(对象类型，父类，接口，方法)的地址信息，存放在方法区中
		
		指针的访问方式，refernce中直接存储的就是对象的地址，访问到相应实例，然后对象的类型数据要去方法区中找
		
		内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。
		内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
		
	减少内存解决内存溢出：
	内存-堆-方法区/栈容量=线程数，创建多个线程，容易引起内存溢出
	情景，不减少线程数情况下，减少最大堆和栈容量来换取更多的线程
		
	
	直接内存的也会溢出，常见的是使用大量的nio操作，需要用到direct memory
	
	
	这块内存主要是被JVM存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space中，它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序执行期对PermGen space进行清理，所以假设你的应用中有非常CLASS的话,就非常可能出现PermGen space错误。
	这样的错误常见在webserver对JSP进行pre compile的时候。
	假设你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。
	
	
	
类加载相关
	class文件是一组以8位字节为基础单位的二进制流,jvm只要识别是class文件就可以执行了，不用关心class的来源是什么语言
	class文件中，各数据严格按照顺序紧凑排列，其中只有两种数据类型：无符号数和表，class本质上是一张表，按序解析
	
	虚拟机的类加载机制
		虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的java类型
	
	符号引用 ：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。
				间接引用，引用的目标不一定已经加载到内存中
				个人理解为：在编译的时候一个每个java类都会被编译成一个class文件，但在编译的时候虚拟机并不知道所引用类的地址，多以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。
				
				
				String s=”adc”;
				System.out.println(“s=”+s);
				和
				System.out.println(“s=”+”abc”);
				
				person类中引入了一个country.class，对应的class权限类型就是符号引用，在解析的时候换成直接的地址引用
				
				
	直接引用 ：直接引用和虚拟机的布局是相关的，不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的。
			   如果有了直接引用，那么直接引用的目标一定被加载到了内存中。			
				
	初始化的坑就是 int类型 查询返回了一个null
	
		类加载的双亲委派模型实现逻辑：先检查是否已经被加载过，若没有加载则调用父加载器的loadclass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。
		如果父类加载失败，则在抛出classNotFoundException异常后，再调用自己的findclass()方法进行加载
		即所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(他的搜索范围中没有找到所需要的类时)，子加载器才会尝试自己加载
		好处是某个class，再程序的各种类加载环境中都是同一个类
		
		
	虚拟机字节码执行引擎
		栈帧：是用于支持jvm方法调用和执行的数据结构，是stack中的栈元素，(存储了局部变量表，操作数栈，动态连接，方法返回地址等信息),方法调用到执行完成，对应栈帧在jvm中入栈到出栈的过程
		编译时期，栈帧需要多发的局部变量表、多深的操作数栈已经完全确定，因此一个栈帧分配多少内存，不会受到运行期变量数据影响。
		在方法的调用链中，只有栈顶的栈帧是有效的，称为当前栈帧，对应所关联的方法称为当前方法，执行引擎所运行的所有字节码指令，都只针对当前栈帧进行操作
		局部变量：表示一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。由于是建立在线程的堆栈上，是线程私有的数据
		
		类变量有两次赋初始值的过程，一次是准备阶段，赋予系统初始值；另一次是在初始化阶段，赋予程序员定义的初始值。所有即使没有人为赋值，也还是会有一个确定的初始值。
		但是局部变量是必须初始化赋值的
		
		虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中
		
		泛型：编译期间可以发现强制转换的问题
		
		自动拆箱装箱的过程
			JVM会自动维护八种基本类型的常量池，int常量池中初始化-128~127的范围，所以当为Integer i=127时，在自动装箱过程中是取自常量池中的数值，而当Integer i=128时，128不在常量池范围内，所以在自动装箱过程中需new 128，所以地址不一样。
			
			包装类的==运算在没有遇到算数运算的情况下不会自动拆箱，而且他们的equals()方法不会处理数据转型的关系，比如g=(a+b)
			
			
		执行引擎在执行java代码时候可能有解释器执行或者通过即时编译器产生的本地代码执行编译器
		所有执行引擎是一致的，输入的是字节码文件，处理过程是子界面解析的等效过程，输出的是执行结果
			
	运行期的优化		
		区别是：即时编译生成机器相关的中间码，可重复执行缓存效率高。解释执行直接执行字节码，重复执行需要重复解释。
		被即时编译器编译的热点代码有两个特点：1被多次调用的方法。2被多次调用的循环体。
		
		
		java体系中的三种编译方式：前端编译、即时编译（JIT编译）、静态提前编译（AOT编译）,目前主流的是前端编译+JIT编译方式的运作
		
		1、前端编译
		   把Java源码文件（.java）编译成Class文件(.class)的过程；

		   也即把满足Java语言规范的程序转化为满足JVM规范所要求格式的功能；

			优点：

			这阶段的优化是指程序编码方面的；

			许多Java语法新特性（"语法糖"：泛型、内部类等等），是靠前端编译器实现的,而不是依赖虚拟机；

			编译成的Class文件可以直接给JVM解释器解释执行，省去编译时间，加快启动速度；

			缺点：

			对代码运行效率几乎没有任何优化措施；

			解释执行效率较低，所以需要结合下面的JIT编译；    

			前端编译器：Oracle javac、Eclipse JDT中的增量式编译器（ECJ）等;
			
			
		2、后端编译/即时(JIT)编译
			通过Java虚拟机（JVM）内置的即时编译器（Just In Time Compiler，JIT编译器）；在运行时把Class文件字节码编译成本地机器码的过程；            

			优点：
			通过在运行时收集监控信息，把"热点代码"（Hot Spot Code）编译成与本地平台相关的机器码，并进行各种层次的优化；
			可以大大提高执行效率；
			缺点：
			收集监控信息影响程序运行；
			编译过程占用程序运行时间（如使得启动速度变慢）；
			编译机器码占用内存；
			JIT编译器：HotSpot虚拟机的C1、C2编译器等；
			 

			另外，JIT编译速度及编译结果的优劣，是衡量一个JVM性能的很重要指标；

			所以对程序运行性能优化集中到这个阶段；

			也就是说可以对这个阶段进行JVM调优；
							
		
		3、静态提前编译（Ahead Of Time，AOT编译）
			程序运行前，直接把Java源码文件（.java）编译成本地机器码的过程；

			优点：

			编译不占用运行时间，可以做一些较耗时的优化，并可加快程序启动；

			把编译的本地机器码保存磁盘，不占用内存，并可多次使用；

			缺点：

			因为Java语言的动态性（如反射）带来了额外的复杂性，影响了静态编译代码的质量；

			一般静态编译不如JIT编译的质量，这种方式用得比较少；

			静态提前编译器（AOT编译器）：JAOTC、GCJ、Excelsior JET、ART (Android Runtime)等；
		
		
		在 JVM 中有三个非常重要的编译器，它们分别是：前端编译器、JIT 编译器、AOT 编译器。
		前端编译器，最常见的就是我们的 javac 编译器，其将 Java 源代码编译为 Java 字节码文件。（纯文本编辑器打开 Demo.class 文件，我们会发现是一连串的 16 进制二进制流。）
		JIT 即时编译器，最常见的是 HotSpot 虚拟机中的 Client Compiler 和 Server Compiler，其将 Java 字节码编译为本地机器代码。
		而 AOT 编译器则能将源代码直接编译为本地机器码。
		这三种编译器的编译速度和编译质量如下：
			编译速度上，解释执行 > AOT 编译器 > JIT 编译器。
			编译质量上，JIT 编译器 > AOT 编译器 > 解释执行。
		而在 JVM 中，通过这几种不同方式的配合，使得 JVM 的编译质量和运行速度达到最优的状态。
		
		无论什么语言写的代码，最终都是通过机器码运行的。
		
		javac的编译过程：1解析与填充符号表过程 2.插入式注解处理器的注解处理过程 3、分析与字节码生成过程
		编译过后的字节码文件就是.class格式的文件
		
		编译阶段的填充符号表：类之间是会互相引用的，但在编译阶段，我们无法确定其具体的地址，所以我们会使用一个符号来替代。
							  即对抽象的类或接口进行符号填充。等到类加载阶段，JVM 会将符号替换成具体的内存地址。
		
		
		语法分析后，只是获得了程序代码的抽象语法树(能表示一个结构正确的源程序抽象)，但不能保证符合逻辑
		
		字节码生成是javac编译过程的最后一个阶段，该阶段，把前面各步骤生成的信息转化为字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作
		
		当源代码转化为字节码之后，其实要运行程序，有两种选择。
		一种是使用 Java 解释器解释执行字节码，
		另一种则是使用 JIT 编译器将字节码转化为本地机器代码。
		
		因为机器码的运行效率肯定是高于 Java 解释器的，
		
		前者启动速度快但运行速度慢，而后者启动速度慢但运行速度快。
		因为解释器不需要像 JIT 编译器一样，将所有字节码都转化为机器码，自然就少去了优化的时间。
		而当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。
		而我们知道，机器码的运行效率肯定是高于 Java 解释器的。
		所以一个节约内存，一个提高效率，现在一般是二者并存使用的，因为解释器可以作为编译器激进优化的一个逃生门。
		
		
		现在的的即时编译器一般是两种，为 Client Compiler 和Server Compiler。简称C1和C2编译器，这两种不同的编译器衍生出两种不同的编译模式，
		我们分别称之为：
		C1 编译模式：优化相对保守，编译速度快
		C2 编译模式：会根据性能监控信息，激进优化，编译质量好，耗时长
		
		
		目前是和解释器混搭的模式，工作模式都是可以配置的
		
		
	内存模型
		除了volatile，java还有两个关键字实现可见性，synchronized和final
		
		实现线程的三种方式：1、使用内核线程实现，2使用用户线程（目前不用），3使用用户线程加轻量级进程混合实现
		
		轻量级进程就是我们通常意义上的所讲的线程，每个轻量级进程都由一个内核线程支持
		
		java 中一条jav线程就映射到一条轻量级进程中，系统提供的线程模型是一对一的
		
		线程调度的方式：
			1协同式，执行时间由线程本身控制，任务做完才通知系统切换线程，即线程执行之间不可控，容易阻塞进程
			2抢占式，由系统分配执行时间，执行时间系统可控，不会阻塞整个进程。是基于优先级的调度
			
			
	线程安全
		不可变的对象一定是线程安全的
		reentrantLock有着api层面的互斥锁（lock()和unlock()方法配合try/finally语句块完成）,而且三个高级功能
		1、等待可中断，
		2、公平锁，按照申请锁的时间顺序来依次获得锁，而非公平是随机的，默认是非公平，也可配置使用公平锁
		3、锁可以绑定多个条件（reentrantLock可以同时绑定多个condition对象相对于synchronized的和一个天剑关联）
		
	同步只是保障共享数据争用时的正确性的手段
	经典的web交互模型中“一个请求对应一个服务器线程”，那么线程本地存储来解决线程安全问题
	
	每个线程thread对象都有一个threadlocalmap对象，这个对象存储了一组以threadlocal.threadlocalhashcode为键，
	以本地线程变量为值的k-v值对，threadlocal对象就是当前线程的threadlocalmap访问入口，
	每个threadlocal对象都包含了一个独一无二的threadlocalhashcode，使用这个值可在线程k-v中找到对应的本地线程变量
	
	
	private static final ThreadLocal<ApplicationContext> opContextHolder = new ThreadLocal<ApplicationContext>();
	set时候 在当前thread的map中存入了一个k-v，k是threadlocalhashcode，v是存入的value
	
	String是不可变类，字符串的连接操作(如a+b+c)总是通过生成新的Stirng对象来进行的
	
	
	锁优化
		自旋锁；让线程执行一个忙循环(自旋转)，这样可以让线程等待，不用放弃处理器的执行时间，
				好处是避免了线程切换的开销，但是要占用处理器的时间，因此有个自旋转限定次数
	
	
	Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
	
补充：
	默认空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。
	JDK，开发java程序用的开发包，JDK里面有java的运行环境(JRE)，包括client和server端的。需要配置环境变量。。。。
	JRE，运行java程序的环境，JVM，JRE里面只有client运行环境，安装过程中，会自动添加PATH。
	
	其默认空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。
	如果内存剩余不到40％，JVM就会增大堆到Xmx设置的值，内存剩余超过70％，JVM就会减小堆到Xms设置的值。
	所以服务器的Xmx和Xms设置一般应该设置相同避免每次GC后都要调整虚拟机堆的大小
	
	
	那么Heap 越大可以供，程序申请的内存空间越少，就是说虚拟机栈越少（线程数量越少）
	堆内存存储了对象，我们称为GC堆，我们增加-Xmx 只是增加了GC堆的大小正真执行程序的内存空间反而小了
	
	
	
	当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，
	这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。
	无用可达
	
	内存泄漏场景：

	(1) 长生命周期的对象持有短生命周期对象的引用

	这是内存泄露最常见的场景，也是代码设计中经常出现的问题。

	例如：在全局静态map中缓存局部变量，且没有清空操作，随着时间的推移，这个map会越来越大，造成内存泄露。

	(2) 修改HashSet中对象的参数值，且参数是计算哈希值的字段

	当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段，否则对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，
	在这种情况下，即使在contains方法使用该对象的当前引用作为参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中删除当前对象，造成内存泄露。

	(3) 机器的连接数和关闭时间设置

	长时间开启非常耗费资源的连接，也会造成内存泄露。
	
	
	
	
	
	hashset中的
	执行顺序：
    首先比较哈希值是否相同
        相同：继续执行equals()方法
               返回true：元素重复了，不添加
               返回false：直接把元素添加到集合
        不同：就直接把元素添加到集合
	
	
	过程内容：
		1、选书的原因，项目和理论相结合，理论性多点的，相互学习
		1、书中的前言部分，内容特色中，简单介绍5个部分的主要内容。对着书的简介看
	
	
	
	
	
-Xms 为jvm启动时分配的内存，比如-Xms200m，表示分配200M

						大点，程序会启动的快一点
-Xmx 为jvm运行过程中分配的最大内存，比如-Xms500m，表示jvm进程最多只能够占用500M内存


-Xss 为jvm启动的每个线程分配的内存大小，默认JDK1.4中是256K，JDK1.5+中是1M




https://www.jianshu.com/p/4b4519f97c92     配置总结

	
	
	
	