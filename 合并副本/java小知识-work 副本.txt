学习小结：
1-学习新的东西，最直接标准的就是官方的API文档。
2-不要绕业务逻辑，抓重点
3-背景色：R:204, G:232, B:207
	  红199  绿237  蓝204 豆沙绿











 

	
			
			



20、		list添加数据时 引用类型要new一个新地址出来
21、 	  	sql语句查询精确查询id等字段需要#{ }，根据字段排序用${ }








		






	
	

39、		"addServices": ["2" ,"1"]
		{ }内需要传键值对


40  		hashmap和treemap（有序）





54、		创建一个public static final 类型的map 并初始化赋初值，，也可以通过Collections.unmodifiableMap(params)，实现不可更改。  
				静态常量
				public static final Map<String,String> map=new HashMap<String, String>();
				static{
					map.put("1", "a");
					map.put("2", "b");
					map.put("3", "c");
				}
				在别的类中进行修改，重新创建实例可以全局共享修改的数据map。同样静态字符串常量也是一样的。	



 

57、		
		maven：
上传远程仓库
		<version>0.0.6-SNAPSHOT</version>
		<version>3.2.0.RELEASE</version> maven的两种版本管理稳定版和快照版，pom.xml中带release和snapshot的会自动打包拿到nexus相应的目录，其他不识别的打到release目录下，打包的时候需要大写SNAPSHOT才能到正确位置，小写会打到release库下，但是引用大小写都可以。
		<distributionManagement>
			<repository>
				<id>my-nexus-releases</id>
				<url>http://192.168.6.251:8087/nexus/content/repositories/releases/</url>
			</repository>

			<snapshotRepository>
				<id>my-nexus-snapshot</id>
				<url>http://192.168.6.251:8087/nexus/content/repositories/snapshots/</url>
			</snapshotRepository>
		</distributionManagement>
		snapshot实时，但不稳定，release版本则比较稳定。Maven会根据项目的版本判断将构件分发到哪个仓库。
		分发构件到远程仓库需要认证，需在settings.xml中配置认证信息：（nexus的账号和密码），其中server元素下id的值必须与POM中repository或snapshotRepository下id的值完全一致。将认证信息放到settings下而非POM中，是因为POM往往是它人可见的，而settings.xml是本地的。





59、		实现springboot的多环境的配置，对应的resource目录下有三个文件夹各有一个application.properties
		<profiles>
				<profile>
					<id>dev</id>
					<properties>
				<env>dev</env>
					</properties>
					<activation>
						<activeByDefault>true</activeByDefault>
					</activation>
				</profile>
				<profile>
					<id>sit</id>
					<properties>
						<env>sit</env>
					</properties>
				</profile>
				<profile>
					<id>pre</id>
					<properties>
						<env>pre</env>
					</properties>
				</profile>
				<profile>
					<id>prd</id>
					<properties>
						<env>prd</env>
					</properties>
				</profile>
			</profiles>
	
			<build>
				<plugins>
					<plugin>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-maven-plugin</artifactId>
	           		 <dependencies>
	               		 <!-- spring热部署-->
	               		 <dependency>
	                   		 <groupId>org.springframework</groupId>
	                    		<artifactId>springloaded</artifactId>
	                    		<version>1.2.5.RELEASE</version>
	                		</dependency>
	            		</dependencies>
					</plugin>
				</plugins>
				<resources>
					<resource>
						<directory>src/main/resources</directory>
						<includes>
							<include>application-words.properties</include>
							<include>*.xml</include>
						</includes>
					</resource>
					<resource>
						<directory>src/main/resources/${env}</directory>
						<includes>
							<include>application.properties</include>
						</includes>
					</resource>
				</resources>
			</build>

			直接使用xml
	<profiles>
		<profile>
			<id>dev</id>
			<properties>
				<webXmlPath>src/webxml/web-dev.xml</webXmlPath>
			</properties>
			<activation>
				<activeByDefault>true</activeByDefault>
			</activation>
		</profile>
		<profile>
			<id>pre</id>
			<properties>
				<webXmlPath>src/webxml/web-pre.xml</webXmlPath>
			</properties>
		</profile>
		<profile>
			<id>prd</id>
			<properties>
				<webXmlPath>src/webxml/web-prd.xml</webXmlPath>
			</properties>
		</profile>
	</profiles>


60、			<profile>中默认的激活属性配置
			<activation>
				<activeByDefault>true</activeByDefault>
			</activation>

			
62、			属性文件的读取
			String filename = "com/luhy/test/ReadProperties.properties";  
        		Properties props = new Properties();  
       			props.load(ReadProperties.class.getClassLoader().getResourceAsStream(filename));  
       			String h = props.getProperty("v");  
			

63、			servletconfig.getInitParameter("port"),web.xml中配置的servlet属性可以这样读取
				<init-param>
      				<description>port</description>
      				<param-name>port</param-name>
      				<param-value>8080</param-value>
    			</init-param>

				

	

69、  			权重排序，打分排序
			query.setParam("bf","addSerJJ^0.8 require_goal^0.6 recip(rord(deal_money),1.0,10000.0,10000.0)^0.1");
			bf="ord(popularity)^0.5 recip(rord(price),1,1000,1000)^0.3，一般也不这样用，简单的排序规则就可以了



			




73、			fl=*,score查询权重得分



			

			

80、			相关知识整理
				在启动Web项目时，容器会读web.xml配置文件中的两个节点<listener>和<contex-param>,容器会将读取到<context-param>转化为键值对,并交给ServletContext。
				容器对于web.xml的加载过程是context-param >> listener  >> fileter  >> servlet
				servletconfig可以getInitParameter获取web.xml中的初始化的参数值。
		
				
				spring分别提供了用于启动WebApplicationContext的Servlet和Web容器监听器，在web应用启动的时候来初始化WebApplicationContext:
				org.springframework.web.context.ContextLoaderServlet;
				org.springframework.web.context.ContextLoaderListener.
				
				配置例子如下：
				<context-param> 
				<param-name>contextConfigLocation</param-name> 
				<param-value>/WEB-INF/applicationContext.xml</param-value> 
				</context-param> 

				<listener> 
				<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> 
				</listener> 
				
	
				spring的启动过程：

				1、首先，对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境；

				2、其次，在web.xml中会提供有contextLoaderListener。在web容器启动时，会触发容器初始化事件，此时contextLoaderListener会监听到这个事件，其contextInitialized方法会被调用，
				在这个方法中，spring会初始化一个启动上下文，这个上下文被称为根上下文，即WebApplicationContext，这是一个接口类，确切的说，其实际的实现类是XmlWebApplicationContext。
				这个就是spring的IoC容器，其对应的Bean定义的配置由web.xml中的context-param标签指定。在这个IoC容器初始化完毕后，spring以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取；

				3、再次，contextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这个servlet可以配置多个，以最常见的DispatcherServlet为例，这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请求。DispatcherServlet上下文在初始化的时候会建立自己的IoC上下文，
				用以持有spring mvc相关的bean。在建立DispatcherServlet自己的IoC上下文时，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE先从ServletContext中获取之前的根上下文(即WebApplicationContext)作为自己上下文的parent上下文。有了这个parent上下文之后，
				再初始化自己持有的上下文。这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，大概的工作就是初始化处理器映射、视图解析等。这个servlet自己持有的上下文默认实现类也是mlWebApplicationContext。初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为Key，
				而是通过一些转换，具体可自行查看源码)的属性为属性Key，也将其存到ServletContext中，以便后续使用。这样每个servlet就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文(第2步中初始化的上下文)定义的那些bean。	


81、				ResourceBundle resourceBundle = ResourceBundle.getBundle("filters.redis"); 加载classpath下的属性文件获取，resourceBundle.getString("redis.port")直接获取属性文件中的值



				
			

85、				final static常量String不能被重新赋值，只能被替换，替换不改变原来的值，而是返回这个新值
			





92、	去除字符串中某个重复字段
	String b="加急 ,匿名,加急推送";
		String combine="";
		String[] c=b.split(",");
		
		
		for(int i=0;i<c.length;i++){
			if(combine.indexOf("加急")==-1||c[i].indexOf("加急")==-1){
				combine=combine+c[i];
			}else{
				combine=combine+c[i].replaceFirst("加急", "");
			}
		}

96	$(#id)中不能带,号  like '%${param.ValiDateNameStr}%'

97、	左关联的实例	
	SELECT
		* FROM
		(
		SELECT
		user_classify_score.user_id ,
		user_classify_score.id ,
		user_classify_score.class_id ,
		IF(user_base_info_ext.RunStatus IS
		NULL,0,user_base_info_ext.RunStatus) AS STATUS
		FROM user_classify_score
		LEFT JOIN user_base_info_ext ON
		user_base_info_ext.User_Id=user_classify_score.user_id
		WHERE
		user_classify_score.class_id=367 AND
		user_classify_score.user_id!=203
		ORDER BY FLOOR(send_count/2)
		ASC,class_scores DESC,service_scores
		DESC,credit_scores DESC
		)userc
		WHERE userc.status=0


98、java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for  mapper声明路径不对


99、		完整的ajax调用
		/**
		*取消修改
		*/
		function cancelModify(idStr) {
			if (idStr != null && idStr != '') {
				var url = "${serverAddr}${cpath}/require/release/" + idStr + "/canceledit";
				var option = {
					url : url,
					dataType:"json",
					type : "post",
					beforeSubmit : null,
					success : function(json) {
						if (json.data == "success") {
								XYE.Alert.alert({str:"取消成功",callBack : function(obj){
								$(obj).find('.cen_butgoon').click(function(){
								window.location.reload();
									});
								}}
							);				
						}else if(json.data == "failed"){
							alert("取消失败");
						}else{
							alert(data.result);
						}
					}
				};
				XYE.Alert.prompt( {
				str:"您确认取消修改吗？",
				success : function(obj){
				    jQuery.ajax(option);
				    return;
				}
				});
			}
		}

		
101、 		count 和sum

102		主站和soa之间的地址访问时不是是否涉及跨域问题，controller中的调用接口，接口在spring-dubbo.xml中有注册，通过注册的地址，实现远程调用，并不是从前端页面直接跳转过来，不存在跨域问题
		soa服务化和主站对接   注册zookeeper，启动soa，主站依赖soa的api，通过jar引入主站的spring管理，通过dubbo配置，实现调用。
		
		
		跨域实现
		Tomcat下的配置 下载cors-filter-1.7.jar，java-property-utils-1.9.jar这两个库文件，放到lib目录下。（可在 http://search.maven.org上查询并下载。）工程项目中web.xml中的配置如下： [html] view plaincopy在CODE上查看代码片派生到我的代码片 <filter> <;filter-name>CORS</filter-name> <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class> <init-param> <param-name>cors.allowOrigin</param-name> <param-value>*</param-value> </init-param> <init-param> <param-name>cors.supportedMethods</param-name> <param-value>GET, POST, HEAD, PUT, DELETE</param-value> </init-param> 
		<init-param> <param-name>cors.supportedHeaders</param-name> <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value> </init-param> 
		<init-param> <param-name>cors.exposedHeaders</param-name> <param-value>Set-Cookie</param-value> </init-param> <init-param> <param-name>cors.supportsCredentials</param-name> 
		<param-value>true</param-value> </init-param> </filter> <filter-mapping> <filter-name>CORS</filter-name> <url-pattern>/*</url-pattern> </filter-mapping>

		还可以通过跳转controller中使用httpclient来实现访问，作为中间层来回调数据，这也是目前系统最稳定的方案。
		其他的还有方案是：jsonp 跨域浏览。


103、	
		增值服务去重
		String addSerString1="";
		String addSerString2="";
		String addSerString3="";	
		String addSerString="推送,加急推送,推送,推送,推送,匿名";
		String[] c=addSerString.split(",");
		for(int i=0;i<c.length;i++){
			String cc=c[i];
			if(addSerString1.indexOf("推送")==-1||c[i].indexOf("推送")==-1){
				addSerString1=addSerString1+cc; 
				addSerString2=addSerString2+cc+",";
				
			}else{
				addSerString1=addSerString1+cc.replaceFirst("推送", "");
				addSerString2=addSerString2+cc.replaceFirst("推送", ",");
				addSerString2=addSerString2.replaceAll(",,", ",");
				
			}
		}
		String replaceAll = addSerString2.replaceAll(",,", ",");
		String[] splits = replaceAll.split(",");

104、		</span><b>'+name+'</b></div>' name是js变量
		var name=$(this).parent().siblings('input').eq(1).val(); 获取同级第二个input元素

105、		edismax	
		query.setQuery(keyField + ":" + xyeSolrParam.getQueryStr());
		query.set("qf", keyField + "^2");


107、		属性文件载入容器管理
		<bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"> 
   			<property name="locations"> 
   			 <list> 
     			<value>classpath: conf/sqlmap/jdbc.properties </value> 
    			</list> 
   			</property> 
			</bean>

			<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"> 
			<property name="driverClassName" value="${jdbc.driverClassName}" /> 
   			<property name="url" value="${jdbc.url}" /> 
   			<property name="username" value="${jdbc.username}" /> 
   			<property name="password" value="${jdbc.password}" /> 
		</bean>


		
109、		数据库查询空字段使用is null，数据库的模糊查询like		
		select * from where 字段名 like '%"+str1+"%'; 查询变量      			concat(concat('%',#{username}),'%')
		SELECT * FROM user_base_info WHERE cell_phone LIKE '%/_%' ESCAPE '/'



112、		

113、		 	默认的servlet加载顺顺序
			<servlet>
    			<description>spring mvc servlet</description>
    			<servlet-name>springMvc</servlet-name>
    			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    			<init-param>
     			 <description>spring mvc 配置文件</description>
     			 <param-name>contextConfigLocation</param-name>
      			<param-value>classpath:config/spring-mvc.xml</param-value>
    			</init-param>
    			<load-on-startup>1</load-on-startup>
  			</servlet>
 	 		<servlet-mapping>
    			<servlet-name>springMvc</servlet-name>
    			<url-pattern>/</url-pattern>
  			</servlet-mapping>

		<context-param>
   		 <param-name>contextConfigLocation</param-name>
    		<param-value>classpath:config/spring.xml,classpath:config/spring-mybatis.xml,classpath:config/spring-dubbo.xml</param-value>
  		</context-param>	

114、		1.启动一个WEB项目的时候,容器(如:Tomcat)会去读它的配置文件web.xml.读两个节点: <listener></listener> 和 <context-param></context-param>
		2.紧接着,容器创建一个ServletContext(上下文),这个WEB项目所有部分都将共享这个上下文.

115、 		关联的问题
		<resultMap id="ResultMap2" type="com.xiaoyuer.model.RequireAdditionService"
		extends="BaseResultMap">
		<association property="baseAddServiceSetting" column="Base_Addser_Id"
			javaType="com.xiaoyuer.model.BaseAddServiceSetting">
			<id property="id" column="Base_Addser_Id"></id>
			<result property="title" column="Title" />
			<result property="description" column="Description" />
			<result property="price" column="Price" />
			<result property="code" column="Add_Ser_Code" />
			
		</association>
		</resultMap>

116、		    protected void doPost(HttpServletRequest req, HttpServletResponse resp)  
            		throws ServletException, IOException {  
        		//获取servlet初始化参数:  
        		String initParam = getServletConfig().getInitParameter("initParam");  
        		System.out.println("initParam: ---->" + initParam);  
       		 	//获取全局初始化参数:  
        		String contextParam = getServletContext().getInitParameter("contextParam");  
        		System.out.println("contextParam: ---->" + contextParam);  
        		//获取用户提交过来的数据:  	
			String username = req.getParameter("username");  
        		String password = req.getParameter("password");  
        		System.out.println("用户提交的数据:" + username + " , " + password);  
    		} 


		<init-parm>配置在<servlet>标签中,用来初始化当前的Servlet的,属于当前Servlet的配置,因此存放在servletConfig对象中;
       		 通过getServletConfig().getInitParameter("initParam")的方式获取;
		<context-param>直接配置在web.xml的<web-app>标签中,属于上下文参数,在整个web应用中都可以使用,它是全局的,因此存放在servletContext对象中(即application对象);
        	通过getServletContext().getInitParameter("contextParam")的方式获取;
		<context-param>搭配ContextLoaderListener监听类使用，是spring默认的初始化容器的监听类，默认是 WEB-INF/applicationContext.xml下的路径，可以通过<context-param>自由配置路径	

		getServletContext()取得的是 <context-param>配置的参数 
               	getServletConfig()取得的是 <servlet> <init-param>配置的参数

117、		Servlet和Filter是可以配置mapping的，即针对哪些地址的请求使用这些Servlet或者Filter，而Listener则是根据实现接口来判断什么情况下调用这个Listener的，
		基本的Listener仅仅在启动时执行一些任务。如果一个请求，同时调用到这三个，则执行顺序是：context- param -> listener -> filter -> servlet 

118、		继承自 SqlSessionDaoSupport后，数据处理	
		BaseDict bt = new BaseDict();
		List<Object> list = dataDictService.selectByObject(bt,BaseDictMapper.class);
		BaseMapper baseMapper = (BaseMapper)sqlSession.getMapper(object);
		return baseMapper.selectByObject(entity);

119、		web.xml 启动停止监听类
		ServletContextListener 接口，它能够监听 ServletContext 对象的生命周期，即监听 Web 应用的生命周期。
		当Servlet 容器启动或终止Web 应用时，会触发ServletContextEvent 事件，该事件由ServletContextListener 来处理。在 ServletContextListener 接口中定义了处理ServletContextEvent 事件的两个方法。
		* 当Servlet 容器启动Web 应用时调用该方法。在调用完该方法之后，容器再对Filter 初始化， 并且对那些在Web 应用启动时就需要被初始化的Servlet 进行初始化。 contextInitialized(ServletContextEvent sce)   
 		* 当Servlet 容器终止Web 应用时调用该方法。在调用该方法之前，容器会先销毁所有的Servlet 和Filter 过滤器。 contextDestroyed(ServletContextEvent sce)  
		在Container 加载Web 应用程序时（例如启动 Container 之后），会呼叫contextInitialized() ，而当容器移除Web 应用程序时，会呼叫contextDestroyed () 方法。

120、		web.xml中 处理内存泄漏的问题
		JDK中的java.beans.Introspector类的用途是发现Java类是否符合JavaBean规范，专门用来处理Introspector内存泄漏问题的辅助类。如果有的框架或程序用到了Introspector类,那么就会启用一个系统级别的缓存,此缓存会
　  		存放一些曾加载并分析过的JavaBean的引用。当Web服务器关闭时,由于此缓存中存放着这些JavaBean的引用,所以垃圾回收器无法回收Web容器中的JavaBean对象,最后导致
     		内存变大。IntrospectorCleanupListener会在Web服务器停止时清理Introspector缓存,使那些Javabean能被垃圾回收器正确回收。Spring自身不会出现这种问题，因为Spring在加载并分析完一个类之后会马上刷新
     		JavaBeans Introspector缓存,这就保证Spring中不会出现这种内存泄漏的问题。但有些程序和框架在使用了JavaBeans Introspector之后,没有进行清理工作(如 Quartz,Struts),最后导致内存泄漏
		<listener>
    		<listener-class>org.springframework.web.util.IntrospectorCleanupListener</listener-class>
 	 	</listener>
 
121、		项目中的mapper，和xml通过spring-mybatis.xml注入容器，一般的interface和impl通过@service注入+扫描包注入容器，java的实体类没有注入容器管理
		依赖的api通过dubbo.xml注入容器，并通过zookeeper的地址实现调用，filter过滤属性文件到resource下的属性文件后，通过注入容器，可以直接在xml中使用，也可以通过属性文件的加载读取（加载方式为流读取）。

122、		@Component 注释外，还定义了几个拥有特殊语义的注释，它们分别是：@Repository、@Service 和 @Controller。@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注





		
		
124、		跨系统之间的数据类传输需要序列化处理，特点是保持对象的属性状态。但不是每个类都可序列化，例如涉及线程的类与特定JVM有非常复杂的关系。

125、		依赖的jar是如何加入spring管理 引入的jar包需要包名统一为com.包，通过spring.xml扫描配置注入容器，再通过springdubbo.xml实现服务化的调用

126、		.gitconfig 文件下需要配置[receive]
    denyCurrentBranch = ignore才能远程提交
		git的两个仓库之间传输，需要两个仓库独立存在，pull 和push通过url连接，push需要更新后才能执行
		git提交到本地仓库以后可以revert远程版本实现回退

127、		request.getRequestDispatcher("/list.jsp").forward(request, response); 
		提交的request做处理完了，分发到下一个JSP页面或者下一个Action继续处理。会有forward()和redirect()两种情况，forward()是request中的参数继续传递，redirect()则是重新生成request了。

128、		Spring Boot应用程序在启动后，会遍历CommandLineRunner接口的实例并运行它们的run方法，实现启动类的加载，从容器中寻找。

129、		大数据处理	BigDecimal	处理类似科学计数法的大数据类  new BigDecimal(大数据).toString()；

130、		final static String 常量类不能放在主函数内 共享常量   方法里声明变量是私有的


	
134、		通过vars下的properties过滤到.xml下的读取直接用$[]读取，通过属性文件的加载配置PropertyPlaceholderConfigurer读取的使用${}读取

	

136、		比较		Date signDate = DateUtil.parseDate(userSigninCount.getSigningDate(), "yyyy-MM-dd");
					Date currentDate=DateUtil.getCurrentDateDate("yyyy-MM-dd");
					if(currentDate.compareTo(signDate)==0){
						//已签到
						return true;
					}






138、		java反射用例中，setAccessible(true) 并不是将方法的访问权限改成了public，而是取消java的权限控制检查。所以即使是public方法，其accessible 属相默认也是false
		利用反射，可以使用BeanUtils.copyProperties()来复制属性，对象的名称要匹配，不匹配不转，复杂属性类型需一致，否则argument type mismatch，常规属性类型的可以不一致，复杂类的属性复制，this.value=value全属性覆盖
		PropertyUtils的工具类，它也提供copyProperties()，并且还提供类型转换的功能，但两者都不支持date类型，这种的速度相对要慢
		反射本身的field可以直接设置，也可以通过setMethod.invoke()设值

139、		configfilter数据库加密   	java -cp druid-1.0.16.jar com.alibaba.druid.filter.config.ConfigTools you_password   1.0.16版本加密默认带有公钥，私钥。1.0.13版本默认不带公钥。
		通过设置<property name="filters" value="config" />
			<property name="connectionProperties" value="config.decrypt=true;config.decrypt.key=$[xye_jdbc_publicKey]" />来解密。
		加密的带公钥的需要传入公钥，未公钥加密的不需要传入公钥。

140、		传参是map类型的查询语句，
Map<String,Object> map = new HashMap<String,Object>();Integer updateFishfoodActiveByUserId(@Param("map")Map<String,Object> map);
		 <update id="updateFishfoodActiveByUserId" parameterType="java.util.Map" >
  			update 
  				user_base_account
  			set 
  				fishfood_active = #{map.fishfoodActive,jdbcType=INTEGER}
  			where 
  				user_id = #{map.userId,jdbcType=INTEGER}
  		</update>



142、		依赖的jar是如何加入spring管理 ，spring加入容器管理：通过注解标签+扫描路径的方式。



143、		资金归集生产问题，1、tomcat下prd实时日志，根据错误1、反序列化失败，2、redis获取null重新登陆，3、userbankcard中也有系统账户号，取消过滤即可。
		测试prd更改，直接将com.xiaoyuer.pay.web.controller.gateway.WithdrawController.class（在对应工程的target下的jar）的文件夹放到tomcat下的classes下，虽然依赖的jar中有这个类，但是会优先使用classes下的文件。

		




149、		自定义标签的常用输出方法：pageContext.getOut().print("Hello Tag!!!");  
		<c:if test="${!fn:contains('nihao','k')}">
		不包含
		</c:if>
		this.pageContext.setAttribute(var, Constants.XYE_PAYCORE_HOSTS); 前段页面的属性赋值
		

150、		git历史库中可以新建tag使用，并





153、		数据库的操作是原子性的，是单线程的，代码对象的更新数据库，在多人同时操作的时候，有可能出现高并发的问题。



155、		js的var变量在定义在函数外面的时候再页面加载好了之后就会赋值，定义在函数里才是实时数据（全局变量除外）。

156、		FileOutputStream fs = new FileOutputStream(outPath);//实例了文件输出流，参数是文件输出路径
		OutputStreamWriter ow = new OutputStreamWriter(fs,"UTF-8");//在写输出流的时候做编码格式转化，以免乱码！
		BufferedWriter bWriter = new BufferedWriter(ow);//将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入	

		（1）以utf-8的格式构造一个文件输出流FileOutputStream，（2）然后将这个文件输出字符流封装成字节输出流OutputStreamWriter，（3）然后将这个字节输出流封装成缓冲字节输出流。	

		
157、		maven    jar重复打包失败，切换版本再打回来。

158、		

159、		一般的jar是不让看到源码的，fastjson-1.2.2-sources.jar，jar包中加入类似的sources文件就可以看了

160、		忘记本地数据库 mysqld --skip-grant-tables







165、		logback中的		private static Logger logger = LoggerFactory.getLogger("test"); 
					 <logger name="test" >
					<level value="error" />
					<appender-ref ref="FILE" />
					<appender-ref ref="STDOUT" />
					</logger> 
			会默寻找 name相符合的log名称，找不到会默认继承根log，打日志

		lo4j中的日志设置		log4j.logger.packag1= info, packag1    默认packag1包下类和"packag1"的字符串

		protected static final Logger logger = Logger.getLogger(""); 参数只可能是1-字符串，2-*.class类，1就字符串匹配packag1名；2就作为类需要在packag1包下





	





	

170、	form参数绑定
	<form:form id="queryInfoForm" modelAttribute="platformOrder">
	<span>类型：</span>
	<form:select path="addSerCode" id="addSerCode">
		<option value="" selected>全部</option>
			<c:forEach var="addType" items="${addSers}" varStatus="addVsType">
				<c:choose>
			             <c:when test="${addType.key==platformOrder.addSerCode}">
					  <option value="${addType.key}" selected="selected">
						 ${addType.value}
					   </option>
						 /c:when>					
					 <c:otherwise>
					 <option value="${addType.key}">
						 ${addType.value }
					 </option>
				      </c:otherwise>
				</c:choose>
			</c:forEach>				
		</form:select>
		 <input type="submit"  class="bth" value="查询" />
		div id="partlist"></div>
 	 </form:form>



173、	maven依赖中出现依赖不一致的情况，可能出现了两次以上的maven依赖，maven出现！情况，但是jar引用存在，多是因为jar中缺少相关代码，打包与工程对应的正确的jar即可。
174、	library 和lib区别
		library是用来编译里面的src中java文件的
		部署到tomcat时,仅仅只复制了WEB-INF/lib里面的jar包,
		出现eclipse可以正常编译但tomcat运行是找不到类

175、
	 

176、	pw.print("{\"result\":\"" + result + "\"}"); json串的转义输出



178、	手动获取spring的ApplicationContext和bean对象    写一个工具类实现ApplicationContextAware接口,并将这个加入到spring的容器，具体方法网上有


179、	Field对于到一个成员对象, 这个和类定义是相关的.如果Field拿到的是static, 则get(null)取得当前field的值.
	如果Field是一个实例成员对象, 那么我们传入一个 对象实例, 拿到对象实例 的实例成员 的值. 案例代码如下：	
	
	Field f=Counter.class.getField("count"); //拿到Counter类的count 实例域
	Counter c=new Counter();                 //一个Counter对象实例
	Long l=(Long) f.get(c);                  //拿到对象实例的 域成员的值








	
187、	<url-pattern>/</url-pattern>  会匹配到/login这样的路径型url，不会匹配到模式为*.jsp这样的后缀型url
	<url-pattern>/*</url-pattern> 会匹配所有url：路径型的和后缀型的url(包括/login,*.jsp,*.js和*.html等)




191、	springboot搭建	

	1）、springboot默认contextpath的路径为/,部署在了root下       @RestController =@Controller +  @ResponseBody  

	2）、springboot支持需要添加tomcat-jsp解析包
        	<dependency>
            		<groupId>org.apache.tomcat.embed</groupId>
            		<artifactId>tomcat-embed-jasper</artifactId>
        	</dependency>
	3）、springboot的入口类 如果按官方的项目结构加上@SpringBootApplication即可，自定义特殊的目录结构需要加上自动配置和扫描等标签
	4）、 sprinboot工程maveninstall失败，unable to find a main class，pom中指定启动类即可
		 <properties>
        		<start-class>com.boot.Application</start-class>
        		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        		<java.version>1.7</java.version>
   		 </properties>
	5）、springboot整合mybatis需要引入数据库连接依赖，主要是配置sqlsessionfactory（注入datasource目前是application中配置，内含*mapper.xml配置，@Configuration和
		@EnableTransactionManagement(proxyTargetClass=true)）和mapper扫描（需要在sqlsessionfactory配置完成之后，@Configuration和@AutoConfigureAfter(MybatisConfig.class)），
		具体实现是mybaitsConfig.java和mapperScanner.java，   	
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
		</dependency>
	6）、springboot也支持xml配置，在启动类上加上@ImportResource({"classpath:config/spring-mvc.xml"})即可注入配置 ，配置spring-mvc 建议使用官方的xml头文件
        	
	
	
196、	spring.xml和spring-mvc.xml中配置的是不同的上下文，service交给spring管理，conroller交给spring-mvc管理，两个xml中的各自配置各自的属性文件，否则对应的访问不到，controller中的注入的bean一定要是spring-mvc.xml中注入的的bean
	配置多个PropertyPlaceholderConfigurer时 重点是：ignoreUnresolvablePlaceholders属性需要设置为true




203、	init()方法，然后用@PostConstruct 需要搭配@Component并被spring扫描到才行，启动时执行初始化


205、	filter类实现filter接口即可，在web.xml中配置，其中共有三个方法 
	1）、init（）是在启动项目的时候进行初始化
	2）、dofilter（）是在拦截打匹配的路径时候进行处理，处理完用chain.doFilter(request, response)进行继续访问请求
	3）、destroy（）当应用服务被停止或重新装载了，则会执行Filter的destroy方法，Filter对象销毁。比如改动项目的代码重新reload时候（Reloading Context）
  

208、	AtomicInteger提供原子操作来进行Integer的使用，通过线程安全的方式操作加减，因此十分适合高并发情况下的使用。但是效率相对低，高并发适用。

209、	modelAttribute使用时需要在进入jsp和跳转自jsp的controller中都要绑定相应的参数。


211、	拦截顺序，拦截路径的时候，先进入filter的dofilter()方法，在进入intercepor的prehandle()方法
	
	


213、	Tomcat中指定URL用UTF-8编码server.xml：
	<Connector port="8080" protocol="HTTP/1.1"   connectionTimeout="20000"   redirectPort="8443" useBodyEncodingForURI="true" URIEncoding="UTF-8" />  


215、		//构造XML
			Document document = DocumentHelper.createDocument();
			Element root = document.addElement("root");
			root.addElement("user").addText(ids[1]);
			root.addElement("sessionIdentifier").addText(ids[0]);
			response.setContentType("text/html;charset=UTF-8");
			response.getWriter().write(document.asXML());
			response.getWriter().flush();
			


218、	




221、	HttpServlet 包含  init()、destroy()、service()方法
	init()：启动加载，可设置Servlet 的初始化参数，并用它的 ServletConfig 对象参数来启动配置。
	service()：客户请求一个HttpServlet 对象，该对象的service() 方法就要被调用，而且传递给这个方法一个"请求"(ServletRequest)对象和一个"响应"(ServletResponse)对象作为参数。
		   servlet中首先执行doService(),判断是请求是get还是post,get就调用doGet(), post就调用doPost()。也可以直接过载doService()方法，这样不管是get还是post，都会执行这个方法。  

	当服务器调用sevlet 的Service()、doGet()和doPost()这三个方法时，均需要 "请求"和"响应"对象作为参数。"请求"对象提供有关请求的信息，而"响应"对象提供了一个将响应信息返回给浏览器的一个通信途径。  
	使用GET，form中的数据将编码到url中，而使用POST的form中的数据则在http协议的header中传输



222、	重头戏:servlet、filter、interceptor的区别

	执行顺序：url请求----->filter----->interceptor----->servlet

	filter：用途是过滤字符编码、做一些业务逻辑判断(登录、权限：session中的权限不够可以直接重定向)，用于请求预处理(Request、Response)，也可对HttpServletResponse进行后处理，是个典型的处理链。Filter只是链式处理，请求依然放行到目的地址
		HttpRequest ----> Filter ----> Servlet ----> Controller/Action/... ----> Filter ----> HttpResponse                           filter的处理过程

	
	interceptor: 	不是在web.xml,并且不是针对URL的，而是针对action,当页面提交action时，进行过滤操作，
			与filter不同点：（１）不在web.xml中配置，而是在struts.xml中完成配置，与action在一起 ( 2 ) 可由action自己指定用哪个interceptor 来在接收之前做事

			spingmvc中的HandlerInterceptor的web请求流程：HttpRequest ----> DispactherServlet ----> HandlerInterceptor ---->Controller----> HandlerInterceptor ----> HttpResponse    
	


	1）、Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的响应。
	2）、Filter与Servlet的区别在于：它不能直接向用户生成响应。完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。
	3）、servlet,filter都是针对url之类的，而listener是针对对象的操作的，如session的创建，session.setAttribute的发生，在这样的事件发生时做一些事情。
	4)、拦截器只能对Action请求起作用，而过滤器则可以对几乎所有请求起作用。
	5）、Filter面对的是所有的请求，而HandlerInterceptor是面对具体的Controller。Filter总是先于HandlerInterceptor发挥作用，在Filter中甚至可以中断请求，从而使它无法到达相应的Servlet。
	     而且两者的配置也不一样，Filter是在web.xml中进行配置，HandlerInterceptor是在具体的applicationContext.xml中进行配置。

	6)、 	1.针对url：servlet，filter都是针对url进行的操作，
 		2.针对对象：listener是针对对象的操作，它是在某个对象发生某些动作的时候执行，所以listener是提前封装好的对特定的对象的操作，只需要声明名称和类的位置即可。
 		3.针对action：interceptor是针对action对象进行操作的，它在配置的时候需要和action一起配置才能起作用，当页面提交action时，进行过滤操作。

	7）、1）Filter基于回调函数，而Interceptor则基于java本身的反射机制,这是两者最本质的区别。
	     2）Filter的过滤范围比Interceptor大,Filter除了过滤请求外通过通配符可以保护页面，图片，文件等等，而Interceptor只能过滤请求。




		
226、		流读取文件
		Thread.currentThread().getContextClassLoader().getResourceAsStream("abc.properties") 	默认是classpath下


		
		
227、		newinstance()和new()的区别
			newInstance: 弱类型。低效率。只能调用无参构造。 
    		new: 强类型。相对高效。能调用任何public构造。


228、		xml的解析:dom和sax
			xpath解析：先流读取xml文件获得doc，创建xpath对象，第一参数是xml中的路径，//表示只匹配名称，读取节点xpath.evaluate("/person", doc, XPathConstants.NODESET)  使用xpath.evaluate("background", node，XPathConstants.STRING)读取节点值.


	
		
  		



232、		springboot  bean.setTypeAliasesPackage("com.xiaoyuer.core.**.dmo");通配符配置多路径，com.xiaoyuer.core.dmo和com.xiaoyuer.core.talents.dmo              big  details


	


234、		内关联对象
		<resultMap id="ResultMapRequireInfo" type="com.xiaoyuer.core.dmo.RequireInfo" extends="BaseResultMap">
			<result column="Require_Des" property="requireDes" jdbcType="LONGVARCHAR" />
			<result column="provinceName" property="provinceName" jdbcType="VARCHAR" />
   	 		<result column="cityName" property="cityName" jdbcType="VARCHAR" />
   			<result column="districtName" property="districtName" jdbcType="VARCHAR" />
			<association property="userInfo" javaType="com.xiaoyuer.core.dmo.UserInfo">
				<id column="User_ID" property="id" jdbcType="INTEGER" />
				<result column="User_Name" property="userName" />
				<result column="User_Picture_Att" property="userPictureAtt" />
				<result column="Individual_Type" property="individualType" />
				<result column="Nick_Name" property="nickName" />
			</association>	
		</resultMap>

		关联查询的时候  <id column="Id" property="id" jdbcType="INTEGER" />     数显多条id相同的只能接受一条，除非不查id



235、		在json   post 传输数组或者list对象的时候   [{"nickName": "zhansan",},{"nickName": "zhansan2",}]

236、		proteced 修饰符只能在该类内部使用
   			
237、			
	1）、		{{each talents as item i}} {{/each}}
			{{if item.userValidate==0}}{{/if}}       ftl的另一种写法 

	2）、		$(this).addClass("active");
			$(this).attr('class','active');
			that.siblings().removeClass('active');删除同级节点的active样式
	3）、		var id=$('.xms-sideboxe li').eq(i).attr('id'); 取制定元素的id内容




	
240、	简易的ajax：
		$.ajax({
		             type: "post",
		             url: "localhost:8080/addTalents",
		             data: {"a":"nihao"},
		             dataType: "json",
		             success: function(data){		             	      
		                      }
		       });
	


	

242、	ajax传输数据的时候，后台使用@requestparam接受名字一定要对应，参数中如果不加该标签，传入数据是接受不到的，至少在springboot中接受不到，也就是说，不加标签ajax传输的数据只能tongue标签节后和request.getparammeter接收


243、	jsonarry和list转换	
	<dependency>
		<groupId>net.sf.json-lib</groupId>
		<artifactId>json-lib</artifactId>
		<version>2.4</version>
	</dependency>
		
244、	${ }不能在js中使用,循环添加一个新建对象，出现同一覆盖值的问题，var dataPrice={};一般要把新建对象放在循环体内
		r["name"]="tom"; 为对象添加属性
		var r=new Object();
		var dataForm=serialize(releaseReqForm);  表单序列化
		delete dataForm.appointPrice;   移除对象属性

	创建对象属性：
		var dataPrice={};
		XYE.each(dataForm.userId,function(i,tem){
		dataPrice['userId']=tem;
	
	浏览器的回退刷新
		<input type="hidden" id="refreshed" value="no">	
		<script type="text/javascript">
		onload=function(){
					var e=document.getElementById("refreshed");
					if(e.value=="no")e.value="yes";
					else{
						e.value="no";location.reload();
					     }
				  }
		</script >




247、	再一个方法中操作数据库，如果没有走完，数据库是不会把事务提交的，即在数据库中是实时看不到操作完成的数据的，但是数据已经在缓存中发生了变化


248、	interface中定义的常量可以直接interface.调用
	public interface IOperateAdminRequireLogService {
	public String opAdmin_release_require="requires/release";//小秘书发需求,该flag在requireInfoMapper.selectReqListByUserIdWihtSecListPage中被使用，慎改
	public String opAdmin_re_release_require="requires/reRelease";//小秘书重发需求
	public String opAdmin_modify_require="update";//小秘书修改需求
	public String opAdmin_colse_require="close";//小秘书关闭需求
	public String opAdmin_delete_require="delete";//小秘书删除需
	public String opAdmin_choose_apply="apply/select";//小秘书代选人
	void insertOperateAdminReqLog(int reqId,int userId,int requserId,String remark);
}






252、代码测试：
	1、主函数中测试，这种只支持一些常规类的创建对象测试，无法注入interface，mapper，applicationContext等，无法进行接口等测试
	2、junit测试，入口属于代码接口测试，在项目中添加library中添加junit，即可进行单元测试
相关maven依赖		<dependency>
    				<groupId>junit</groupId>
    				<artifactId>junit</artifactId>
    				<version>3.8.1</version>
    				<scope>test</scope>
			</dependency>
	在sprinboot中：
		@RunWith(SpringJUnit4ClassRunner.class) // SpringJUnit支持，由此引入Spring-Test框架支持！ 
		@SpringBootTest(classes = XyeServiceCoreApplication.class) // 指定我们SpringBoot工程的Application启动类
		@WebAppConfiguration 
		public class TalentsSearchServiceImplTest {
			@Autowired
			ITalentsSearchService  talentsSearchService;
			@Test
			public void testSelectUsersInfoBycellPhones() {
				BaseModelInfo<usersInfoBean> selectUsersInfoBycellPhones = talentsSearchService.selectUsersInfoBycellPhones(1, 202, "18862241316");
			}
		}
	在普通的ssm工程中：在这里是在war工程中进行测试，也因为各个jar的引用集中，mybattis也是集成在这里。不引入spring-mvc.xml的原因是这里是接口测试，无需controller相关，引入spring.xml是获得容器中的service，引入spring-mybatis.xml是因为接口中需要mapper等，否则接口注入失败
		@RunWith(SpringJUnit4ClassRunner.class)
		@ContextConfiguration(locations = { "classpath:spring.xml","classpath:spring-mybatis.xml" })
		public class UserInfoServiceImplTest {
			@Autowired
			IUserInfoService userInfoService;
			@Test
			public void test() {
				UserInfo selectById = userInfoService.selectById(203);
			}
		}

	3、postman测试，这种入口是路径测试
		在spring 接受参数是@pathvariable和@requestparam
		在springboot jboos中节后参数是@pathparam，@queryparam和@requestparam   @path标签和这些标签的匹配比较严格


	4、debug从前端页面到controller进入测试，这种在前后端分离的开发过程中是行不通的


253、默认的spring配置文件是resources下的applicationContext.xml，可以修改配置文件
			<context-param>	
				<param-name>contextConfigLocation</param-name>
				<param-value>classpath*:spring.xml</param-value>
			</context-param>


254、	接口中定义的"变量", 其实就是常量, 接口中的"变量"默认都是 "public static final"类型, 即为常量, 不要使用"常量接口模式", 此模式会导致类中的常量混乱



256、	.val() 方法返回或设置被选元素的值。

266、	ecipse下错误: 找不到或无法加载主类，重新添加buildPath中的add源码即可，maven打包异常不覆盖，也适用


	

269、	<resource>		----打包的类路径classpath
		<directory>src/main/resources</directory>	-----打包的目录，默认全部
		<includes>
		<include>spring-dubbo.xml</include>	-----打包固定的目录或文件
		</includes> 

	</resource>

	<profiles>
		<profile>
			<id>prd</id>
			<properties>
				<env>prd</env>
			</properties>
			<build>
				<filters>
					<filter>../vars/vars.prd.properties
					</filter>
				</filters>
			</build>
		</profile>
		<profiles>
	<resource>
		<directory>${basedir}/src/main/resources</directory>
		<filtering>true</filtering> 	----开启过滤功能
	</resource>
270、maven多环境 <resources>中，pom中不指定具体的路径，默认 web deployment assembly 中配置的resource 全目录打包，
	配置了<resource>就会严格固定pom中的配置目录
	


273、spring配置datasource的方式
	使用jndi需要在tomcat中增加数据源jar和logjar，并在context.xml中新增resourcejndi配置
	1、xml中注入配置datasource，需要指定数据源，目前用的是数据源jar是druid版本，在指定一些常规数据库连接属性即可
	2、 应用配置在高性能的应用服务器上，使用应用服务器本身提供的数据源。应用服务器的数据源，使用JNDI开放调用者使用，Spring为此专门提供引用JNDI资源的JndiObjectFactoryBean类。
		<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">      
    			<property name="jndiName" value="java:comp/env/jdbc/bbt"/>      
		</bean>  

	代码端：	Spring 2.0提供了一个jee命名空间，通过jee命名空间，简化J2EE资源的引用。
				<jee:jndi-lookup id="dataSource" jndi-name=" java:comp/env/jdbc/bbt"/>
	服务器端：	然后在tomcat中的context.xml中配置
				<Resource auth="Container" driverClassName="com.mysql.jdbc.Driver" maxActive="100" maxIdle="40" maxWait="12000" name="jdbc/XiaoyuerProject" password="db_xiaoyuer" type="javax.sql.DataSource" url="jdbc:mysql://192.168.6.251:3306/db_xiaoyuer_xq?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;generateSimpleParameterMetadata=true" username="db_xiaoyuer"/> 
 
	sprinboot中配置@bean 注入datasource，则以配置的为准，默认的取消

	DataSourceBuilder使用该类配置共配置数据源	


274、	<url-pattern>/</url-pattern> 会匹配到/login这样的路径型url，不会匹配到模式为*.jsp这样的后缀型url
	<url-pattern>/*</url-pattern> 会匹配所有url：路径型的和后缀型的url(包括/login,*.jsp,*.js和*.html等)
275、	在springmvc中继承HandlerInterceptorAdapter可以实现拦截器
	sprinboot中使用@ComponentScan(basePackageClasses = XyeManagerApplication.class）同样可以定义扫描的包路径
	
	springmvc中配置拦截器的路径，
	interceptor中处理request.setAttribute("baseUrl", Constants.URL_WEB_HOST_NEWADMIN);这样可以定义访问路径级别的全局的常量
	
	<mvc:interceptors>
    	<mvc:interceptor>
        <!-- 匹配的是url路径， 如果不配置或/**,将拦截所有的Controller -->
        <mvc:mapping path="/**"/>
        <bean class="com.cckj.util.auth.AuthInterceptor"></bean>
    	</mvc:interceptor>
    	<!-- 当设置多个拦截器时，先按顺序调用preHandle方法，然后逆序调用每个拦截器的postHandle和afterCompletion方法 -->
	</mvc:interceptors>



	


	
	
280、	<%@ taglib uri="http://www.xiaoyuer.com/tag" prefix="xiaoyuer"%>
		web.xml中：
		<jsp-config>
    		<taglib>
      		<taglib-uri>http://www.xiaoyuer.com/tag</taglib-uri>
      		<taglib-location>/WEB-INF/tag/xiaoyuer.tld</taglib-location>
    		</taglib>
		</jsp-config>
	  


	
	
284、	soaBean校验：
	1）、普通类实现接口需要实现接口中的所有方法，
	     抽象类实现借口，可以完全覆盖/重写 接口中的方法，也可只重写接口中的某几个方法，子类再继承抽象类时，子类重写的方法即为抽象类中未重写接口中的方法。
	     总的而言，抽象类实现接口可以自选实现的方法
	     普通类继承抽象类需要实现抽象类中的抽象方法
	     ***由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现***

	2)、field.setAccessible(true); 忽略访问修饰符权限
	    field.get(obj),对象实例换取对象的属性值，拿到对象实例的 域成员的值


286、	spring的事务模板，使用匿名内部类并进行封装
		Object tmpResult = this.transactionTemplate.execute(new TransactionCallback()
         {
             public Object doInTransaction(TransactionStatus status)
             {
                    return serviceCallback.invoke();
             }
         }); 
		使用TransactionCallback()可以返回一个值。
		如果使用TransactionCallbackWithoutResult则没有返回值。 

	


300、	spring的事务管理：
	a. 默认spring事务只在发生未被捕获的 runtimeexcetpion时才回滚；
	b. spring aop  异常捕获原理：被拦截的方法需显式抛出异常，并不能经任何处理，这样aop代理才能捕获到方法的异常，才能进行回滚，默认情况下aop只捕获runtimeexception的异常，但可以通过配置来捕获特定的异常并回滚  ！

	a1.  如果是service层处理事务，那么service中的方法中不做异常捕获，或者在catch语句中最后增加throw new RuntimeException()语句，以便让aop捕获异常再去回滚，并且在service上层（webservice客户端，view层action）要继续捕获这个异常并处理
	b2. 在service层方法的catch语句中增加：TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();语句，手动回滚，这样上层就无需去处理异常（现在我的项目的做法）



	
	
	
	
	
302、	使用SqlSessionDaoSupport ，在mybatis的中实现dao实现类，使用可获得sqlsession
	@Repository
	public class UserDAOImpl extends SqlSessionDaoSupport implements UserDAO

  	@Autowired(required = false)
   	 @Qualifier("sqlSessionFactory")
   	 public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
    	    super.setSqlSessionFactory(sqlSessionFactory);
    	}


	使用sqlsession.getMapper(CLASS)使用的是初始的mybatis操作，加载mybatis配置后使用，
	在整合spring以后，直接使用mapper方法即可

	总结：
	1、原生的jdbc操作需要具体拼装sql执行
	2、mybatis初始，可以使用dao，sqlsession.执行（）实现，
	也可使用mapper代理，namespace需要和mapper路径一致，sqlsession.getmapper()，未整合spring，无法扫描到mapper接口的位置
	3、整合spring之后，直接使用mapper方法调用



304、	hessian实现远程方法的调用:HessianServiceExporter或者HessianProxyFactory，基于二进制的数据传输对象，二进制RPC协议的轻量级远程调用框架，Hessian远程调用框架是构建在Http协议之上的
	如果在远程调用时，用到了自定义的实体，必须序列化
	在hessian接口调用时候，可设置超时时间，必须要考虑超时情况下，客户端和服务端数据回滚情况，尤其是金融相关问题，两边可以打上tag，实时验证。
	在调用时需要分别配置服务端和客户端的配置，客户端主要是加入容器bean，服务端是拦截路径交给hessian处理转至相应的serviceimpl处理，返回

	客户端――>序列化写到输出流――>远程方法(服务器端)――>序列化写到输出流 ――>客户端读取输入流――>输出结果
	目前想到的和dubbo的区别是，hessian只能连接单一远程服务，但是dubbo可以有zookeeper提供多个提供者




306、	aop
	两种动态代理的模式：1、jdk动态代理	jdk实现的代理要求被代理类基于统一的接口，基于反射机制实现

			    2、cglib动态代理

	1.默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了
	2.当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB

	动态代理的核心就是代理对象的生成	Proxy.newProxyInstance(classLoader, proxyInterface, handler)
	切面aspect的中可包含多个通知（Advice）

	通知执行顺序：前置通知→环绕通知连接点之前→连接点执行→环绕通知连接点之后→返回通知→后通知→(如果发生异常)异常通知→后通知
	强制cglib代理	<aop:config>的 proxy-target-class属性设为true

	代理其实是在原实例前后加了一层处理，堆原来的类进行了包装，并使用代理类来执行

	AOP就实现了把这些业务需求与系统需求分开来做。这种解决的方式也称代理机制。	
	多个不具有继承关系的对象引入一个公共行为，会造成代码重复，这时提现aop的好处
	


307、这个异常处理无效
	try {
		throw new IOException(
				"Did not receive successful HTTP response: status code = ");
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	

	ExceptionUtils.getMessage(e)获得异常类型


308、	直接读取xml文件，加入容器
	一、简单的用ApplicationContext做测试的话,获得Spring中定义的Bean实例(对象).可以用:
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	RegisterDAO registerDAO = (RegisterDAO)ac.getBean("RegisterDAO");

	如果是两个以上:
	ApplicationContext ac = new ClassPathXmlApplicationContext(new String[]{"applicationContext.xml","dao.xml"});

	或者用通配符:
	ApplicationContext ac = new ClassPathXmlApplicationContext("classpath:/*.xml");

	
309、	金融封装的map传出参数 
	Map<String, Object> m = acBaseDao.queryForMap("acService.acctTrans.tableAutoColumnNextval", map);
 	 Long id = Long.valueOf(String.valueOf(m.get("id")));

310、	jvm知识：
	1）、堆和方法区是线程共享的，Java栈和本地方法栈是线程私有的



311、	https：
	加密算法一般分为两种，对称加密和非对称加密。所谓对称加密（也叫密钥加密）就是指加密和解密使用的是相同的密钥。
	而非对称加密（也叫公钥加密）就是指加密和解密使用了不同的密钥。



313、	不想编译报错，处理可以抛出RuntimeException，
	Throwable是java.lang包中一个专门用来处理异常的类。
	它有两个子类，即Error（运行环境方面的异常） 和Exception（显示-编译/隐式-运行异常），它们分别用来处理两组异常。

314、	spring的事务管理：为了确保数据的完整性和一致性。
	原子性：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。
	Spring事务管理的核心接口是PlatformTransactionManager 				
	TransactionStatus status = this.transactionManager.getTransaction(TransactionDefinition definition); 返回接口的实现类，
	definition中定义的了一些基本的事务属性，根据指定的传播行为返回当前活动的事务或创建一个新的事务

	1、配置事务管理器
		<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    			<property name="dataSource" ref="dataSource" />
		</bean>
	

	2、两种事务管理方式：
		1.编程式事务管理
			可使用PlatformTransactionManager，spring中使用了TransactionTemplate模板操作
				<bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate">
        				<property name="transactionManager" ref="transactionManager"></property>
        				<!--定义事务隔离级别,-1表示使用数据库默认级别-->
        				<property name="isolationLevelName" value="ISOLATION_DEFAULT"></property>
        				<property name="propagationBehaviorName" value="PROPAGATION_REQUIRED"></property>
    				</bean>
				
			代码级别的rollback

	
		2.声明式事务管理
			一种是基于tx和aop命名空间的xml配置文件，
				 <tx:advice id="advice" transaction-manager="transactionManager">
        				<tx:attributes>
           				<tx:method name="insert" propagation="REQUIRED" read-only="false"  rollback-for="Exception"/>
        				</tx:attributes>
    				</tx:advice>

    				<aop:config>
        				<aop:pointcut id="pointCut" expression="execution (* com.gray.service.*.*(..))"/>
        				<aop:advisor advice-ref="advice" pointcut-ref="pointCut"/>
    				</aop:config>

			一种是基于@Transactional注解
  				<tx:annotation-driven transaction-manager="transactionManager"/>
				
			@Transactional(rollbackFor=Exception.class)
   			 public void insert(String sql, boolean flag) throws Exception {
        			dao.insertSql(sql);
        			// 如果flag 为 true ，抛出异常
        			if (flag){
            			throw new Exception("has exception!!!");
        			}
    			}






320、























