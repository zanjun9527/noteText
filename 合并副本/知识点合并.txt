合并时间点

1、	相关request和response操作，以及前段页面

	1.	request.getRequestURL() http://localhost:8080/jqueryWeb/resources/request.jsp
		request.getContextPath()/jqueryWeb
		request.getServletPath()/resources/request.jsp
		注： resources为WebContext下的目录名 	jqueryWeb 为工程名
	  
	2.	request.getParameter() 是从浏览器传递到服务器中的参数
		request.getAttribute() 是服务器代码暂时保留在request的值，这些值在代码中通过setAttribute后才会有值
		本页使用的变量可以用request.setAttribute("xx", xx);	
		跨页可以这样request.getSession().setAttribute("xx", xx);跨页后相应的request.getSession()然后get出来
	
	3.	response.sendredirect(url);   对服务器的响应进行重定向。当server作出响应后，client客户端的请求的生存周期就终止了。这个时候再用request.getparameter()或request.getattribute()得到的只能是null。 
		response.sendredirect(“sendredirect.htm?name=sparkwu&e-mail=spark.wu@cobra-tech.com”) 这样可以传值  
		
	4.json输出
		// 流的输出 自定义json 串或任意字符 调用方负责组装全部json串 或字符
		JSONObject jsonObject = new JSONObject();
		jsonObject.put("key","value");
		String result = jsonObject.toJSONString();
		public void printDataText(HttpServletResponse response, String result) {
			response.setContentType("text/html;charset=utf-8");
			PrintWriter pw = null;
			pw = response.getWriter();
			pw.print(result);
			pw.flush();
			pw.close();
		}
	5.动态select框
	<select class="VAILD" name="budgetType" id="unitPriceII" value="">
			<c:if test="${budgetType==null}">
			<option value="-1"  selected="selected">请选择预算费用</option>
			</c:if>
			<c:forEach items="${requireBudget}" var="item">
				<c:if test="${item.id==9}">
				<option value="" ></option>
				</c:if>
				<c:if test="${item.id!=9}">
				<option value="" ></option>
				</c:if>
			</c:forEach> 
		</select>
		
		
		<c:forEach var="addType" items="${addSers}" varStatus="addVsType">
			varStatus.index 从0开始的索引
			varStatus.count	从1开始的计数
		
	6.ftl freemarker相关
		ftl中的注释用<#-- -->
			<#if requireType=="1">
			1111
			<#elseif requireType=="4">
			444444
			</#if>  注意值加""

			<#if user??>
			${(user.name)!""}
			判空	<#if userAddress.area??>

					<#else>

					</#if>

	7.	ajax局部刷新页面案列
			<div id="context"></div>
			function toView1(act){
			var url = "${ctx}/admin/incomeCollect/toView1?act="+act;
			var option={
				url:url,
				type:"post",
				target:"#context",
				beforeSubmit:null,
				success:function(){	
				}
			};
			$("#queryInfoForm").ajaxSubmit(option);
	8.label标签没有for属性会默认制定第一个button
		<label>
			点点看<br>
			<input type='button'></input>
			<input type='button'></input>
		</label>
	9.httpServletRequest.getRequestURI()== getContextPath() + getServletPath() + getPathInfo()
		cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案
	10.	cookie：
		读取-	Cookie[] cookies = request.getCookies(); 然后遍历看cookie.getName()有匹配cookiename参数的，有则存在该cookie，
		添加-	cookie添加的时候，需要设置Path默认根路径，Domain域名，MaxAge过期时间
		
	11.data:{"reqAppointInfo":JSON.stringify(dataForm),"userId":$('#userId').val()},如果走的ajax data数据，没有传就拿不到，和表单提交不一样
	12.${}页面取值只能维持一次请求
	13.表单内容序列化
		var dataForm=serialize(releaseReqForm);
		dataForm['phoneScreen']=dataForm.cellShow;
	14.JSP,Servlet获取前一个请求的url路径
		pageContext.getRequest().getAttribute("javax.servlet.forward.request_uri")
		经常用在分页中的下一页传递一个page过去即可。
	15.跨域实现
		还可以通过跳转controller中使用httpclient来实现访问，作为中间层来回调数据，这也是目前系统最稳定的方案。
		其他的还有方案是：jsonp 跨域浏览。
	16.var name=$(this).parent().siblings('input').eq(1).val(); 获取同级第二个input元素
	17.简易的ajax：
		$.ajax({
		             type: "post",
		             url: "localhost:8080/addTalents",
		             data: {"a":"nihao"},
		             dataType: "json",
		             success: function(data){		             	      
		                      }
		       });
	18.	自定义标签的常用输出方法：pageContext.getOut().print("Hello Tag!!!");  
		<c:if test="${!fn:contains('nihao','k')}">
		不包含
		</c:if>
		this.pageContext.setAttribute(var, Constants.XYE_PAYCORE_HOSTS); 前段页面的属性赋值
	19.js的var变量在定义在函数外面的时候再页面加载好了之后就会赋值，定义在函数里才是实时数据（全局变量除外）。
	20.使用GET，form中的数据将编码到url中，而使用POST的form中的数据则在http协议的header中传输
	21.var id=$('.xms-sideboxe li').eq(i).attr('id'); 取制定元素的id内容
	22.	var dataForm=serialize(releaseReqForm);  表单序列化
		delete dataForm.appointPrice;   移除对象属性
		创建对象属性：
		var dataPrice={};
		dataPrice['userId']="203";
	23.自定义标签
		<%@ taglib uri="http://www.xiaoyuer.com/tag" prefix="xiaoyuer"%>
		web.xml中：
			<jsp-config>
				<taglib>
					<taglib-uri>http://www.xiaoyuer.com/tag</taglib-uri>
					<taglib-location>/WEB-INF/tag/xiaoyuer.tld</taglib-location>
				</taglib>
			</jsp-config>
			
	24.request.getRequestDispatcher("/list.jsp").forward(request, response); 
		提交的request做处理完了，分发到下一个JSP页面或者下一个Action继续处理。会有forward()和redirect()两种情况，forward()是request中的参数继续传递，redirect()则是重新生成request了。
	25.跨域：不同域名，相同域名但是不同端口
	26.将jquery的相关js引入到classpath下的js文件夹下，再在页面引入<script  src="js/jquery-1.8.3.min.js">，即可使用。
	27.redirect 无法共享request return "redirect:queryItem.action" 重定向路径，同级类省略类根路径，地址栏改变
		response.sendirect("url")
	
		forward 地址栏不变，共享request return "forward:queryItem.action"
		request.getRequestDipatcher("path").forward(request,response)
	28.请求时key/value对象：在ajax中 data:'name=shouji&price=90'; 常用的还有json格式


	
		
	
	
2、	缓存相关

	1.简单地比较Redis与Memcached：
        1.Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
        2.Redis支持数据的备份，即master-slave（主从）模式的数据备份。
        3.Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。
	2.
		ehcache:jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。依赖程序  单个应用或者对缓存访问要求很高的应用，用ehcache
		redis:通过socket访问到缓存服务，效率比ecache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。独立的  大型系统，存在缓存共享、分布式部署、缓存内容很大

		整合方法：mybatis自带cach的接口，实现即可：
		1、引入相关jar，配置mapper中的cache中的type为其实现类<cache type="">
		2、classpath下配置ehcache.xml
	3.	session.removeAttribute()适用于清空指定的属性   
		session.invalidate()是清除当前session的所有相关信息
		
	



应用场景
访问量大，实时性要求不高的才用缓存，缺点：mapper在commit后会清空缓存，缓存命中率很低
		
3、数据库和sql相关

	1.	ALTER TABLE `service_apply` ADD COLUMN `Price_Mode` int NULL COMMENT 'Price_Mode为0表示一口价' AFTER `Totoal_Price`;
	    UPDATE  pp_withdraw_limit_policy_config SET SINGLE_DAY_LIMIT=2000000,SINGLE_MONTH_LIMIT=2000000 WHERE id=1
	2.mybatis的自动参数绑定@param
	3.关联自身查询：
		<resultMap id="CitiesMap" type="com.xiaoyuer.core.dmo.BaseCountryArea">
  		<id property="id" column="id1"></id>
		<result property="name" column="name1"/>
		<result property="arealevel" column="Level1"/>
	 	 <association property="baseCountryArea" column="parentId1" javaType="com.xiaoyuer.core.dmo.BaseCountryArea">
	 	 		<id property="id" column="id2"></id>		----------数显多条id相同的只能接受一条，除非不查id
	  		<result property="name" column="name2"/>
	  		<association property="baseCountryArea" column="parentId2" javaType="com.xiaoyuer.core.dmo.BaseCountryArea">
		  		<id property="id" column="id3"></id>
		  		<result property="name" column="name3"/>
		  		<association property="baseCountryArea" column="parentId3" javaType="com.xiaoyuer.core.dmo.BaseCountryArea">
			  		<id property="id" column="id4"></id>
			  		<result property="name" column="name4"/>
	  		</association>
	  	</association>
	  	</association>
  		</resultMap>
		
  		<select id="selectCities" parameterType="java.lang.Integer" resultMap="CitiesMap">
  			select 
			bca1.id as id1,bca1.name as name1,
			bca2.id as id2,bca2.name as name2,
			bca3.id as id3,bca3.name as name3,
			bca4.id as id4,bca4.name as name4
			from base_country_area bca1
			LEFT JOIN base_country_area bca2 on  bca1.Parent_Id= bca2.ID
			LEFT JOIN base_country_area bca3 on  bca2.Parent_Id= bca3.ID
			LEFT JOIN base_country_area bca4 on  bca3.Parent_Id= bca4.ID
			where bca1.id=#{id,jdbcType=INTEGER}
  		</select>
		<!---城市的关联查询--->
		4.	<![CDATA[文本内容]]>标记xml中作为纯文本,但是一般不把<if>标签包括在内，包含sql语句部分即可。
			alter table `pp_withdraw_order` change `Type` `TYPE` tinyint DEFAULT NULL 数据库更改字段名
			ALTER TABLE my_user CHANGE username username VARCHAR(18) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT ”;
			数据库更改字段类型，也可以直接数据库工具修改
			
		5.	数据库操作的时候程序没有完成走完也可以用临时的数据操作，遇到事务回滚才会返回，否则顺利完成，*插入成功没数据 事务回滚
		6.	<insert id="insertSelective" parameterType="com.xiaoyuer.core.dmo.RequireInfo" useGeneratedKeys="true" keyProperty="id">返回自增id
		7.	SYSDATE() 数据库sql中获取系统的当前时间
		8.	<if test="types!=null and types.size>0">
				and type in
				<foreach item="item" index="index" collection="types" open="(" 
					separator="," close=")">
					#{item,jdbcType=TINYINT}
				</foreach>
			</if>			-----------------------------------小写
		9.timestampdiff(second ,datetime_expr1,datetime_expr2)>=#{time}	返回日期之间的整数差。其单位由interval参数给出
		10.	SQL中select round(123.456,2)	123.46	返回数字表达式并四舍五入为指定的长度或精度。
			sql中ifnull（a,0）若a非null，返回a，否则返回0
		11.修改本地数据库的密码，关键的地方是需要关闭进程中的mysql和停止服务中的mysql。cmd中执行sql语句需要加；
			数据库的导入，选中库执行sql。sql中只有表的相关操作。
		12.order by IF(ISNULL(my_field),1,0),my_field; 
			IFNULL(sum(apply_amount),0)
			group by  唯一划分 要放在最后 
		13.	select id,group_concat(name) from aa group by id; 以id分组，把name字段的值打印在一行，分号分隔
			GROUP_CONCAT(bass.ID) AS addSer
			GROUP BY requireId
			搭配使用  
		14.数据库查询如果database没有主键，查询速度会非常慢
		15.sql使用`却别关键字
		16.	update中出现select语句的更新操作,select的结果再通过一个中间表select多一次，就可以避免这个错误
			update message set content='Hello World' where id in( select min_id from ( select min(id) as min_id from mes））
		17.sql表数据转储其他库时，先建表，后倒入数据，可保持数据结构一致
		18.	主键、外键和索引的区别:
				主键--唯一标识，不重复，不为空，
				外键--是另一表的主键, 可重复, 可空，用来和其他表建立联系用的，
				索引--无重复值，可为空，提高查询排序的速度，可有多个唯一索引
			 
				设置联合主键，自增的主键不能放在最左边
				CREATE TABLE `user` (  
				`id` int(11) NOT NULL AUTO_INCREMENT,  
				`username` varchar(255) NOT NULL,  
				`nack` varchar(255) DEFAULT NULL,  
				PRIMARY KEY (`username`,`id`) 
		19、数据库查询空字段使用is null，数据库的模糊查询like		
			select * from where 字段名 like '%"+str1+"%'; 查询变量      			concat(concat('%',#{username}),'%')
			SELECT * FROM user_base_info WHERE cell_phone LIKE '%/_%' ESCAPE '/'
		20.'%${param.ValiDateNameStr}%'
		21.传参是map类型的查询语句，
			Map<String,Object> map = new HashMap<String,Object>();
			Integer updateFishfoodActiveByUserId(@Param("map")Map<String,Object> map);
					 <update id="updateFishfoodActiveByUserId" parameterType="java.util.Map" >
						update 
							user_base_account
						set 
							fishfood_active = #{map.fishfoodActive,jdbcType=INTEGER}
						where 
							user_id = #{map.userId,jdbcType=INTEGER}
					</update>
		22.	事务控制中操作数据库，如果没有走完，数据库是不会把事务提交的，即在数据库中是实时看不到操作完成的数据的，但是数据已经在缓存中发生了变化 
		23.	sql语句查询精确查询id等字段需要#{ }，根据字段排序用${ }
		24.数据模型分析
			1、分模块对每张表记录的内容进行熟悉，相当学习系统需求的过程
			2、每张表数据库重要字段的设置，非空，外键和索引
			3、数据库级别表之间的关系：**外键关系**
			
			
		25.其中使用collection可以完成一对多的映射,查询出对象中的list属性
		26.<where>可以自动去掉条件中的第一个and
		27.主键返回：
			自增主键返回

			<insert id='insertObj'>
				<selectKey keyProperty="id" order="AFTER" resultType='java.lang.Integer '>-----将查询到的主键id设置到参数属性中
					select last_insert_id()
				</selectKey >
			inser into user(...) values (....)
			</insert>

			非自增主键
			先通过uuid查询到主键，将主键输入到sql中
			执行uuid（）语句顺序相对于insert语句之前
			使用uuid创建主键，insert之前创建uuid，
				<selectKey keyProperty="id" order="BEFORE" resultType='java.lang.String '>-----将
					select uuid()
				</selectKey >


			

	
4、	前端相关操作：
	
	1. 	function goStep2(){
			mill=(parseInt(Math.random()*10000)).toString();
			url="${serverAddr}${cpath}/wservice/release?mill="+mill;
			location.href = url;
		}
		
		
5、	相关快捷键和命令
		alt+↑  代码上移
		alt+ shift+o 显示 选中的属性 高亮
		ctrl + k 和 ctrl + shift+k 快速定位
		/** + 回车  快捷注释类
		
		
		netstat -ano|findstr "8080"  查找系统当前端口号占用情况
		cmd 查看当前目录， dir
		
	
	
	
6、	soa服务化项目：

	1.测试工具 postman
	2.Spring MVC -- @PathVariable和@RequestParam   
					 jersy访问框架restful--@PathPram和@QueryParam
	
	
7、	maven相关（问题优先打包）

	1.maven依赖jar,但是没有在eclispe中导入项目也看不到源码，除非jar中有resource文件
	2.springboot中
			<plugins>  
            	<plugin>  
                <!-- 自动重动 该工程在spring boot开发过程中非常有用，当工程文件发生变化的时候工程能够自动重启生效变化的内容 -->  
                <groupId>org.springframework.boot</groupId>  
                <artifactId>spring-boot-maven-plugin</artifactId>  
                <!-- <configuration> <fork>true</fork> </configuration> -->  
            	</plugin>  
        	</plugins>  
	3.默认优先依赖本地工程，jar靠后
	4.		
	上传远程仓库  snapshot和release版本
		<version>0.0.6-SNAPSHOT</version>
		<version>3.2.0.RELEASE</version> maven的两种版本管理稳定版和快照版，pom.xml中带release和snapshot的会自动打包拿到nexus相应的目录，其他不识别的打到release目录下，打包的时候需要大写SNAPSHOT才能到正确位置，小写会打到release库下，但是引用大小写都可以。
		<distributionManagement>
			<repository>
				<id>my-nexus-releases</id>
				<url>http://192.168.6.251:8087/nexus/content/repositories/releases/</url>
			</repository>
			<snapshotRepository>
				<id>my-nexus-snapshot</id>
				<url>http://192.168.6.251:8087/nexus/content/repositories/snapshots/</url>
			</snapshotRepository>
		</distributionManagement>
		snapshot实时，但不稳定，release版本则比较稳定。Maven会根据项目的版本判断将构件分发到哪个仓库。
		分发构件到远程仓库需要认证，需在settings.xml中配置认证信息：（nexus的账号和密码），其中server元素下id的值必须与POM中repository或snapshotRepository下id的值完全一致。将认证信息放到settings下而非POM中，是因为POM往往是它人可见的，而settings.xml是本地的。
		默认nexus不允许release重复部署，本地有版本就只会依赖本地版本，不会再远程拉，没有本地才拉远程
	5.打war包名称			
				<build>
    				<!-- pojectName就是打包后的名称：pojectName.war -->
					<finalName>pojectName</finalName>
				</build>
	6.Multiple SCMs Plugin使用 jenkins同时打包两个git项目
	7.实现springboot的多环境的配置，对应的resource目录下有三个文件夹各有一个application.properties
		1.<profiles>
				<profile>
					<id>dev</id>  也可以是sit等环境
						<properties>
							<env>dev</env> 
						</properties>
						<activation>
							<activeByDefault>true</activeByDefault>			默认的激活属性配置
						</activation>
				</profile>
			</profiles>
			<build>
				<plugins>
					<plugin>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-maven-plugin</artifactId>
	           		 <dependencies>
	               		 <!-- spring热部署-->
	               		 <dependency>
	                   		 <groupId>org.springframework</groupId>
	                    		<artifactId>springloaded</artifactId>
	                    		<version>1.2.5.RELEASE</version>
	                		</dependency>
	            		</dependencies>
					</plugin>
				</plugins>
				<resources>
					<resource>	----打包的类路径classpath
						<directory>src/main/resources/${env}</directory>	----打包的目录，默认全部
						<includes>
							<include>application.properties</include>		----可以是多个include（表示只引用这个），打包固定的目录或文件，
						</includes>
					</resource>
				</resources>
			</build>
	2.过滤方式
			<profiles>
				<profile>
					<id>prd</id>
					<properties>
						<env>prd</env>
					</properties>
					<build>
						<filters>
							<filter>../vars/vars.prd.properties
							</filter>
						</filters>
					</build>
				</profile>
				<profiles>
			<resource>
				<directory>${basedir}/src/main/resources</directory>
				<filtering>true</filtering> 	----开启过滤功能
			</resource>

		maven多环境 <resources>中，pom中不指定具体的路径，默认 web deployment assembly 中配置的resource 全目录打包，配置了<resource>就会严格固定pom中的配置目录
	8.	maven命令
		测试	goals 输入 clean test
		打包	goals 输入 clean package
		打包并发送到本地仓库	goals 输入 clean install
	9.
		使用maven的tomcat插件实现热部署（打包-上传-热部署）
		修改项目的pom.xml文件,在<build> 节点下面增加如下配置:tomcat7的配置
		<build>
			<plugins>
				<!-- 配置Tomcat插件 -->
				<plugin>
					<groupId>org.apache.tomcat.maven</groupId>
					<artifactId>tomcat7-maven-plugin</artifactId>
					<configuration>
						<port>8081</port>
						<path>/</path>
						<url>http://192.168.25.136:8080/manager/text</url> 	//maven中tomcat7插件的默认热部署路径
						<username>tomcat</username>			   				//tomcat中配置的权限用户
						<password>tomcat</password>				
					</configuration>		
				</plugin>
			</plugins>
		</build>
	
	10.	pom中的${project.version} 是一个属性引用，指向了POM的project/version的值，也就是这个POM对应的version。由于app-dao的version继承于app-parent，因此它的值就是1.0-SNAPSHOT
	
8、	solr相关
	
	1.组合使用优化查询效率
		query.addFilterQuery("status:0 AND biz_type:1 AND class_id:1 AND xxx:123");  
		query.setQuery("xxx:123"); 
	2.solradmin中 sort= id desc实现倒序排序
		id:[533 TO *] 查询533之后的所有
	3.	索引的与或过滤	
		String params = "(title:笔记 OR content:笔记) AND catalog_id:2";
		SolrQuery query = new SolrQuery();
		query.setQuery(params);
	4.solr搜索的schema.xml中的id（主键，不可重命名），默认是doc的主键
	5.solr工程可以使用单核和多核的配置，	6.默认情况下，solr的日志是瞬时的，tomcat重启后，就消失了。引入相应的日志jar后，在solr-4.5.1.war的WEB-INF下建classes目录，在该目录创建文件log4j.properties，即可生成日志文件。一般我们是在使用solrj的系统中增加日志捕获异常并输出日志，不在solr工程增加。
	7.	solr异常解决
		1.SolrException: Error loading class 'solr.VelocityResponseWriter'
		vi /usr/local/tomcat/solr/collection1/conf/solrconfig.xml
		<queryResponseWriter name="velocity" class="solr.VelocityResponseWriter" enable="${solr.velocity.enabled:true}"/>注释或者disabled - enable:false即可
		重启Tomcat

		2.org.apache.solr.common.SolrException:org.apache.solr.common.SolrException: Error opening new searcher
		清空索引index

	8.权重排序，打分排序
			query.setParam("bf","addSerJJ^0.8 require_goal^0.6 recip(rord(deal_money),1.0,10000.0,10000.0)^0.1");
	9.		
		排序打分规则（boost）：

		1、定制Lucene的boost算法，加入自己希望的业务规则；（难度较大）
		2、使用Solr的edismax实现的方法，通过bf查询配置来影响boost打分。
		3、在建索引的schema时设置一个字段做排序字段，通过它来影响文档的总体boost打分。

		query.setQuery(keyField + ":" + xyeSolrParam.getQueryStr());
		query.set("qf", keyField + "^2");----  针对字段设置打分权重
	10.	solr集群，有需要可以自己研究下，暂不深究
		在tomcat中需要注册zookeeperr，solrj使用CloudSolrServer参数为zookeeper的ip和port,
		zookeeper	分布式开源、服务协调服务
		主要用处	1、配置管理 2 、集群管理
		可以单击可以集群 集群比单击版多三个参数 initLimit=5 
							syncLimit=2 
							server.1=192.168.211.1:2888:3888 
							server.2=192.168.211.2:2888:3888
		集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下对应上述的server.id
		

		初始三个参数为				tickTime=2000 
							dataDir=D:/devtools/zookeeper-3.2.2/build 
							clientPort=2181


		
9、	git
	1.eclispe的workspace中有关联.git的插件，实现与git本地仓库的代码关联
	2.两种查看项目地址的方式：1、preference-git-configuration-repository  2、项目右键查看git respository，查看properties。
	3. 版本的上线合并使用tag ，代码暂时保存需要切换其他分支做点事使用stash，stash会暂存当前的工作区内容，然后将工作区内容保持和上次提交相同，做完切换回来再恢复stash即可
	4.git版本回退：
				1、在history中的选中某个分支改动，reset（hard），之后再右键team-remote-push，选择分支强制推送，实现回退。
			     2、右键replacewith 选择相应的tag实现回退，实现的是将tag版本覆盖本地的dev分支，这时候dev会和远程有git变动
			     3、可以使用checkout挑出tag到本地，单独操作，也可以新建分支，随意
	5.git cherry-pick	用于把另一个本地分支的commit修改应用到当前分支。
	6.tag是基于分支存在的，远程有分支才能pull对应的tag
	7.	.gitconfig 文件下需要配置[receive]	denyCurrentBranch = ignore才能远程提交
		git的两个仓库之间传输，需要两个仓库独立存在，pull 和push通过url连接，push需要更新后才能执行
		git提交到本地仓库以后可以revert远程版本实现回退


10、linux相关
		1.linux的常用命令 ：
			./当前目录 ../上级目录 /根路径
			1、鼠标选中复制，右键黏贴
			2、cd..返回上级目录
			./startup.sh启动tomcat
			cd空格返回根目录
			cd空格..返回上级目录
			pwd-->示当前的工作目录（pwd:print working directory）
			find / -name dubbo-2.8.4a.jar查找某个文件
			tail -f  文件 可以实时follow日志信息
			ctrl+c 退出tail -f
			cd  / 退回到根路径
			find 查找
			:q!退出命令后加 ! 忽略提示   
			clear清屏   
			linux中的文本中?查找 		或者/
			
			ls和dir查看所有文件命令，more 查看具体的文件
			ctrl+shift+f  快速翻页
			insert或者i进入编辑模式    退出esc+:wq
			输入exit退出root用户
			
			rm -rf * 强制递归删除
			yum -y install 包名（支持*） ：自动选择y，全自动
			yum install 包名（支持*） ：手动选择y or n
			ll是会显示当前目录下的文档详细信息（包括权限、所属用户和组、大小、时间、名称等），		是ls -l的缩写；ls只显示当前目录下的文档名。
			tar zxvf zhcon-0.2.5.tar.gz	z代表gzip的压缩包；x代表解压；v代表显示过程信息；f代表后面接的是文件
			linux 下  make 编译  make install 安装 make uninstall卸载
			cp 文件 文件路径   复制文件
			cp -r 文件夹 路径  复制文件夹内容到指定路径下

			vim linux下的文本编辑器  进入后，按/，然后输入字符串，回车，按N或者n是向前向后搜索字符串    
			如果在命令行下使用vim，先按下ESC退出编辑模式，然后输入：wq 保存并退	出或者q退出或者q!强制退出，从而回到命令行界面。
			ll *.rb 查找当前文件夹下的rb文件
			mkdir 目录名    创建一个目录
			chmod +x 文件  给出文件的可执行权限
			ps | grep 和 ps aux | grep  显示运行中/所用状态的进程
			
		2.linux下配置tomcat的环境变量
		JAVA_HOME=/usr/java/jdk1.8.0_131
		JRE_HOME=${JAVA_HOME}/jre
		PATH=$JAVA_HOME/bin:$PATH
		CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
			
			
11、常用工具类

	1.DecimalFormat 数字进行格式化类
		String val = new DecimalFormat("#0.0").format(12.08);数字转换
		String format1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(date);格式时间生成
		BigDecimal bg = new BigDecimal(d).setScale(2,  BigDecimal.ROUND_HALF_UP); double四舍五入保留2位小数
	2.StringUtils
	3.spring工具类AntPathMatcher， boolean result = new AntPathMatcher().match(patternPath, requestPath) 校验路径是否匹配
	4.simpledateformat只是日期格式的转换	Calendar才是日期的操作类	yyyy-MM-dd HH:mm:ss  大小写哈哈
	5.大数据处理	BigDecimal	处理类似科学计数法的大数据类  new BigDecimal(大数据).toString()；
	6.ExceptionUtils.getMessage(e)获得异常类型

		

12.框架相关

	ssm
		1.配置mvc视图解析的时候，默认配置视webapp下的路径，配置到/jsp下就可以了
		2.<context:component-scan> ，属性base-package去扫描指定包下的class和jar文件，扫描到有@Component 	@Repository、@Controller@Service等这些注解的类，并注册为Bean类放到Bean工厂
		3.<Host appBase="webapps" autoDeploy="true" name="localhost" unpackWARs="true">
			---项目的部署路径              
		<Context docBase="D:\apache-tomcat-7.0.70\webapps\XiaoyuerProject" path="" reloadable="true" source="org.eclipse.jst.jee.server:XiaoyuerProject"/></Host>  --实际访问路径     实际的运用中可以配置图片服务器的虚拟路径
		在图片file写入磁盘的时候，采用的是路径+文件名的方式，路径最后要加上/，写入完整的路径。
		4.	属性文件载入容器管理，配置数据源
		<bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"> 
   			<property name="locations"> 
   			 <list> 
     			<value>classpath: conf/sqlmap/jdbc.properties </value> 
    			</list> 
   			</property> 
		</bean>

			<context:property-placeholder location="classpath:jdbc.properties"/>-----简化上述配置
			
			
			<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"> 
			<property name="driverClassName" value="${jdbc.driverClassName}" /> 
   			<property name="url" value="${jdbc.url}" /> 
   			<property name="username" value="${jdbc.username}" /> 
   			<property name="password" value="${jdbc.password}" /> 
		</bean>
		5.通过vars下的properties过滤到.xml下的读取直接用$[]读取，通过属性文件的加载配置PropertyPlaceholderConfigurer读取的使用${}读取，也可以代码级别的读取
		6.	<url-pattern>/</url-pattern>  会匹配到/login这样的路径型url，不会匹配到模式为*.jsp这样的后缀型url
			<url-pattern>/*</url-pattern> 会匹配所有url：路径型的和后缀型的url(包括/login,*.jsp,*.js和*.html等)
		7.依赖的jar是如何加入spring管理 ，spring加入容器管理：通过注解标签+扫描路径的方式。
		8.web容器启动过程  web.xml 的加载顺序是：context- param -> listener -> filter -> servlet
				spring分别提供了用于启动WebApplicationContext的Servlet和Web容器监听器，在web应用启动的时候来初始化WebApplicationContext:
				org.springframework.web.context.ContextLoaderServlet;
				org.springframework.web.context.ContextLoaderListener.
				
				在启动Web项目时，容器会读web.xml配置文件中<contex-param>,将读取到<context-param>转化为键值对,并交给ServletContext。
				容器对于web.xml的加载过程是context-param >> listener  >> filter  >> servlet  理发师 哈哈

				spring的启动过程：
				1、首先，对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境；
				2、其次，在web.xml中会提供有contextLoaderListener。在web容器启动时，会触发容器初始化事件，此时contextLoaderListener会监听到这个事件，其contextInitialized方法会被调用，
				在这个方法中，spring会初始化一个启动上下文，这个上下文被称为根上下文，即WebApplicationContext，这是一个接口类，确切的说，其实际的实现类是XmlWebApplicationContext。
				这个就是spring的IoC容器，其对应的Bean定义的配置由web.xml中的context-param标签指定。在这个IoC容器初始化完毕后，spring以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取；

				3、再次，contextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这个servlet可以配置多个，以最常见的DispatcherServlet为例，这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请求。DispatcherServlet上下文在初始化的时候会建立自己的IoC上下文，
				用以持有spring mvc相关的bean。在建立DispatcherServlet自己的IoC上下文时，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE先从ServletContext中获取之前的根上下文(即WebApplicationContext)作为自己上下文的parent上下文。有了这个parent上下文之后，
				再初始化自己持有的上下文。这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，大概的工作就是初始化处理器映射、视图解析等。这个servlet自己持有的上下文默认实现类也是xmlWebApplicationContext。初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为Key，
				而是通过一些转换，具体可自行查看源码)的属性为属性Key，也将其存到ServletContext中，以便后续使用。
				这样每个servlet就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文(第2步中初始化的上下文)定义的那些bean。	
				
				配置例子如下：
				<context-param> 
				<param-name>contextConfigLocation</param-name> 
				<param-value>/WEB-INF/applicationContext.xml</param-value> 
				</context-param> 

				<listener> 
				<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> 
				</listener> 
				
				前端控制器servlet
				<servlet>
					<description>spring mvc servlet</description>
					<servlet-name>springMvc</servlet-name>
					<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
					<init-param>
					 <description>spring mvc 配置文件</description>
					 <param-name>contextConfigLocation</param-name>
					<param-value>classpath:config/spring-mvc.xml</param-value>
					</init-param>
					<load-on-startup>1</load-on-startup>
				</servlet>
				<servlet-mapping>
					<servlet-name>springMvc</servlet-name>
					<url-pattern>/</url-pattern>
				</servlet-mapping>
	
				1.启动一个WEB项目的时候,容器(如:Tomcat)会去读它的配置文件web.xml.读两个节点: <listener></listener> 和 <context-param></context-param>
				2.紧接着,容器创建一个ServletContext(上下文),这个WEB项目所有部分都将共享这个上下文.
				3. servlet实例 
				
					protected void doPost(HttpServletRequest req, HttpServletResponse resp)  
						throws ServletException, IOException {  
					//获取servlet初始化参数:  
					String initParam = getServletConfig().getInitParameter("initParam");  
					System.out.println("initParam: ---->" + initParam);  
					//获取全局初始化参数:  
					String contextParam = getServletContext().getInitParameter("contextParam");  
					System.out.println("contextParam: ---->" + contextParam);  
					//获取用户提交过来的数据:  	
				String username = req.getParameter("username");  
					String password = req.getParameter("password");  
					System.out.println("用户提交的数据:" + username + " , " + password);  
				} 

				<init-parm>配置在<servlet>标签中,用来初始化当前的Servlet的,属于当前Servlet的配置,因此存放在servletConfig对象中;
				通过getServletConfig().getInitParameter("initParam")的方式获取;
				<context-param>直接配置在web.xml的<web-app>标签中,属于上下文参数,在整个web应用中都可以使用,它是全局的,因此存放在servletContext对象中(即application对象);
				通过getServletContext().getInitParameter("contextParam")的方式获取;
				<context-param>搭配ContextLoaderListener监听类使用，是spring默认的初始化容器的监听类，默认是 WEB-INF/applicationContext.xml下的路径，可以通过<context-param>自由配置路径	
				getServletContext()取得的是 <context-param>配置的参数 
				getServletConfig()取得的是 <servlet> <init-param>配置的参数
		9.	web.xml中 处理内存泄漏的问题(特定类)
			JDK中的java.beans.Introspector类的用途是发现Java类是否符合JavaBean规范，专门用来处理Introspector内存泄漏问题的辅助类。如果有的框架或程序用到了Introspector类,那么就会启用一个系统级别的缓存,此缓存会
	　  		存放一些曾加载并分析过的JavaBean的引用。当Web服务器关闭时,由于此缓存中存放着这些JavaBean的引用,所以垃圾回收器无法回收Web容器中的JavaBean对象,最后导致
				内存变大。IntrospectorCleanupListener会在Web服务器停止时清理Introspector缓存,使那些Javabean能被垃圾回收器正确回收。Spring自身不会出现这种问题，因为Spring在加载并分析完一个类之后会马上刷新
				JavaBeans Introspector缓存,这就保证Spring中不会出现这种内存泄漏的问题。但有些程序和框架在使用了JavaBeans Introspector之后,没有进行清理工作(如 Quartz,Struts),最后导致内存泄漏
			<listener>
				<listener-class>org.springframework.web.util.IntrospectorCleanupListener</listener-class>
			</listener>
		10.spring.xml和spring-mvc.xml中配置的是不同的上下文，service交给spring管理，conroller交给spring-mvc管理，两个xml中的各自配置各自的属性文件，否则对应的访问不到，controller中的注入的bean一定要是spring-mvc.xml中注入的的bean
			配置多个PropertyPlaceholderConfigurer时 重点是：ignoreUnresolvablePlaceholders属性需要设置为true
			
		11.listen ，filter，servlet相关
				基本的Listener仅仅在启动时执行一些任务
			1.	HttpServlet 包含  init()、destroy()、service()方法
				init()：启动加载，可设置Servlet 的初始化参数，并用它的 ServletConfig 对象参数来启动配置。
				service()：客户请求一个HttpServlet 对象，该对象的service() 方法就要被调用，而且传递给这个方法一个"请求"(ServletRequest)对象和一个"响应"(ServletResponse)对象作为参数。
				servlet中首先执行doService(),判断是请求是get还是post,get就调用doGet(), post就调用doPost()。也可以直接过载doService()方法，这样不管是get还是post，都会执行这个方法。  

				当服务器调用sevlet 的Service()、doGet()和doPost()这三个方法时，均需要 request和response对象作为参数。
			2.filter类实现filter接口即可，在web.xml中配置，其中共有三个方法   Filter只是链式处理，请求依然放行到目的地址或者中断直接调用重定向
				init（）是在启动项目的时候进行初始化
				dofilter（）是在拦截打匹配的路径时候进行处理，处理完用chain.doFilter(request, response)进行继续访问请求
				destroy（）当应用服务被停止或重新装载了，则会执行Filter的destroy方法，Filter对象销毁。比如改动项目的代码重新reload时候（Reloading Context）
			3.	在springmvc中继承HandlerInterceptorAdapter可以实现拦截器
				sprinboot中使用@ComponentScan(basePackageClasses = XyeManagerApplication.class）同样可以定义扫描的包路径
				
				springmvc中配置拦截器的路径，
				interceptor中处理request.setAttribute("baseUrl", Constants.URL_WEB_HOST_NEWADMIN);这样可以定义访问路径级别的全局的常量
				<mvc:interceptors>
					<mvc:interceptor>
					<!-- 匹配的是url路径， 如果不配置或/**,将拦截所有的Controller -->
					<mvc:mapping path="/**"/>
					<bean class="com.cckj.util.auth.AuthInterceptor"></bean>
					</mvc:interceptor>
					<!-- 当设置多个拦截器时，先按顺序调用preHandle方法，然后逆序调用每个拦截器的postHandle和afterCompletion方法 -->
				</mvc:interceptors>

			4.重头戏:servlet、filter、interceptor的区别

				filter：用途是过滤字符编码、做一些业务逻辑判断(登录、权限：session中的权限不够可以直接重定向)，用于请求预处理(Request、Response)，也可对HttpServletResponse进行后处理
					HttpRequest ----> Filter ----> Servlet ----> Controller/Action/... ----> Filter ----> HttpResponse
					
				spingmvc中的HandlerInterceptor的web请求流程：HttpRequest ----> DispactherServlet ----> HandlerInterceptor ---->Controller----> HandlerInterceptor ----> HttpResponse    

				1）、Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的响应。
				2）、Filter与Servlet的区别在于：它不能直接向用户生成响应。完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。
				5）、Filter面对的是所有的请求，而HandlerInterceptor是面对具体的Controller。Filter总是先于HandlerInterceptor发挥作用，
				6)、1.针对url：servlet，filter都是针对url进行的操作，
					2.针对对象：listener是针对对象的操作，它是在某个对象发生某些动作的时候执行，所以listener是提前封装好的对特定的对象的操作，只需要声明名称和类的位置即可。
					3.针对action：interceptor是针对action对象进行操作的，它在配置的时候需要和action一起配置才能起作用，当页面提交action时，进行过滤操作。
				7）、1）Filter基于回调函数，而Interceptor则基于java本身的反射机制,这是两者最本质的区别。
					 2）Filter的过滤范围比Interceptor大,Filter除了过滤请求外通过通配符可以保护页面，图片，文件等等，而Interceptor只能过滤请求，几乎所有请求起作用
				
				在interceptor中取到的信息可以放进request中，再传递到controller中	   			request.setAttribute(a,b) 构建访问级别的全局变量
				
			5.interceptor
				拦截器：
				springmvc中 实现handlerInterceptor接口，基于aop机制，
				1）、针对handlermapping进行拦截设置
				一般不用，麻烦，需要写interceptor类，注入到指定的handlermapping中

				2）、配置类似全局的拦截器，注入到每个handlermapping中,多个拦截器顺序执行
				<mvc:interceptors>
					<mvc:interceptors>
						 <mvc:mapping path='/**'/>------/**表示拦截所有url包括子url，只配/*只拦截根url
						 <bean class="">
					</mvc:interceptors>	
				</mvc:interceptors>


				1）、prehandler(request,response,object handler)-----进入handler方法之前执行，
				用于身份认证授权，
				未登录，return false 拦截不向下执行，return true 表示放行

				2）、posthandler(request,response,object handler ,mv)--进入handler方法之后，返回mv之前执行
				应用场景从mv出发，可在此处理模型和数据

				3）、afterCompletion(request,response,object handler ,mv,exeception)---执行handler完成执行
				统一异常和日志处理


				当多个拦截器拦截统一请求时，
				I、拦截器1、2同时放行
				prehandler按顺序执行，posthandler，afterCompletion按拦截器配置的逆向顺序执行，优先过滤原则，进出把关
				II、拦截器1放行，2不放行
				拦截器1prehandler放行，拦截器2的prehandler才会执行，拦截器2prehandler不放行，1、2后续都不执行
				III、拦截器1、2都不放行
				执行到拦截器1prehandler return false 结束

				用例1、统一日志处理拦截器，需要该拦截器prehandler一定要放行，且将它放在拦截器链中的第一个位置

				用例2、登录认证拦截器，次先放在拦截链第一位置，权限检验放在其次
				测试用例：1.用户请求url
					  2、判断书否是url白名单
						 拦截器拦截校验 session存在，放行，不存在，调转登录页面
				
				
				
				
						
		12.使用SqlSessionDaoSupport ，在mybatis的中实现dao实现类，使用可获得sqlsession
				@Repository
				public class UserDAOImpl extends SqlSessionDaoSupport implements UserDAO

				@Autowired(required = false)
				 @Qualifier("sqlSessionFactory")
				 public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
						super.setSqlSessionFactory(sqlSessionFactory);
					}

				使用sqlsession.getMapper(CLASS)使用的是初始的mybatis操作，加载mybatis配置后使用，
				在整合spring以后，直接使用mapper方法即可

				总结：
				1、原生的jdbc操作需要具体拼装sql执行
				2、mybatis初始，可以使用dao，sqlsession.执行（）实现，
				也可使用mapper代理，namespace需要和mapper路径一致，sqlsession.getmapper()，未整合spring，无法扫描到mapper接口的位置
				3、整合spring之后，mapperscanner直接使用mapper方法调用
		13.spring配置datasource的方式
			使用jndi需要在tomcat中增加数据源jar和logjar，并在context.xml中新增resourcejndi配置
			1、xml中注入配置datasource，需要指定数据源，目前用的是数据源jar是druid版本，在指定一些常规数据库连接属性即可
			2、 应用配置在高性能的应用服务器上，使用应用服务器本身提供的数据源。Spring为此专门提供引用JNDI资源的JndiObjectFactoryBean类。
				<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">      
						<property name="jndiName" value="java:comp/env/jdbc/bbt"/>      
				</bean>  

			代码端：	Spring 2.0提供了一个jee命名空间，通过jee命名空间，简化J2EE资源的引用。
						<jee:jndi-lookup id="dataSource" jndi-name=" java:comp/env/jdbc/bbt"/>
			服务器端：	然后在tomcat中的context.xml中配置
						<Resource auth="Container" driverClassName="com.mysql.jdbc.Driver" maxActive="100" maxIdle="40" maxWait="12000" name="jdbc/XiaoyuerProject" password="db_xiaoyuer" type="javax.sql.DataSource" url="jdbc:mysql://192.168.6.251:3306/db_xiaoyuer_xq?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;generateSimpleParameterMetadata=true" username="db_xiaoyuer"/> 
		 
			sprinboot中配置@bean 注入datasource，则以配置的为准，默认的取消 DataSourceBuilder使用该类配置数据源
		14.	web.xml 启动停止监听类
			ServletContextListener 接口，它能够监听 ServletContext 对象的生命周期，即监听 Web 应用的生命周期。
			当Servlet 容器启动或终止Web 应用时，会触发ServletContextEvent 事件，该事件由ServletContextListener 来处理。在 ServletContextListener 接口中定义了处理ServletContextEvent 事件的两个方法。
			* 当Servlet 容器启动Web 应用时调用该方法。在调用完该方法之后，容器再对Filter 初始化， 并且对那些在Web 应用启动时就需要被初始化的Servlet 进行初始化。 contextInitialized(ServletContextEvent sce)   
			* 当Servlet 容器终止Web 应用时调用该方法。在调用该方法之前，容器会先销毁所有的Servlet 和Filter 过滤器。 contextDestroyed(ServletContextEvent sce)  
			在Container 加载Web 应用程序时（例如启动 Container 之后），会呼叫contextInitialized() ，而当容器移除Web 应用程序时，会呼叫contextDestroyed () 方法。
	springmvc
		
		1.上传图片:
		tomcat的server.xml中添加虚拟目录，方便代码和图片在一台电脑上测试用	
		<Context path="/helloapp" docBase="docBase="D:\web\helloapp" reloadable="true"/>
		springmvc的上传功能：1、form的中增加enctype=”multipart/form-data”
							2、 spring.mvc中需要增加multipartResolver解析器
							3、controller中使用MultipartFile 接受处理
							4、图片目录分级可以提高io能力
							5、采用file.transferTo 来保存上传的文件
							
							
			2.
	34、springmvc（注解版）
	基本类容：
	需要掌握东西：前端控制器 、处理器映射器（注解和非注解）、处理器适配器、视图解析器   搭配模型图更直观
	springmvc注解的开发：
		1）、常用注解
		2）、参数绑定（简单类型，pojo，集合类型）
		3）、自定义参数绑定

	mvc 模型视图控制器 在一次request请求的生命周期 request--->c(控制器controller)--->m模型处理（dao，service）--->返回c--->v（view）视图渲染

	springmvc request--->前端控制器（dispatcherservlet接受请求和响应结果相当于转发器）--->处理器映射器（handlerMappering 根据url匹配相应的handler）--->返回一个执行链（handlerExecution包含interceptor和handler：handler处理器（平时controller），不同的handler由不同的处理器适配器(handlerAdapter：按特定规则执行handler)调用执行）--->返回modelandview到适配器再到前端控制器--->由视图解析器返回view（是个接口，支持不同的view类型）进行视图渲染
	  handlerAdapter：负责数据转换，数据绑定，数据验证

	搭建springmvc
	1、在web.xml中配置前端控制器
	1）、配置dispatcherServlet的url-pattern有三种方式：1、*.action 2、/ 3、/* 这种不对，当转发到一个jsp页面时，仍然会由dispatcherServlet解析jsp,不找到handler
	2）、dispatcherServlet中的init-param需要指定contextconfiguration和springmvc.xml（配置handleradapter和handlerMappering等 ），默认是加载/WEB-INF/servlet名称―servlet.xml

	2.在springmvc.xml中
		1.开启mvc注解驱动，配置映射器和适配器（怎么处理这个handler，是mv还是request）
		<mvc:annotation-driven></mvc:annotation-driven>  。annotation-driven 默认绑定了很多参数绑定方法，代替了requesrMappingHandlerMapping和requesrMappingHandlerAdapter
		×××××返回的mv是一个map，将其填充到request域中（request.setAttribute），前端页面可取值×××××
	 
		@requestMapping实现方法和url的映射。、
		@Controller注解，即表示改类是Handler处理器。
		对标记@controller类中标记@requestMapping的方法进行映射，映射相应的url

		2.使用扫描包驱动，<context:componet-scan base-package=""></context:componet-scan>指定controller，添加进入容器
	3、视图解析器，xml中配置相应的bean即可。

	springmvc和mybatis的整合：
	框架层次：表现层（springmvc），业务层（spring）、持久层（mybatis）
	spring将各层进整合，通过spring管理持久层的mapper接口，通过spring管理业务层的service，通过springmvc管理表现层的handler
	1、整合dao层：mybatis和spring整合，mapperscanner扫描和mapperconfig
	2、整合service：管理service接口，配置或标签，实现事务控制
	3、整合springmvc：是spring的模，无需整合

	简约版配置：
	整合mybatis
	1)、配置mybatis的mybatis.xml中只需要配置分页插件
	2)、spring-mybatis.xml主要将dao整合到spring中，主要是将sqlsessionfactory（包含mybatis.xml和datasource）注入容器中,再将mapper扫描注入容器（实现@autowire注入）

	整合spring
	配置spring的事务管理：
	1）、事务管理器，spring-jdbc
	2）、通知<tx:advice></txadvice>
	3)、<aop:config></aop:config>
	 
	整合springmvc
	1）、组件扫描<context:componet-scan base-packge=""></context:componet-scan>扫描controller
	2）、mvc注解驱动，<mvc:annotation-driven></mvc:annotation-driven>
	3)、视图解析器


	高级内容： 

	参数绑定:处理器适配器调用springmvc的参数绑定组件（converter）获取形参，执行controller
	简单传入：
		1）、简单类型 @requestparam（value，required，defaultvalue） 不使用则  request传入的名称和controller的形参名需一致
		2）、pojo类型
			2I）、不使用标签，页面的name属性和形参pojo的属性name一致，使用的话应该是@modelattribute
		3）、自定义类型 pojo有日期类型，converter<T1,T2>由string转为date，需要自定义，在mvc注解驱动中增加comversion-service="beanid"，目的是在springmvc的绑定组件中注入自定义的转换类。

	高级绑定：
		pojo： 传入pojo中的pojo属性：页面中name="userInfo.name"
		数组：页面中共用相同的name值即可，name="userId"，传到后台就是 Integer[] userIds
		list: userInfo中有个List<pojo> pojoList，页面name="pojoList[index].name"
		map:页面中name="userInfo['name']" -----key-value
	校验：
	主要是后端的服务端校验-validation校验框架，springmvc的校验框架（引入hibernate-validator-4.3.0final.jar,jboss-loggging-3.1.0.CR2.jar,validation-api-1.0.0.GA.jar）
	validator需要注入适配器（配置校验器bean和返回bean，这里使用的是返回properties，个人认为是加入容器，快速读取，{}读取即可），通过mvc注解驱动注入，validator="beanname"
	在形参校验的bean前加@validated 其后需要跟着BindingResult bindingResult，有一个pojo校验就需要跟一个bindingResult,形参顺序一前一后，在对bindingResult进行判断即可。
	多个controller共用一个校验pojo时，pojo中可以指定校验分组，group属性group={validate1.class},校验分组是一个空接口，形参中指定@validated（validate1.class）即可
								
								
	mybatis
		mybatis提供查询缓存：
		一级缓存:sqlSession级别的缓存
		一级缓存  一次存:sqlSession开启关闭
		第一次查询，没有则数据库中查出并添加进一级缓存
		中间如果有commit操作，则会清空全部，保证数据实时更新
		第二次查，缓存中有直接获取，有commit会从数据库重新查

		应用：正式开发，是将maybatis和spring进行整合，事务控制在service中，开始执行时就开启事务，创建sqlsession对象，方法结束sqlsession结束
		执行两次service调用查询信息，不走一级缓存，因为session方法结束一级缓存就会清空

		二级缓存:mapper级别的缓存
		默认不开启，需要手动开启   usecache=false设置禁用二级缓存
		多个sqlsession可以共享一个mapper的二级缓存区域（按照namespace区分）
		sqlsession关闭才能将数据写到二级缓存区域，commit后都会清空二级缓存sqlsession.getMapper()，多个sqlsession之间可以跨，因为二级缓存是针对mapper的
		
		应用场景
		访问量大，实时性要求不高的才用缓存，缺点：mapper在commit后会清空缓存，缓存命中率很低
									
		
		38、mybatis
  
			原生jdbc访问：
			需要加入mysql连接驱动 
			一般顺序，
			1、加载数据库驱动 			Class.forName("com.mysql.jdbc.Driver")
			2、获取数据库连接			connection
			3、获取拼装预处理sql			prepareStament
			4、执行prepareStament得到结果集		resultSet

			问题存在：
			1）、数据库连接，使用创建connection，不用立即释放，频繁开启关闭，影响性能 			解决方案：使用数据库连接池
			2）、sql硬编码					解决方案：sql语句和参数配置在xml文件中，resultSet转为java对象



			使用mybatis
				框架选型：
					mybatis和hibernate：技术选型，低成本，高回报为原则
					hibernate:是一个标准的orm框架，不需要写sql，自动生成
					应用场景：适应需求变化不多的中小型项目，比如后台管理项目

					sqlsession线程不安全，除了操作数据库的方法，还有数据域属性，其最佳的应用场合在方法体内，定义成局部变量

					mybatis：专注sql本身，需要自己写sql，比较灵活
					应用场景：需求变化较多的项目，互联网项目

			执行顺序：
			配置mybatis配置文件，--》sqlSessionFactory--》sqlsession--》sqlsession内部executor执行器操作数据库--》mappedstatement（底层封装对象），存储封装，输入输出

			使用mapper代理开发
			未整合的mybatis使用，：
			1、得到配置文件流，
			2、得到会话工厂，传入配置文件
			3、得到sqlsession，操作数据库
			4、结束sqlsession会话    sqlsession.close（）
			User user=sqlsession.selectOne("test.findUserById",id)首参=namespace.方法id,次参=传入参数
				
			这里使用的是sqlsession原生封装的mapper方法，比较固定
			*mapper.xml中的resultType表示单条记录映射的java对象类型
			1）、#{}表示一个占位符,体现在sql上是 =？ parameters：
			2）、${}表示拼接sql串，将接收到的参数内容不加任何修饰拼接在sql中，直接拼接在sql中，但是可能引起sql注入 比如：select * from user where name like '%'or 1=1 or'%'

			执行insert操作需要手动提交事务，sqlsession.commit()


			dao的开发方法：
			1）、原始dao开发方法，需要写dao接口和dao实现类
			思路：dao实现类中注入sessionfactory，在方法体内通过sessionfactory，创建sqlsession
			interface-impl使用sqlsession操作，sessionfactory作为impl属性值，由构造函数引入，sqlsession在方法体内操作数据库

			总结：I、dao接口实现类存在大量的模板方法，
				  II、调用sqlsession方法时，将statement的id硬编码，sqlsession.selectOne("test.findUserById",id)
				  III、调用sqlsession方法时传入变量，由于使用的是泛型，编译阶段即使变量传参类型错误，也发现不了问题

			2）、mapper代理方法，只需要mapper接口（dao接口）
				I、namespace映射mapper
				II、xml中的id和mapper中方法名一致
				III、入参传参一致
			总结:封装了sqlsession的方法操作
			 
			1、通过sqlsessionfactory得到sqlsession
			2、生成mapper代理对象	UserMapper userMapper=sqlsession.getMapper(UserMapper.class )
			3、mapper方法执行，可以使用同一包装item最为入参（不推荐不灵活），也可以@param指定多个
				代理对象内部调用sqlsession方法:
				mapper方法返回单个pojo对象，代理对象内部就会使用sqlsession.selectOne（），根据mapper的返回类型，判断内部执行的是selectOne还是selectList
				

			4、typeAlias定义别名，mybatis扫描packsge中的po类，别名是类名resultType=“user”	
				通过mapper接口加载，mappers中的<package name="包名">
				




			spring和mybatis整合
			思路：
				1.需要spring通过单例方式管理sqlsession
				2.spring和mybatis整合代理对象，使用sqlsessionfactory创建sqlsession(spring和mybatis自动完成）
				3.持久层的mapper都需要由spring进行管理

			整合过程：
				1.相关spring的jar mybatis的jar  和spring-mybatis整合jar
				2.配置sqlsessionfactory （1.configlocation：mybatis.xml和2.datasource）,存在spring-mybatis的jar中

			原始dao开发（使用sqlsession操作） *****继承sqlsessiondaosupport*****    以往是通过构造方法注入
			在原始的dao开发中，实现类可以继承sqlsessiondaosupport，调用this.getSqlSession()获取sqlsession操作对象 
			整合spring后是交给spring管理sqlsession，无需手动关闭sqlsession，是方法级别的销毁

			mapper代理开发
			1.使用mapperFactoryBean可以单一添加mapper代理对象，指定mapperInterface和sqlsessionfactory（因为bean继承了sqlsessiondaosupport），单一模式不常用
			2.项目中使用的是mapperscanner，扫描出mapper接口，自动创建代理对象并且在spring的容器中注入
			<bean class="....mapperscannerconfigurer">
				<property name="basePackage" value=""> 扫描多个包，使用半角，分割
				<property name="sqlsessionfactoryBeanName" value="sqlsessionfactory">  
			</bean>

			容器启动mapper扫描会先执行，datasource配置 中，属性文件加载暂时无效，不能配置name="sqlsessionfactory" ，一般无需注意，有个印象就可以
			至于mapper映射文件，属于sqlsession操作的范围，整合到sqlsessionfactory中也可以
			  <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">  
					<property name="dataSource" ref="dataSource" />  
					<!-- 自动扫描mapping.xml文件 -->  
					<property name="mapperLocations" value="classpath*:dao/*.xml"></property>  
				</bean>  


										
		
	springboot:
		1.接口测试中：
			@Consumes({ ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8 })	请求指定
			@Produces({ ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8 }) 	返回指定
		2.springboot  bean.setTypeAliasesPackage("com.xiaoyuer.core.**.dmo");	通配符配置多路径，com.xiaoyuer.core.dmo和com.xiaoyuer.core.talents.dmo             
		3.	springboot搭建	
			1）、springboot默认contextpath的路径为/,部署在了root下       @RestController =@Controller +  @ResponseBody  
			2）、springboot支持需要添加tomcat-jsp解析包
					<dependency>
							<groupId>org.apache.tomcat.embed</groupId>
							<artifactId>tomcat-embed-jasper</artifactId>
					</dependency>
			3）、springboot的入口类 如果按官方的项目结构加上@SpringBootApplication即可，自定义特殊的目录结构需要加上自动配置和扫描等标签

			5）、springboot整合mybatis需要引入数据库连接依赖，主要是配置sqlsessionfactory（注入datasource目前是application中配置，内含*mapper.xml配置，@Configuration和
				@EnableTransactionManagement(proxyTargetClass=true)）和mapper扫描（需要在sqlsessionfactory配置完成之后，@Configuration和@AutoConfigureAfter(MybatisConfig.class)），
				具体实现是mybaitsConfig.java和mapperScanner.java，   	

			6）、springboot也支持xml配置，在启动类上加上@ImportResource({"classpath:config/spring-mvc.xml"})即可注入配置 ，配置spring-mvc 建议使用官方的xml头文件
		4.Spring Boot应用程序在启动后，会遍历CommandLineRunner接口的实例并运行它们的run方法，实现启动类的加载，从容器中寻找。
		5.springboot工程搭建继承springboot 的parent
			<parent>
				<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-parent</artifactId>
					<version>1.5.3.RELEASE</version>
			</parent>
		pom库直接依赖实现pom依赖
		6.	springboot启动类的@ComponentScan一定要包括config包，启动一定要扫描到mapper


13.redis相关
	1.redis-cli.exe -h IP -p 6379,  这个要在redis-cli.exe 所在目录下面，-h后面接redis服务器的IP地址，-p后面接端口 
	2.redis加入环境变量并配置开机启动
	将D:\redis加入系统环境变量;使用sc create redis binpath= "D:\redis\redis-server.exe redis.conf" displayname= "redis" start= auto 
	命令注册windows服务使其开机启动。
	3.	redis持久化的方案：
		RDB持久化：指定的时间间隔内将内存中的数据集快照写入磁盘，不过实时的可能会数据丢失，速度快
		AOF持久化：将每一个收到的写命令都通过write函数追加到文件中(默认是 appendonly.aof)，速度慢、体积大，可设置不同的fsync 策略，安全性高
	4.关闭指定端口的redis，redis01/redis-cli -p 8080 shutdown
	5.	redis 127.0.0.1:6379> TTL KEY_NAME 			Redis TTL 命令以秒为单位返回 key 的剩余过期时间。
		redis是单线程，不会设计多个线程并发的问题
	6.redis集群分布式节点一般一主一备，当任意master挂了没有备份或半数以上的master挂了则集群不可用   
	7.jedis客户端  单个jedis、jedispool和jediscluster
	
14.分布式和高并发相关
	分布式
		1.session共享
			代码级别的session共享			1、走拦截类，但此时request.getsession是不同步的，只能从redis中取出相应的值，存在则已经登录，但是这是redis使用，表面的登录，此时两个服务器的session是不同步的

			tomcat级别的session共享
			2、tomcat级别的session共享，相当于使用redis实现两个服务器的缓存共享
			
			3.主站和soa之间不存在跨域问题，接口在spring-dubbo.xml中有注册，通过注册的地址，实现远程调用
			soa服务化和主站对接   注册zookeeper，启动soa，主站依赖soa的api，通过jar引入主站的spring管理，通过dubbo配置，实现调用。
		2.跨系统之间的数据类传输需要序列化处理，特点是保持对象的属性状态。但不是每个类都可序列化，例如涉及线程的类与特定JVM有非常复杂的关系。
		3.序列化和反序列化需要包名一致，具体参照soa-api，
		4.hessian实现远程方法的调用:HessianServiceExporter或者HessianProxyFactory，基于基于http的二进制传输rpc框架
			如果在远程调用时，用到了自定义的实体，必须序列化
			在hessian接口调用时候，可设置超时时间，必须要考虑超时情况下，客户端和服务端数据回滚情况，尤其是金融相关问题，两边可以打上tag，实时验证。
			在调用时需要分别配置服务端和客户端的配置，客户端主要是加入容器bean，服务端是拦截路径交给hessian处理转至相应的serviceimpl处理，返回
			
			客户端――>序列化写到输出流――>远程方法(服务器端)――>序列化写到输出流 ――>客户端读取输入流――>输出结果
			目前想到的和dubbo的区别是，hessian只能连接单一远程服务，但是dubbo可以有zookeeper提供多个提供者
		5.	依赖的api通过dubbo.xml注入容器，并通过zookeeper的地址实现调用，
		6.		rpc框架的一些知识:
				1.想调用本地服务一样调用远程接口的服务，特点需要暴露统计的接口api
				2.两种方式：同步或异步调用，区别在于是否等待服务端执行完成并返回结果。
				3.RPC 框架提供接口的代理实现
				4.对于同一语言而言，RPC可以共享接口定义，
		7.dubbo
			zookeeper挂机，提供者和消费者联系
			可以的，启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存	在本地。每次调用时，按照本地存储的地址进行调用
			1.dubbo
				传输协议：TCP
				传输方式：NIO异步传输。非阻塞型的io，      
				序列化：Hessian二进制序列化

	
	
	
	
	高并发
		1.nio
		传统的socket io需要为每个连接创建一个线程，开销巨大；
		使用NIO，可用一个含有限数量的线程的线程池，甚至一个线程来为任意数量的连接服务。由于线程数量小于连接数量，所以每个线程进行IO操作的时候就不能阻塞，如果阻塞的话，有些连接就得不到处理，NIO提供了这种非阻塞的能力。
	
		2.并发锁的问题
			select for update 数据库的悲观锁 在高并发长事务情况下容易发生锁表问题
			改善方案，使用数据库的乐观锁，表中增加version字段，每次更新+1，数据库根据version操作即可
			数据库的update使用时 where 条件需要使用主键或者索引，防止长事务锁表
		3.	AtomicInteger提供原子操作来进行Integer的使用，通过线程安全的方式操作加减，因此十分适合高并发情况下的使用。但是效率相对低，高并发适用
		4.数据库的操作是原子性的，是单线程的，代码对象的更新数据库，在多人同时操作的时候，有可能出现高并发的问题。
		5.nginx
			nginx中的config文件中一个server就是一个虚拟主机
			客户端均衡--->nginx--->tomcat 请求经过nginx转发，由tomcat处理，这样叫反向代理，多台tomcat就叫做负载均衡（仅对httpserver如tomcat有效）
			nginx配置以下三种方式：
			1）、ip
			2）、端口
			3)、域名 		这个是最常用的
			一个域名只能绑定一个ip，一个ip可以被多个域名绑定
			通常ip地址是和dns服务器（根据域名换ip地址）绑定一起的，
		
			www.baidu.com-->dns服务器---->取得对应的ip地址---->访问百度的服务器,默认的是80端口
			在host文件中，如果配置了ip对应的域名，就会跳过dns解析，进行访问
			反向代理决定哪个服务器提供服务，最简单的比如轮询，nginx只做请求的的转发给服务器，
		6.
		nginx配置负载均衡：http节点下，添加upstream节点。
		upstream linuxidc { 
     		 server 10.0.6.108:7080; 
      		 server 10.0.0.85:8980; 
		}
  		2.  将server节点下的location节点中的proxy_pass配置为：http:// + upstream名			称，即“http://linuxidc”.默认的分配策略是轮询，其他暂不研究
			高可用：解决高可用的方案就是：添加冗余（备用一主一备）一般用keepalived(集群管理中实现高可用，防止单点故障),不断检查主nginx是否正常，异常就启用备用nginx，主正常，在切换回去。
		
	
15、nginx相关
	1.nginx反向代理原则是，优先匹配全路径，然后再依次匹配后面的路径
	2.nginx.exe -t 检查配置文件是否正确
	3.nginx可以监听80端口将不同域名绑定到tomcat上的不同端口的不同项目
	 nginx是监听的本地ip，所以要改host文件域名，搭配使用，默认http是80端口，https是443端口，浏览器默认不显示端口域名，不得使用已经注册的域名


16、反射动态代理相关
	1.	Field对于到一个成员对象, 这个和类定义是相关的.如果Field拿到的是static, 则get(null)取得当前field的值.
		Field是一个实例成员对象, 那么我们传入一个 对象实例, 拿到对象实例 的实例成员 的值. 案例代码如下：	
	
		Field f=Counter.class.getField("count"); //拿到Counter类的count 实例域
		Counter c=new Counter();                 //一个Counter对象实例
		Long l=(Long) f.get(c);                  //拿到对象实例的 域成员的值
	2.	field.setAccessible(true); 忽略访问修饰符权限
	    field.get(obj),对象实例换取对象的属性值，拿到对象实例的 域成员的值
		
	3.	setAccessible(true) 并不是将方法的访问权限改成了public，而是取消java的权限控制检查。所以即使是public方法，其accessible 属相默认也是false
		实例:BeanUtils.copyProperties()来复制属性，对象的名称要匹配，不匹配不转，复杂属性类型需一致，否则argument type mismatch，常规属性类型的可以不一致，复杂类的属性复制，this.value=value全属性覆盖
		PropertyUtils的工具类，它也提供copyProperties()，并且还提供类型转换的功能，但两者都不支持date类型，这种的速度相对要慢
		反射本身的field可以直接设置，也可以通过setMethod.invoke()设值
	4.	aop
		将业务需求与系统需求分开来做，不具有继承关系的对象引入一个公共行为，会造成代码重复，这时提现aop的好处
		使用@aspect或者xml中配置
		
		两种动态代理的模式：1、jdk动态代理	jdk实现的代理要求被代理类基于统一的接口，基于反射机制实现
							2、cglib动态代理	采用动态创建子类的方法，对于final方法，无法进行代理 字节码技术

		1.默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了,基于接口
		2.不是接口，使用CGLIB代理，也可强制使用，<aop:config>proxy-target-class属性设为true


		动态代理的核心就是代理对象的生成	Proxy.newProxyInstance(classLoader, proxyInterface, handler)
		切面aspect的中可包含多个通知（Advice）
		代理实现InvocationHandler

		通知执行顺序：前置通知→环绕通知连接点之前→连接点执行→环绕通知连接点之后→返回通知→后通知→(如果发生异常)异常通知→后通知
		×××代理其实是在原实例前后加了一层处理，堆原来的类进行了包装，并使用代理类来执行***
		
	5.	java反射：动态获取类中的信息
			getDeclaredMethod()获取类自身声明的所有方法，包含public、protected和private方法。
			getMethod()获取类的所有共有方法，包括自身的所有public方法，和从基类继承的、从接口实现的所有public方法。
			method.invoke(pbj,param)
	


		
	

17、代码测试： 主要还是postman和juint
	1、主函数中测试，这种只支持一些常规类的创建对象测试，无法注入interface，mapper，applicationContext等，无法进行接口等测试
	2、junit测试，入口属于代码接口测试，在项目中添加library中添加junit，即可进行单元测试
			<dependency>
    				<groupId>junit</groupId>
    				<artifactId>junit</artifactId>
    				<version>3.8.1</version>
    				<scope>test</scope>
			</dependency>
			在sprinboot中：
				@RunWith(SpringJUnit4ClassRunner.class) // SpringJUnit支持，由此引入Spring-Test框架支持！ 
				@SpringBootTest(classes = XyeServiceCoreApplication.class) // 指定我们SpringBoot工程的Application启动类
				@WebAppConfiguration 
				public class TalentsSearchServiceImplTest {
					@Autowired
					ITalentsSearchService  talentsSearchService;
					@Test
					public void testSelectUsersInfoBycellPhones() {
						BaseModelInfo<usersInfoBean> selectUsersInfoBycellPhones = talentsSearchService.selectUsersInfoBycellPhones(1, 202, "18862241316");
					}
				}
			在普通的ssm工程中：在这里是在war工程中进行测试，也因为各个jar的引用集中，mybattis也是集成在这里。不引入spring-mvc.xml的原因是这里是接口测试，无需controller相关，引入spring.xml是获得容器中的service，引入spring-mybatis.xml是因为接口中需要mapper等，否则接口注入失败
				@RunWith(SpringJUnit4ClassRunner.class)
				@ContextConfiguration(locations = { "classpath:spring.xml","classpath:spring-mybatis.xml" })
				public class UserInfoServiceImplTest {
					@Autowired
					IUserInfoService userInfoService;
					@Test
					public void test() {
						UserInfo selectById = userInfoService.selectById(203);
					}
				}

	3、postman测试，这种入口是路径测试
		在spring 接受参数是@pathvariable和@requestparam
		在springboot jboos中节后参数是@pathparam，@queryparam和@requestparam   @path标签和这些标签的匹配比较严格


	4、debug从前端页面到controller进入测试，这种在前后端分离的开发过程中是行不通的
	
18.事务控制和异常处理
	spring的事务管理：为了确保数据的完整性和一致性。核心接口是PlatformTransactionManager
	原子性：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。	

	1、配置事务管理器
		<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    			<property name="dataSource" ref="dataSource" />
		</bean>
		
	TransactionStatus status = this.transactionManager.getTransaction(TransactionDefinition definition); 返回接口的实现类，
	definition中定义的了一些基本的事务属性，根据指定的传播行为返回当前活动的事务或创建一个新的事务



	2、两种事务管理方式：
		1.编程式事务管理（代码级别的rollback）
			可使用PlatformTransactionManager，spring中使用了TransactionTemplate模板操作
				<bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate">
        				<property name="transactionManager" ref="transactionManager"></property>
        				<!--定义事务隔离级别,-1表示使用数据库默认级别-->
        				<property name="isolationLevelName" value="ISOLATION_DEFAULT"></property>
        				<property name="propagationBehaviorName" value="PROPAGATION_REQUIRED"></property>
    				</bean>
				
			spring的事务模板，使用匿名内部类并进行封装，使用TransactionCallback()可以返回一个值。
			如果使用TransactionCallbackWithoutResult则没有返回值。
			可以手动可以抛出RuntimeException，让事务回滚
			Object tmpResult = this.transactionTemplate.execute(new TransactionCallback()
			 {
				 public Object doInTransaction(TransactionStatus status)
				 {
						return serviceCallback.invoke();
				 }
			 }); 
			 
	
		2.声明式事务管理
			一种是基于tx和aop命名空间的xml配置文件，
				 <tx:advice id="advice" transaction-manager="transactionManager">
        				<tx:attributes>
           				<tx:method name="insert" propagation="REQUIRED" read-only="false"  rollback-for="Exception"/>
        				</tx:attributes>
    				</tx:advice>

    				<aop:config>
        				<aop:pointcut id="pointCut" expression="execution (* com.gray.service.*.*(..))"/>
        				<aop:advisor advice-ref="advice" pointcut-ref="pointCut"/>
    				</aop:config>
					
		spring基于aop的事务管理：
		1.spring aop  异常捕获原理：被拦截的方法需显式抛出异常，并不能经任何处理，这样aop代理才能捕获到方法的异常，才能进行回滚，默认情况下aop只捕获runtimeexception的异常，但可以通过配置来捕获特定的异常并回滚  ！

		2. 如果是service层处理事务，那么service中的方法中不做异常捕获，或者在catch语句中最后增加throw new RuntimeException()语句，以便让aop捕获异常再去回滚，并且在service上层（webservice客户端，view层action）要继续捕获这个异常并处理
		3.也可catch后手动回滚，这样上层就无需去处理异常（现在我的项目的做法）

			一种是基于@Transactional注解
  				<tx:annotation-driven transaction-manager="transactionManager"/>
				
			@Transactional(rollbackFor=Exception.class)
   			 public void insert(String sql, boolean flag) throws Exception {
        			dao.insertSql(sql);
        			// 如果flag 为 true ，抛出异常
        			if (flag){
            			throw new Exception("has exception!!!");
        			}
    			}
				
	3.异常处理：
		springmvc提供了全局异常处理器进行统一异常处理（唯一），是抛到前端控制器交给统一异常处理器处理  
			预期异常：
			runtimeException：
		定义异常处理器，需要实现handlerExceptionResolver接口，并需要在springmvc.xml中注入
		自定义的异常信息类需要继承exception类
				
				
				
		

19.单点登录的主要实现方案：
		1、服务接口的开发
		2、在分布式环境中使用redis实现session共享（缓存唯一token和对应的用户信息）
		3、使用cookie在多个系统中共享。（存放token信息）
		4、拦截器的使用方法（访问校验cookie中的token是否存在或过期）
		
架构相关
	1.restful支持： 
		restful架构的特点：
		对url进行规范，常用
		非rest url http://.../queryitem?id=001&type=t01
		rest url   http;//.../item/001
		****实现rest访问 前端控制器需要配置/拦截****
		配置/ 	那么静态资源js也会由前端控制器拦截，所以找不到，
		在springmvc.xml中添加静态资源解析即可，<mvc:resources location='/js/'  mapping='/js/**'>

	
	
	

		
		
杂知识点：

	1.两个Integer变量不能直接==，需要intvalue（）后判断
	2.内部类：
		静态内部类可以直接创建对象new B.C();
		如果内部类不是静态的，那就得这样
		B b = new B();
		B.C c = b.new C();	 
		
	3.@Value("${PAGE_RETURN_URL}") 属性读取的条件是需要将属性文件加入容器
	4.加载类的时候，默认执行无参构造，使用有参构造，则只执行有参构造
	5.多个tomcat实例运行：
			1、复制多个tomcat目录副本,catalina.bat中不需要改动（已实用）
			修改startup.bat和shutdown.bat文件头下加，实现多个tomcat的运行
			SET JAVA_HOME=C:\Program Files\Java\jdk1.7.0_17
			SET CATALINA_HOME=D:\apache-tomcat-7.0.55-src
			SET CATALINA_BASE=D:\apache-tomcat-jenkins
			2、准备多套base_home的目录，公用一个catalina_home
			set "CATALINA_BASE=%cd%"  
			set "CATALINA_HOME=F:\apache-tomcat-7.0.69"  
			set "EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat"  
			call "%EXECUTABLE%" start 
			tomcat 的 catalina_home（安装目录） 和catalina_base（工作目录）
	6.tomcat的内存优化
		tomcat内存修改      -Xms256M   -Xmx512M   -XX:PermSize=128M   -XX:MaxPermSize=1024M
		eclipse内存优化		eclipse.ini    -Xmx1524m  -XX:MaxPermSize=256M
	
			
	8.创建一个public static final 类型的map 并初始化赋初值，，也可以通过Collections.unmodifiableMap(params)，实现不可更改。  
				public static final Map<String,String> map=new HashMap<String, String>();
				static{
					map.put("1", "a");
					map.put("2", "b");
					map.put("3", "c");
				}
				在别的类中进行修改，重新创建实例可以全局共享修改的数据map。同样静态字符串常量也是一样的。	
				
	9.mybatis generator 源码会默认设置追加属性为ture
	10.netstat -aon|findstr "49157" 查看端口的占用情况，然后任务管理器pid对应的进程
	11.modelMap.put(key,value)添加重复的key，会覆盖原来的值.
	12.HTTP Status 400 - Required String parameter 'pwd' is not present  @requestParam绑定缺失
	13.// 手机号码校验，使用正则表达式判断
		Pattern p = Pattern.compile("^17[\\d]{9}|13[0-9]{9}|15[012356789][0-9]{8}|18[\\d][\\d]{8}|147[0-9]{8}$");
		Matcher m = p.matcher(cellPhoneNum)
	14.eclipse中的tomcat找不到war工程 
		The given project is not a virtual component project   让我改property >  Myeclipse> project  facets（可选择相应的web和java版本） 
	15.使用@responseBody标签直接返回json数据，需要引入两个jar包 jackson-core.jar，jackson-databind.jar
	16.poi 实现excel的导出功能。
	17.一般jsp文件不放在web-inf下  	web.xml放在web-inf下
	18.	eclispe部署到root下放入的方案
		1）、部署的路径是webapps下，工程的名字改为root，这种测试中比较快
		2）、解压war工程到root下，运行tomcat即可，这个一般linux自动部署方法
		3）、改变工程访问路径   
		server.xml 中 <Context path="/" docBase="XiaoyuerProject" debug="0"  reloadable="false"></Context> 
		这个和web project setting中设置context root是一致的，倾向后者，在双击tomcat中的modules中也可以设置
	19.	bean的注入失败情况
		1.对应要注入的实现类没有 加注解，如dao层 @Repository  如service层  @Service
		2."You generally autowire to your interface type and not impl."调用的接口是否有具体的实现类。
		3.@Autowired下面，没有类，直接跟了@RequestMapping。【我的是直接跟了method，显示无法注入method，导致不识别的No qualifying bean of type [java.lang.String] found for dependency错误，】
	20.正常类中@Override 时出错误，因为你的Compiler 是jdk1.5，只要把它改为 1.6
	21.	//创建数组
	1）、int[] arr=new int[6];
	2）、int[] x={1,2,3,4};
	3）、int[] y= new int[]{1,2,3,4,5};

	23.sosoapi sosoapi ip权限  和 用户管理员权限（t_proj_mem中修改成员的信息）
	24.连等判断 int a = 2==2 ? 1:0;
	25.		随机数
			Integer res = random.nextInt(n);
			Integer res2 = (int)(Math.random() * n);
	26.注释模板：
		shift+alt+J 自动注释  
		或者/** +enter      
		Window -->preferences--> Java --> Code Style --> Code Templates  中修改注释模板
	27.	<c:set var="fileUrl" value="http://192.168.6.199:8086"/>
	<form id="itemForm" action="${fileUrl}${pageContext.request.contextPath }/editItemsSubmit" method="post" enctype="multipart/form-data"> 
	跨域提交表单的时候，需要写全http://头，否则不识别跳转blank空页面
	表单提交需要刷新回显
	ajax可以实现异步回显
	28.web.xml 和jar正常  java.lang.ClassNotFoundException:org.springframework.web.context.ContextLoaderListener 
		原因是最终的web工程中jar最终是要在web-inf的lib下的，没有重新添加maven的buildPath
	29.	枚举类的使用
			枚举类一定需要private的构造函数
			public class Test {  
			public enum Color {  
				RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4);  
				// 成员变量  
				private String name;  
				private int index;  
				// 构造方法  
				private Color(String name, int index) {  
					this.name = name;  
					this.index = index;  
				}  
				@Override  
				public String toString() {  
					return this.index + "_" + this.name;  
				}  
			}  
			public static void main(String[] args) {  
				System.out.println(Color.RED.toString());  
			}  

		}
	30.取对象属性操作后，对象本身也在变化
		Person person = new Person();
		BaseDict2 baseDict2 = person.getBaseDict2();
		baseDict2.setDescription("123123");
		System.out.println(JSON.toJSON(person).toString());
	31.可以看出DTO传输对象的设计应该具备这几个特点：
		1.按需放入字段。
		2.保证贫血模型，不要放任何逻辑在里面。可以看出DTO传输对象的设计应该具备这几个特点：
		1.按需放入字段。
		2.保证贫血模型，不要放任何逻辑在里面。

	32.@Autowired，首先在容器中查询对应类型的bean
　　　　如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据
　　　　如果查询的结果不止一个，那么@Autowired会根据名称来查找。
　　　　如果查询的结果为空，那么会抛出异常。解决方法时，使用required=false
		弄到方法上就是在实例化这个类的时候，注入方法形参类型的
		@resource（name=“personDaoBean”）默认byName
	33.NAT的典型应用：
	在一个局域网内，只需要一台计算机连接上Internet，就可共享Internet连接，使局域网内其他计算机也可以上网。使用NAT协议，
	局域网内的计算机可以访问Internet上的计算机，但Internet上的计算机无法访问局域网内的计算机。
	34.泛型
		List<T> getList<T param1,T param2>	可以限制返回结果的类型以及两个参数的类型一致。
		List<?>一般就是在泛型起一个限制作用。	public void test(? extends Fruit){};
	35.	svn删除恢复
	找到删除该文件或者文件夹的版本，在Logmessage里右键Revertthechangesfromthisrevision。
	36.	maven本地工程依赖失效，install总的pom工程即可
	37.	日志：logger.error("用户{},获取月份信息失败", "nini"); 日志快捷传参
	38.	拦截器再往上抛出异常，可由统一自定义异常处理
		springmvc的统一异常处理需要实现HandlerExceptionResolver接口
		spring的handle在处理时发现异常后，HandlerExceptionResolver的列表会被赋值，然后进行处理
		这个统一异常处理类需要加入spring容器

		ControllerExceptionResolver implements HandlerExceptionResolver
		{
		public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,
			Exception ex)
		{
			ModelAndView mv= new ModelAndView();
			return mv;
		}
		}
		拦截其中重定向后return true，则重定向无效
	39.WEB-INF下的文件无法直接访问，可以直接把JSP页面放到WEB-INF外的webapp目录下，可以通过转发的方式访问，我用的是Controller来进行转发，
	<%=request.getContextPath()%>	jsp页面中直接获取项目的工程名	
	路径前加“/”是代表绝对路径，不加“/”是代表相对路径。
	相对目录中 同级怒路直接取	<img src="img/solr.png">
	40.	HttpClient  
        HttpEntity  消息载体，post或者response中消息的载体
		httpclient.execute(httppost)
		处理返回消息体：EntityUtils.toString(response.getEntity(), "UTF-8");
		post请求：传参
		List<namevaluepair> formparams = new ArrayList<namevaluepair>();
	41.代码改动没反应，删除classes下的文件，在项目buildpath，把源码src添加进来就可以了
	42.list添加数据时 引用类型要new一个新地址出来
	43.json数组 "addServices": ["2" ,"1"]
	
	44.属性文件的读取
			1.String filename = "com/luhy/test/ReadProperties.properties";  
        	Properties props = new Properties();  
       		props.load(ReadProperties.class.getClassLoader().getResourceAsStream(filename)); loda属性流文件 
       		String h = props.getProperty("v"); 
			2.流读取文件
			Thread.currentThread().getContextClassLoader().getResourceAsStream("abc.properties") 	默认是classpath下
			
			3.ResourceBundle resourceBundle = ResourceBundle.getBundle("filters.redis"); 
			加载classpath下的属性文件获取，resourceBundle.getString("redis.port")直接获取属性文件中的值
	45.configfilter数据库加密   	java -cp druid-1.0.16.jar com.alibaba.druid.filter.config.ConfigTools you_password   1.0.16版本加密默认带有公钥，私钥。1.0.13版本默认不带公钥。
		通过设置<property name="filters" value="config" />
			<property name="connectionProperties" value="config.decrypt=true;config.decrypt.key=$[xye_jdbc_publicKey]" />来解密。
		加密的带公钥的需要传入公钥，未公钥加密的不需要传入公钥。
	46.忘记本地数据库 mysqld --skip-grant-tables
	47.日志相关
		logback中的		private static Logger logger = LoggerFactory.getLogger("test"); 
					<logger name="test" >
					<level value="error" />
					<appender-ref ref="FILE" />
					<appender-ref ref="STDOUT" />
					</logger> 
			会默寻找 name相符合的log名称，找不到会默认继承根log，打日志

		lo4j中的日志设置		log4j.logger.packag1= info, packag1    默认packag1包下类和"packag1"的字符串
		protected static final Logger logger = Logger.getLogger(""); 
		参数只可能是1-字符串，2-*.class类，1就字符串匹配packag1名；2就作为类需要在packag1包下
	48.	library 和lib区别
		library是用来编译里面的src中java文件的
		部署到tomcat时,仅仅只复制了WEB-INF/lib里面的jar包,
		出现eclipse可以正常编译但tomcat运行是找不到类
		
	48.	form参数绑定 留着参考
	<form:form id="queryInfoForm" modelAttribute="platformOrder">
	<span>类型：</span>
	<form:select path="addSerCode" id="addSerCode">
		<option value="" selected>全部</option>
			<c:forEach var="addType" items="${addSers}" varStatus="addVsType">
				<c:choose>
			             <c:when test="${addType.key==platformOrder.addSerCode}">
					  <option value="${addType.key}" selected="selected">
						 ${addType.value}
					   </option>
						 /c:when>					
					 <c:otherwise>
					 <option value="${addType.key}">
						 ${addType.value }
					 </option>
				      </c:otherwise>
				</c:choose>
			</c:forEach>				
		</form:select>
		 <input type="submit"  class="bth" value="查询" />
		div id="partlist"></div>
 	 </form:form>
	 49.Tomcat中指定URL用UTF-8编码server.xml：
	<Connector port="8080" protocol="HTTP/1.1"   connectionTimeout="20000"   redirectPort="8443" useBodyEncodingForURI="true" URIEncoding="UTF-8" />  
	50.	//构造XML传输对象
			Document document = DocumentHelper.createDocument();
			Element root = document.addElement("root");
			root.addElement("user").addText(ids[1]);
			root.addElement("sessionIdentifier").addText(ids[0]);
			response.setContentType("text/html;charset=UTF-8");
			response.getWriter().write(document.asXML());
			response.getWriter().flush();
	51.xml解析
		xml的解析:dom和sax
			xpath解析：先流读取xml文件获得doc，创建xpath对象，第一参数是xml中的路径，//表示只匹配名称，读取节点xpath.evaluate("/person", doc, XPathConstants.NODESET)  使用xpath.evaluate("background", node，XPathConstants.STRING)读取节点值.
			
	52.ecipse下错误: 找不到或无法加载主类，重新添加buildPath中的add源码即可，maven打包异常不覆盖，也适用
	53.	直接读取xml文件，加入容器
		一、简单的用ApplicationContext做测试的话,获得Spring中定义的Bean实例(对象).可以用:
		ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
		RegisterDAO registerDAO = (RegisterDAO)ac.getBean("RegisterDAO");

		如果是两个以上:
		ApplicationContext ac = new ClassPathXmlApplicationContext(new String[]{"applicationContext.xml","dao.xml"});

		或者用通配符:
		ApplicationContext ac = new ClassPathXmlApplicationContext("classpath:/*.xml");
		
		在junit测试中，也可以使用new ClassPathXmlApplicationContext("classPath:spring.xml")获得applicationContext，spring的容器对象
		
	
	54.手动获取spring的ApplicationContext和bean对象    写一个工具类实现ApplicationContextAware接口,并将这个加入到spring的容器，
	55.	io操作
		FileOutputStream fs = new FileOutputStream(outPath);//实例了文件输出流，参数是文件输出路径
		OutputStreamWriter ow = new OutputStreamWriter(fs,"UTF-8");//在写输出流的时候做编码格式转化，以免乱码！
		BufferedWriter bWriter = new BufferedWriter(ow);//将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入	
		（1）以utf-8的格式构造一个文件输出流FileOutputStream，（2）然后将这个文件输出字符流封装成字节输出流OutputStreamWriter，（3）然后将这个字节输出流封装成缓冲字节输出流。	
	56.匿名内部类
		通类实现接口需要实现接口中的所有方法，
	    抽象类实现借口，可以完全覆盖/重写 接口中的方法，也可只重写接口中的某几个方法，子类再继承抽象类时，子类重写的方法即为抽象类中未重写接口中的方法。
	    总的而言，抽象类实现接口可以自选实现的方法
	    普通类继承抽象类需要实现抽象类中的抽象方法
	    ***由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现***
	57.	sprinboot工程maveninstall失败，unable to find a main class，pom中指定启动类即可
				 <properties>
						<start-class>com.boot.Application</start-class>
						<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
						<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
						<java.version>1.7</java.version>
				 </properties>
	58.	 转字节流
			ByteArrayOutputStream bo = new ByteArrayOutputStream();  
	        ObjectOutputStream oo = new ObjectOutputStream(bo);  
	        oo.writeObject("nihao "); 
	        byte[] bytes = bo.toByteArray(); 
		
	59.自增方式	1、uuid 2、redis.incr 3、date+random 4、mysql自增
	60.classes删除，启动无法加载类，右键build path 重新添加代码路径即可
	61.域名的分配 
		一级域名	taotao.com
		二级域名	www.taotao.com
	62.网站并发数量在1000-2000级别的，用户数量一般在百万级别
	63.解决post乱码：在web.xml中配置字符集过滤
		解决个体乱码：	1、tomcat中     <Connector URLEncoding="utf-8" port="8080" 		protocol="HTTP/1.1"  connectionTimeout="20000" redirectPort="8443" />
						2、new String(request.getParammeter("a").getBytes("ISO8859-1"),"utf-8")
	64.json数据交互:springmvc中使用这两个标签需要引入jackson jar
		请求时json串：前端需要处理转为json串，不太方便 
		@requestbody 可以将json串转为java对象，形参绑定
		@responsebody可以将java对象转为json串输出

		public @ResponseBody UserInfo getUserInfo(@RequestBody Item item){

			return userInfo;
		}
	65.throw是语句抛出一个异常。
		throws是方法可能抛出异常的声明。
	66.WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。

	
		
	

	





				
				
		

	
	
	
	


	


	