-mvc
	我想在拦截的方法里面得到从前台传入的参数,怎么得到？
	答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样
	14、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？
	答：直接在方法中声明这个对象,SpringMvc 就自动会把属性赋值到这个对象里面。


	通过 ModelMap 对象,可以在这个对象里面用 put 方法,把对象加到里面,前台就可以通
	过 el 表达式拿到。

	个类把视图和数据都合并的一起的,叫什么？
答：叫 ModelAndView。

-jishushouce
分布式
加机器做集群可以解决大部分访问压力


目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数
据库服务器的数据更新同步到另一台服务器上。网站利用数据库的这一功能，实现数据库读写分离，从而改善数据
库负载压力

分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更
常用的数据库拆分手段是业务分库，将不同业务的数据部署在不同的物理服务器上。

cap
分区容忍性是我们必须需要实现的。
所以我们只能在一致性和可用性之间进行权衡，没有任何分布式系统能同时保证这三点。
C:强一致性 A：高可用性 P：分布式容忍性 CA 传统Oracle数据库
AP 大多数网站架构的选择
CP Redis、Mongodb
注意：分布式架构的时候必须做出取舍。 一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要
强一致性。
因此牺牲C换取P，这是目前分布式数据库产品的方向
对网站架构而言，只要能通过增加一台服务器的方式改善负载压力，就可以以同样的方式持续增加服务器不断改善系统性能，从而实现系统的可伸缩性，通过负载均衡调度即可

redis
Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储
Redis支持数据的备份，即master-slave模式的数据备份

redis快的原因
纯内存操作
单线程操作，避免了频繁的上下文切换
采用了非阻塞I/O多路复用机制


简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有
一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器
中。 需要说明的是，这个I/O多路复用机制


redis的过期策略以及内存淘汰机制
定期删除+惰性删除，
如果定期删除没删除key。然后你也没即时去请求key，
也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最
近最少使用的key。推荐使用，目前项目在用这种


秒杀的思路
限流
由于活动库存量一般都是很少，对应的只有少部分用户才能秒杀成功。所以我们需要限制大部分用户流量，只准少
量用户流量进入后端服务器。
削峰
秒杀开始的那一瞬间，会有大量用户冲击进来，所以在开始时候会有一个瞬间流量峰值。如何把瞬间的流量峰值变
得更平缓，是能否成功设计好秒杀系统的关键因素。实现流量削峰填谷，一般的采用缓存和 MQ 中间件来解决。
异步
秒杀其实可以当做高并发系统来处理，在这个时候，可以考虑从业务上做兼容，将同步的业务，设计成异步处理的
任务，提高网站的整体可用性。
缓存
秒杀系统的瓶颈主要体现在下订单、扣减库存流程中。在这些流程中主要用到 OLTP 的数据库，类似 MySQL、
SQLServer、Oracle。由于数据库底层采用 B+ 树的储存结构，对应我们随机写入与读取的效率，相对较低。如果
我们把部分业务逻辑迁移到内存的缓存或者 Redis 中，会极大的提高并发效率。





秒杀页面
秒杀活动开始前，其实就有很多用户访问该页面了。如果这个页面的一些资源，比如 CSS、JS、图片、商品详情
等，都访问后端服务器，甚至 DB 的话，服务肯定会出现不可用的情况。所以一般我们会把这个页面整体进行静态
化，并将页面静态化之后的页面分发到 CDN 边缘节点上，起到压力分散的作用。
防止提前下单
防止提前下单主要是在静态化页面中加入一个 JS 文件引用，该 JS 文件包含活动是否开始的标记以及开始时的动态
下单页面的 URL 参数。同时，这个 JS 文件是不会被 CDN 系统缓存的，会一直请求后端服务的，所以这个 JS 文件
一定要很小。当活动快开始的时候（比如提前），通过后台接口修改这个 JS 文件使之生效。
API 接入层优化
客户端优化，对于不是搞计算机方面的用户还是可以防止住的。但是稍有一定网络基础的用户就起不到作用了，因
此服务端也需要加些对应控制，不能信任客户端的任何操作。一般控制分为 2 大类：
限制用户维度访问频率
针对同一个用户（ Userid 维度），做页面级别缓存，单元时间内的请求，统一走缓存，返回同一个页面。
限制商品维度访问频率
大量请求同时间段查询同一个商品时，可以做页面级别缓存，不管下回是谁来访问，只要是这个页面就直接返回。
SOA 服务层优化
上面两层只能限制异常用户访问，如果秒杀活动运营的比较好，很多用户都参加了，就会造成系统压力过大甚至宕
机，因此需要后端流量控制。
对于后端系统的控制可以通过消息队列、异步处理、提高并发等方式解决。对于超过系统水位线的请求，直接采取
「Fail-Fast」原则，拒绝掉。

秒杀系统核心在于层层过滤，逐渐递减瞬时访问压力，减少最终对数据库的冲击。通过上面流程图就会发现压力最
大的地方在哪里？
MQ 排队服务，只要 MQ 排队服务顶住，后面下订单与扣减库存的压力都是自己能控制的，根据数据库的压力，可
以定制化创建订单消费者的数量，避免出现消费者数据量过多，导致数据库压力过大或者直接宕机。
库存服务专门为秒杀的商品提供库存管理，实现提前锁定库存，避免超卖的现象。同时，通过超时处理任务发现已
抢到商品，但未付款的订单，并在规定付款时间后，处理这些订单，将恢复订单商品对应的库存量。

请求->账号安全检查――>商品库存检查->给mq->异步消费订单处理，附带超时补偿操作


核心思想：层层过滤
尽量将请求拦截在上游，降低下游的压力
充分利用缓存与消息队列，提高请求处理速度以及削峰填谷的作用

水平拆
不存在单库大数据，高并发的性能瓶颈。
2. 对应用透明，应用端改造较少。
3. 按照合理拆分规则拆分，join操作基本避免跨库。
4. 提高了系统的稳定性跟负载能力。
缺点：
1. 拆分规则难以抽象。
2. 分片事务一致性难以解决。
3. 数据多次扩展难度跟维护量极大。
4. 跨库join性能较差


怎么解决拆分问题
数据冗余，分组避免数据垮库多表join

XA三阶段提交在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。一旦事物参与者迟迟没有接
到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一
致的问题仍然没有根本解决。


请求域名www.baidu.com,dns服务器解析到114.100.20.203，浏览器亲戚对应114.100.20.203ip，然后到远程的nginx，转发到对应的服务器ip集群上去
DNS负载均衡采用的是简单的轮询算法，不能区分服务器之间的差异，
不能反映服务器当前运行状态，所以其的负载均衡效果并不是太好。

对null 的处理时候，只能采用is null或is not null，而不能采用=、in、<、<>、!=、not in这些操作符号。如：
where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录

必须使用varchar(20)存储手机号解读

禁止使用属性隐式转换解读：SELECT uid FROM t_user WHERE phone=13800000000 会导致全表扫描，
而不能命中phone索引，猜猜为什么？（这个线上问题不止出现过一次）


%开头的模糊查询，会导致全表扫描

禁止使用OR条件，必须改为IN查询解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为
何要让数据库耗费更多的CPU帮助实施查询优化呢？

禁止使用JOIN查询，禁止大表使用子查询解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能

聚集索引的叶节点就是数据节点，而非聚集索引的叶节点仍然是索引节点。

而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶
节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。


聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索
需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。
不在索引列做运算或者使用函数

ike 模糊查询中，右模糊查询（321%）会使用索引，而%321 和%321%会放弃索引而使用全局扫描

Where 子句中经常使用的字段应该创建索引，分组字段或者排序字段应该创建索引，两个表的连接字段应该创建索引


脏读（未提交读）


排他锁 写锁 被加锁的对象只能被持有锁的事务读取和修改，其他事务无法在该对象上加其他锁，也不能读取和修改该对象

共享锁 **读锁** 被加锁的对象可以被持锁事务读取，但是不能被修改，其他事务也可以在上面再加共享锁。

特别的，对共享锁： 如果两个事务对同一个资源上了共享锁，事务A 想更新该数据，那么它必须等待 事务B 释放其共享锁。


默认的隔离级别
三级封锁协议是：二级封锁协议加上事务 在读取数据的瞬间 必须先对其加 共享锁 ，但是 直到事务结束才释放 ，
这样保证了可重复读（既是其他的事务职能读取该数据，但是不能更新该数据）

加 SELECT FOR UPDATE 语句，表明，凡是读到的数据，我会加 排他锁，防止其他数据同一时间获取相同数据) 



mysql的innodb采用的是行锁，而且采用了多版本并发控制来提高读操作的性能
MVCC只在REPEATABLE READ和READ COMMITED两个隔离级别下工作，其它两个隔离级别下不存在MVCC
通过版本号来减少锁的争用。



半数机制：集群中半数以上机器存活，集群可用。所以zookeeper适合装在奇数台机器上。
Zookeeper虽然在配置文件中并没有指定master和slave。但是，zookeeper工作时，是有一个节点为leader，
其他则为follower，Leader是通过内部的选举机制临时产生的


几种树形结构
覆盖索引 和 回表查询，mysql的索引树

二叉树，b树，b+树，红黑树

数是一种数据结构，用来检索数据

B-树就是B树，不要读B减树


最简单的结构，二叉树
为了减少磁盘IO次数，我们就需要把原本“瘦高”的树结构变得“矮胖”些。这就是B-树的特征之一


一个m阶的B+树具有如下几个特征：
1. 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3. 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素

需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针
B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点

hashmap中根据键值key计算hash值得到插入的数组索引i

map的不安全在于，头插法导致的环形链表

判断对象存活
引用计数法，
可达性分析，gc root
通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过
的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从
GC Roots到这个对象不可达）时，则证明此对象是不可用的


一般将新生代划分为一块较大的Eden空间和两个较小的
Survivor空间(From Space, To Space)，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块
空间中还存活的对象复制到另一块Survivor空间中。


redis分布式锁优化
zookeeper 锁相关基础知识 zk 一般由多个节点构成（单数），采用 zab 一致性协议。因此可以将 zk 看成一个单
点结构，对其修改数据其内部自动将所有节点数据进行修改而后才提供查询服务。 zk 的数据以目录树的形式，每
个目录称为 znode， znode 中可存储数据（一般不超过 1M），还可以在其中增加子节点。 子节点有三种类型。
序列化节点，每在该节点下增加一个节点自动给该节点的名称上自增。临时节点，一旦创建这个 znode 的客户端
与服务器失去联系，这个 znode 也将自动删除。最后就是普通节点。 Watch 机制，client 可以监控每个节点的变
化，当产生变化会给 client 产生一个事件。
zk 基本锁 原理：利用临时节点与 watch 机制。每个锁占用一个普通节点 /lock，当需要获取锁时在 /lock 目录下创
建一个临时节点，创建成功则表示获取锁成功，失败则 watch/lock 节点，有删除操作后再去争锁。临时节点好处
在于当进程挂掉后能自动上锁的节点自动删除即取消锁。 缺点：所有取锁失败的进程都监听父节点，很容易发生羊
群效应，即当释放锁后所有等待进程一起来创建节点，并发量很大。
zk 锁优化 原理：上锁改为创建临时有序节点，每个上锁的节点均能创建节点成功，只是其序号不同。只有序号最
小的可以拥有锁，如果这个节点序号不是最小的则 watch 序号比本身小的前一个节点 (公平锁)。 步骤：
在 /lock 节点下创建一个有序临时节点 (EPHEMERAL_SEQUENTIAL)。
判断创建的节点序号是否最小，如果是最小则获取锁成功。不是则取锁失败，然后 watch 序号比本身小的前
一个节点。（避免很多线程watch同一个node，导致羊群效应）
当取锁失败，设置 watch 后则等待 watch 事件到来后，再次判断是否序号最小。
取锁成功则执行代码，最后释放锁（删除该节点）。
优缺点 优点： 有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。 缺
点： 性能上可能并没有缓存服务那么高，因为每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实
现锁功能。ZK 中创建和删除节点只能通过 Leader 服务器来执行，然后将数据同步到所有的 Follower 机器上。还
需要对 ZK的原理有所了解。






108