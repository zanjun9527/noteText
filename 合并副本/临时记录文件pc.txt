HashMap的原理
 底层使用哈希表（数组 + 链表），当链表过长会将链表转成 红黑树以实现 O(logn) 时间复杂度内查找
 
 扩容
 当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列
 元素的下标要么不变，要么变为【原下标+原容量】
 
  `TreeSet` 底层是 `TreeMap`，`TreeMap` 是基于红黑树来实现的。
  
  
  红黑树
  
  
  Comparable 接口和 Comparator 接口实现比较
    - Comparable 是直接在"被比较"的类内部来实现的
    - Comparator则是在被比较的类外部实现的
	
Java 中所有异常都是 `Throwable` 的子类，他的直接子类有两个，一个是 `Error`, 一个是 `Exception（运行+编译）

Java 的 NIO 组合使用了 IO 复用 + 非阻塞 IO 两种 IO 模型

按照 IO 的对象，可以分为 4 类。分别是：
        1. 基于字节操作的 I/O 接口：InputStream 和 OutputStream
        1. 基于字符操作的 I/O 接口：Writer 和 Reader
        1. 基于磁盘操作的 I/O 接口：File
        1. 基于网络操作的 I/O 接口：Socket
		

 单例模式的生命周期
    - 一般来说单例模式创建的对象是由类的 static 变量引用着的，JVM 如果采用可达性分析算法来回收的话，该对象是永远不可能被回收的（从创建以后）。
	
	
分代收集。这种方法没有使用新算法，只是根据对象的特点将堆分为年轻代和老年代，年轻代使用复制算法，老年代使用标记整理算法。
minor GC 和 Full GC 的触发时机
    - minor GC: 当 eden 区满以后会触发。
    - Full GC：
        1. JVM 的一些特性比如分配担保，大对象直接进入老年代，长期存活的对象进入老年代等等都会不断增加老年代的使用率，当老年代空间不足以支持下一次 Minor GC 时会触发一次 Full GC
        1. 当用户代码调用 System.gc 时，系统系统建议执行 Full GC，但是否进行是由 JVM 来决定的。

GC roots 不可达的对象是可以回收的

JDK1.8 中 JVM 做了那些改变
    - 主要是撤销了永久代，引入元空间（本地内存）

	
	介绍一下 Java 的强软弱虚四种引用，问什么时候使用软引用(待定)


双亲委派模型

cglib 动态代理。通过框架转换字节码生成目标类的子类，并覆盖其中的方法实现增强，

 Controller 是单例的，跟 Servlet 一样。

 
 索引为什么用 B 树不用二叉树，有什么好处？
    - 基于 B 树的索引实现，降低了树的高度，减少了磁盘 IO 的次数。
	
一般线程和守护线程的区别


浏览器查询域名的 IP。一般会有以下几个地方：
        1. 浏览器缓存
        1. 操作系统缓存
        1. 路由器缓存
        1. 本地 DNS 服务器
        1. 如果本地 DNS 服务器上没有的话，它会递归的从根 DNS 服务器、顶级 DNS 服务器、权威 DNS 服务器请求，然后把获取到的 IP 返回给浏览器（DNS 协议基于 UDP）。
		
		
如何设计一个高并发的系统
    - 数据库的优化，包括合理的事务隔离级别、SQL语句优化、索引的优化
    - 使用缓存，尽量减少数据库 IO
    - 分布式数据库、分布式缓存
    - 服务器的负载均衡
	
	
	
从 innodb 的索引结构分析，为什么索引的 key 长度不能太长？


参考答案
key 太长会导致一个页当中能够存放的 key 的数目变少，间接导致
索引树的页数目变多，索引层次增加，从而影响整体查询变更的效
率
	
MySQL 的数据如何恢复到任意时间点？
参考答案
恢复到任意时间点以定时的做全量备份，以及备份增量的 binlog 日
志为前提。恢复到任意时间点首先将全量备份恢复之后，再此基础
上回放增加的 binlog 直至指定的时间点。


假如给你一个新产品，你将从哪些方面来保障它的质量？
参考答案
可以从代码开发、测试保障、线上质量三个方面来保障。
在代码开发阶段，有单元测试、代码Review、静态代码扫描等；测
试保障阶段，有功能测试、性能测试、高可用测试、稳定性测试、
兼容性测试等；在线上质量方面，有灰度发布、紧急回滚、故障演
练、线上监控和巡检等
	

	
	concurrenthashmap 的size实现
	http://www.cnblogs.com/ITtangtang/p/3966467.html
	MQ如何保证顺序性
	一个Controller是单例还是多实例
	Redis的内存废弃策略。redis高并发的key怎么处理。默认持久化
	
	Spring MVC的aop实现原理，  是那种方式
dubbo原理
zookeeper原理
netty原理

线上处理经验

Java基础知识和分布式经验应该很熟悉，框架层面源码如果能研读可以加分。但是如果只是会用而不了解原理就要减分。

重点
过往的工作经验是owner一个独立的业务系统，负责系统的设计开发工作。
明确知道系统架构的情况，理解上下游关系。
理解该系统的业务定位，该系统当前存在的问题和后续的规划发展有自己的见解。S
Java基础知识和分布式经验应该很熟悉，框架层面理解原理，适当看源码
重点考察分布式/服务化系统（不是大流量高并发）的设计原理，思路，关注点。
要会理解一些分布式session、全局流水ID号、服务多次重试幂等、同步转异步、服务监控、最终一致性等原理和应用。
2主导一个复杂的系统（多个业务系统完整链路）；或者负责一块五脏俱全的业务。
3 对业务系统的理解会更多从商业价值角度去描述，熟悉这块产品链的模式和玩法，或者工业化成熟度较高的专业实现方案。
4分布式系统设计原则：分库分表分布式事务、性能稳定性的实践。
如果能描述分库分表中间件实现原理（SQLParse、语法树）、单元化/多机房灾备



jre jdk


static方法不能覆盖

值传递，传递了对象副本，就算改变对象副本，也不会改变源对象的值
引用传递，传递的不是实际的对象，而是对象的引用，外部对引用所做的改变，会反应到所有的对象上

线程的就绪状态：线程准备运行，但不一定立马就能开始执行

阻塞：等待，sleep，io阻塞，同步阻塞


死锁避免，指定获取锁顺序，强制线程按照指定的顺序获取锁，线程都按照同样的顺序加锁解锁，就不会死锁了

iterator迭代器可以在迭代的过程中删除底层集合的元素


对象不可达，就可以回收

快速失败和安全失败的区别


jvm中的永久代会垃圾回收吗
垃圾回收不发生在永久代，满了出发full gc
java8中已移除永久代，新加一个元数据区的native内存区


get是追加kv在url中，长度限制，可见
post的kv放在请求体中，长度无限制，不可见

request获取客户端ip和主机名，getRemoteAddr(),getRemoteHost()

session可以存储java对象，cookie只能存储string类型

redirect是会重新创建一个请求，forward是转发同一个请求，request中的data不一样了




tomcat优化
1.配置jvm
主要是jvm配置，一般建议堆的最大值设为可用内存的最大值80%
JAVA_OPTS='-Xms256m -Xmx512m' 初始化内存256MB  最大内存512MB

1.catalina.sh中配置内存
2.java -jar 执行时候追加参数





内存泄漏，就是一个不再被程序使用的对象或变量一直被内存占用(不再使用的对象一直被引用，无法且无法被回收)
比如缓存系统加载了一个对象放在缓存中（例如放在一个全局map中），然后一直不再使用，这个对象一直被缓存引用，但却不再被使用

外部类实例对象的方法返回一个内部类的实例对象，内部类长期引用，外部类虽然不用了但被内部类持有，回收不了


对象存进hashset中，不能修改对象中参与hash值计算的字段，否则hash值与最初存的不一样，即使contains方法使用对象的当前引用作为参数去hashse中检索对象，也找不到对象，内存泄露


gc不会再主程序运行期间对permgen space进行清理，主要是jsp，class文件，jar包过大会导致
需要设置MaxPermSize大小


堆内存不要超过可用物理内存的80%,一般将-xms -xmx设置相同，而xmn为1/4的xmx

-Xmx1024M-Xms512-XX:MaxPermSize=256m


2.禁用dns查询

3.调整线程数


死亡的对象不可访问，直到回收之前，会一直占据堆内存空间
类加载器本身也是一个类，本质是将类从硬盘读到内存中

引用计数问题是循环引用，二者都不为0，也就回收不了





对象优先分在eden区，大对象和长期存活的对象直接进入老年代

双亲委派，递归先给父类，父类不能加载，再反馈给子类去加载


dubbo的token可以防止用户绕过注册中心直连
dubbo还提供服务黑白名单，来控制服务所允许的调用方

快速失败，失败安全，失败快速恢复

hessian的底层采用的是http协议传输

当一个对象被锁住时，对象里所有用Synchronized修饰的方法都将堵塞，对象中非Synchronized修饰的方法可正常被调用，不受锁影响

可重入锁是为了解决自己锁死自己的问题，Synchronized也是可重入的

自旋锁，判断后避免执行阻塞过程

乐观锁只能保证一个共享变量的原子操作



构造函数和设置注入的区别


aqs是一个用来构建锁和同步工具的框架，包括lock，同步类


线程池的思路就是，从workqueue中不断取出需要执行的任务，放在workers中处理

线程池默认初始化后不启动worker，等待有请求时再启动。
线程池完成所有任务后最终会收缩到corePoolSize大小

内存模型中，线程间的变量值传递，需要通过主内存


BeanFactory 和 ApplicationContext 区别

@Configuration用来标注bean定义的资源,被其申明的类可通过再同一个类的内部调用@bean来设置嵌入bean的依赖关系


HandlerAdapter经过适配调用具体的处理器controller


mvc中直接再方法的形参中声明一个对象，前端传过来，参数自动赋值到对象中，名称一致



#{}是预编译处理，
将sql中的#{}替换为？号，并调用PreparedStatement的set赋值

${}是字符串替换
直接替换值

sql列的别名，  t_name as name    列名不区分大小写

拼接通配符，模糊查询like也使用#{}


namespace+id 作为Map<String,MappedStatement>的key使用，namespace不能重复

zookeeper提供了文件系统和通知机制
树状的目录结构，znode
创建全局唯一路径，即使目录节点


通知机制
	client端会对某个znode建立一个watcher事件，当znode变化时，cleint会受到zk通知并根据变化做出改变
	
	分布式时集群状态，不再同一个服务器上，所以要分布式锁
	
	一种是创建一个唯一路劲，只有一个会成功
	如果路径存在，在下面创建临时顺序编号目录节点，编号最小的获取锁
	
	zk集群机制，超过半数节点，集群可正常提供服务
	zk节点挂的多了，只剩一半或不到的节点能工作，集群可能失效
	
	
	
	
	
	
反向代理可以隐藏源服务器的存在和特征，是wweb和服务器的一个中间层
	
	
redis可以通过主从支持数据备份
aof做增量的持久化，bgsave是全量持久化

缓存的穿透，击穿

主从数据库不一致问题解决
1.忽略这个不一致，
2.强制读取主库，读写都在主库，添加缓存提高性能
	
3.选择性读主库，添加一个缓存用来记录必须读主库的数据，将库表键作为缓存的key，设置失效时间为主从同步时间，
	缓存总没有该数据主键就直接
	
master最好不要做持久化
	
	
	redisson 和  jedis
	
	
	构造函数私有化不能继承？
	
	
	平台提升即可，在公司的主要工作内容，技术只谈技术，杂的和别人谈
	尊重和平等
