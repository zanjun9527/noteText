HashMap的原理
 底层使用哈希表（数组 + 链表），当链表过长会将链表转成 红黑树以实现 O(logn) 时间复杂度内查找
 
 扩容
 当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列
 元素的下标要么不变，要么变为【原下标+原容量】
 
  `TreeSet` 底层是 `TreeMap`，`TreeMap` 是基于红黑树来实现的。
  
  
  红黑树
  
  
  Comparable 接口和 Comparator 接口实现比较
    - Comparable 是直接在"被比较"的类内部来实现的
    - Comparator则是在被比较的类外部实现的
	
Java 中所有异常都是 `Throwable` 的子类，他的直接子类有两个，一个是 `Error`, 一个是 `Exception（运行+编译）

Java 的 NIO 组合使用了 IO 复用 + 非阻塞 IO 两种 IO 模型

按照 IO 的对象，可以分为 4 类。分别是：
        1. 基于字节操作的 I/O 接口：InputStream 和 OutputStream
        1. 基于字符操作的 I/O 接口：Writer 和 Reader
        1. 基于磁盘操作的 I/O 接口：File
        1. 基于网络操作的 I/O 接口：Socket
		

 单例模式的生命周期
    - 一般来说单例模式创建的对象是由类的 static 变量引用着的，JVM 如果采用可达性分析算法来回收的话，该对象是永远不可能被回收的（从创建以后）。
	
	
分代收集。这种方法没有使用新算法，只是根据对象的特点将堆分为年轻代和老年代，年轻代使用复制算法，老年代使用标记整理算法。
minor GC 和 Full GC 的触发时机
    - minor GC: 当 eden 区满以后会触发。
    - Full GC：
        1. JVM 的一些特性比如分配担保，大对象直接进入老年代，长期存活的对象进入老年代等等都会不断增加老年代的使用率，当老年代空间不足以支持下一次 Minor GC 时会触发一次 Full GC
        1. 当用户代码调用 System.gc 时，系统系统建议执行 Full GC，但是否进行是由 JVM 来决定的。

GC roots 不可达的对象是可以回收的

JDK1.8 中 JVM 做了那些改变
    - 主要是撤销了永久代，引入元空间（本地内存）

	
	介绍一下 Java 的强软弱虚四种引用，问什么时候使用软引用(待定)


双亲委派模型

cglib 动态代理。通过框架转换字节码生成目标类的子类，并覆盖其中的方法实现增强，

 Controller 是单例的，跟 Servlet 一样。

 
 索引为什么用 B 树不用二叉树，有什么好处？
    - 基于 B 树的索引实现，降低了树的高度，减少了磁盘 IO 的次数。
	
一般线程和守护线程的区别


浏览器查询域名的 IP。一般会有以下几个地方：
        1. 浏览器缓存
        1. 操作系统缓存
        1. 路由器缓存
        1. 本地 DNS 服务器
        1. 如果本地 DNS 服务器上没有的话，它会递归的从根 DNS 服务器、顶级 DNS 服务器、权威 DNS 服务器请求，然后把获取到的 IP 返回给浏览器（DNS 协议基于 UDP）。
		
		
如何设计一个高并发的系统
    - 数据库的优化，包括合理的事务隔离级别、SQL语句优化、索引的优化
    - 使用缓存，尽量减少数据库 IO
    - 分布式数据库、分布式缓存
    - 服务器的负载均衡
	
	
	
从 innodb 的索引结构分析，为什么索引的 key 长度不能太长？


参考答案
key 太长会导致一个页当中能够存放的 key 的数目变少，间接导致
索引树的页数目变多，索引层次增加，从而影响整体查询变更的效
率
	
MySQL 的数据如何恢复到任意时间点？
参考答案
恢复到任意时间点以定时的做全量备份，以及备份增量的 binlog 日
志为前提。恢复到任意时间点首先将全量备份恢复之后，再此基础
上回放增加的 binlog 直至指定的时间点。


假如给你一个新产品，你将从哪些方面来保障它的质量？
参考答案
可以从代码开发、测试保障、线上质量三个方面来保障。
在代码开发阶段，有单元测试、代码Review、静态代码扫描等；测
试保障阶段，有功能测试、性能测试、高可用测试、稳定性测试、
兼容性测试等；在线上质量方面，有灰度发布、紧急回滚、故障演
练、线上监控和巡检等
	

	
	concurrenthashmap 的size实现
	http://www.cnblogs.com/ITtangtang/p/3966467.html
	MQ如何保证顺序性
	一个Controller是单例还是多实例
	Redis的内存废弃策略。redis高并发的key怎么处理。默认持久化
	
	Spring MVC的aop实现原理，  是那种方式
dubbo原理
zookeeper原理
netty原理

线上处理经验

Java基础知识和分布式经验应该很熟悉，框架层面源码如果能研读可以加分。但是如果只是会用而不了解原理就要减分。

重点
过往的工作经验是owner一个独立的业务系统，负责系统的设计开发工作。
明确知道系统架构的情况，理解上下游关系。
理解该系统的业务定位，该系统当前存在的问题和后续的规划发展有自己的见解。S
Java基础知识和分布式经验应该很熟悉，框架层面理解原理，适当看源码
重点考察分布式/服务化系统（不是大流量高并发）的设计原理，思路，关注点。
要会理解一些分布式session、全局流水ID号、服务多次重试幂等、同步转异步、服务监控、最终一致性等原理和应用。
2主导一个复杂的系统（多个业务系统完整链路）；或者负责一块五脏俱全的业务。
3 对业务系统的理解会更多从商业价值角度去描述，熟悉这块产品链的模式和玩法，或者工业化成熟度较高的专业实现方案。
4分布式系统设计原则：分库分表分布式事务、性能稳定性的实践。
如果能描述分库分表中间件实现原理（SQLParse、语法树）、单元化/多机房灾备



jre jdk


static方法不能覆盖

值传递，传递了对象副本，就算改变对象副本，也不会改变源对象的值
引用传递，传递的不是实际的对象，而是对象的引用，外部对引用所做的改变，会反应到所有的对象上

线程的就绪状态：线程准备运行，但不一定立马就能开始执行

阻塞：等待，sleep，io阻塞，同步阻塞


死锁避免，指定获取锁顺序，强制线程按照指定的顺序获取锁，线程都按照同样的顺序加锁解锁，就不会死锁了

iterator迭代器可以在迭代的过程中删除底层集合的元素


对象不可达，就可以回收

快速失败和安全失败的区别


jvm中的永久代会垃圾回收吗
垃圾回收不发生在永久代，满了出发full gc
java8中已移除永久代，新加一个元数据区的native内存区


get是追加kv在url中，长度限制，可见
post的kv放在请求体中，长度无限制，不可见

request获取客户端ip和主机名，getRemoteAddr(),getRemoteHost()

session可以存储java对象，cookie只能存储string类型

redirect是会重新创建一个请求，forward是转发同一个请求，request中的data不一样了




tomcat优化
1.配置jvm
主要是jvm配置，一般建议堆的最大值设为可用内存的最大值80%
JAVA_OPTS='-Xms256m -Xmx512m' 初始化内存256MB  最大内存512MB

1.catalina.sh中配置内存
2.java -jar 执行时候追加参数





内存泄漏，就是一个不再被程序使用的对象或变量一直被内存占用(不再使用的对象一直被引用，无法且无法被回收)
比如缓存系统加载了一个对象放在缓存中（例如放在一个全局map中），然后一直不再使用，这个对象一直被缓存引用，但却不再被使用

外部类实例对象的方法返回一个内部类的实例对象，内部类长期引用，外部类虽然不用了但被内部类持有，回收不了


对象存进hashset中，不能修改对象中参与hash值计算的字段，否则hash值与最初存的不一样，即使contains方法使用对象的当前引用作为参数去hashse中检索对象，也找不到对象，内存泄露


gc不会再主程序运行期间对permgen space进行清理，主要是jsp，class文件，jar包过大会导致
需要设置MaxPermSize大小


堆内存不要超过可用物理内存的80%,一般将-xms -xmx设置相同，而xmn为1/4的xmx

-Xmx1024M-Xms512-XX:MaxPermSize=256m


2.禁用dns查询

3.调整线程数


死亡的对象不可访问，直到回收之前，会一直占据堆内存空间
类加载器本身也是一个类，本质是将类从硬盘读到内存中

引用计数问题是循环引用，二者都不为0，也就回收不了





对象优先分在eden区，大对象和长期存活的对象直接进入老年代

双亲委派，递归先给父类，父类不能加载，再反馈给子类去加载


dubbo的token可以防止用户绕过注册中心直连
dubbo还提供服务黑白名单，来控制服务所允许的调用方

快速失败，失败安全，失败快速恢复

hessian的底层采用的是http协议传输

当一个对象被锁住时，对象里所有用Synchronized修饰的方法都将堵塞，对象中非Synchronized修饰的方法可正常被调用，不受锁影响

可重入锁是为了解决自己锁死自己的问题，Synchronized也是可重入的

自旋锁，判断后避免执行阻塞过程

乐观锁只能保证一个共享变量的原子操作



构造函数和设置注入的区别


aqs是一个用来构建锁和同步工具的框架，包括lock，同步类


线程池的思路就是，从workqueue中不断取出需要执行的任务，放在workers中处理

线程池默认初始化后不启动worker，等待有请求时再启动。
线程池完成所有任务后最终会收缩到corePoolSize大小

内存模型中，线程间的变量值传递，需要通过主内存


BeanFactory 和 ApplicationContext 区别

@Configuration用来标注bean定义的资源,被其申明的类可通过再同一个类的内部调用@bean来设置嵌入bean的依赖关系


HandlerAdapter经过适配调用具体的处理器controller


mvc中直接再方法的形参中声明一个对象，前端传过来，参数自动赋值到对象中，名称一致



#{}是预编译处理，
将sql中的#{}替换为？号，并调用PreparedStatement的set赋值

${}是字符串替换
直接替换值

sql列的别名，  t_name as name    列名不区分大小写

拼接通配符，模糊查询like也使用#{}


namespace+id 作为Map<String,MappedStatement>的key使用，namespace不能重复

zookeeper提供了文件系统和通知机制
树状的目录结构，znode
创建全局唯一路径，即使目录节点


通知机制
	client端会对某个znode建立一个watcher事件，当znode变化时，cleint会受到zk通知并根据变化做出改变
	
	分布式时集群状态，不再同一个服务器上，所以要分布式锁
	
	一种是创建一个唯一路劲，只有一个会成功
	如果路径存在，在下面创建临时顺序编号目录节点，编号最小的获取锁
	
	zk集群机制，超过半数节点，集群可正常提供服务
	zk节点挂的多了，只剩一半或不到的节点能工作，集群可能失效
	
	
	
	
	
	
反向代理可以隐藏源服务器的存在和特征，是wweb和服务器的一个中间层
	
	
redis可以通过主从支持数据备份
aof做增量的持久化，bgsave是全量持久化

缓存的穿透，击穿

主从数据库不一致问题解决
1.忽略这个不一致，
2.强制读取主库，读写都在主库，添加缓存提高性能
	
3.选择性读主库，添加一个缓存用来记录必须读主库的数据，将库表键作为缓存的key，设置失效时间为主从同步时间，
	缓存总没有该数据主键就直接
	
master最好不要做持久化
	
	
	redisson 和  jedis
	
	
	构造函数私有化不能继承？
	
	
	平台提升即可，在公司的主要工作内容，技术只谈技术，杂的和别人谈
	尊重和平等

	
jvm相关

方法区：主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等数据

程序计数器：记录当前线程执行的行号

分代回收的算法流程

GC 的三种收集方法：标记清除、标记整理、复制算法，分代算法

在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。
老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。






类加载的几个过程：
加载、验证、准备、解析、初始化。然后是使用和卸载了
通过全限定名来加载生成 class 对象到内存中，
然后进行验证这个 class 文件，包括文件格式校验、元数据验证，字节码校验等。
准备是对这个对象分配内存。
解析是将符号引用转化为直接引用（指针引用），
初始化就是开始执行构造器的代码


当一个对象不可达 GC Root 时，这个对象并
不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记
如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行
一次筛选，筛选的条件是是否有必要执行 finalize()方法。这里不细看

finalize原理(忽略)
当对象没有覆盖 finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。
如果该对象有必要执行 finalize()方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承
诺一直等待它运行完，这是因为如果 finalize()执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。
GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收


java 内存模型
本地内存是JMM 的一个抽象概念，并不真实存在
线程之间的交互就是内存模型，两个本地内存通过主内存进行交互


一般情况下，触发老年代 GC
的时候不会触发 Minor GC,但是通过配置，可以在 Full GC 之前进行一次 Minor
GC 这样可以加快老年代的回收速度


数据库线程数、数据池连接数


aop
将那些影响了 多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。
所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的 逻辑或责任封装起来，比如日志记录，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。



Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。


Spring Bean 的生命周期

1.实例化一个Bean－－new对象
2.spring上下文为上bean配置，ioc
3.判断接口内容
	BeanNameAware
	BeanFactoryAware
	ApplicationContextAware
	BeanPostProcessor.postProcessBeforeInitialization
	如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。
	BeanPostProcessor.postProcessAfterInitialization
	DisposableBean
	如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。
	
	
  1、实例化一个Bean－－也就是我们常说的new；
  2、按照Spring上下文对实例化的Bean进行配置－－也就是IOC注入；
  3、如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值
  4、如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；
  5、如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；
  6、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；
  7、如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。
  8、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法、；
  注：以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。
  9、当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；
  10、最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。
	另外我们这里描述的是应用Spring上下文Bean的生命周期，如果应用Spring的工厂也就是BeanFactory的话去掉第5步就Ok了
	
	
	
HashMap 和 hashTable 区别？
区别：Hashtable是线程安全的，效率比较低
Hashtable既不支持Null key也不支持Null value。Hashtable的put()方法的注释中有说明
Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。
HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍
Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的
HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。
HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口




重写equals()方法就必须重写hashCode()，但重写hashcode方法不一定要重写equals方法


定位出现问题的堆栈信息排查具体问题
1、top命令：Linux命令。可以查看实时的CPU使用情况。也可以查看最近一段时间的CPU使用情况。
2、ps命令： Linux命令。强大的进程状态监控命令。可以查看进程以及进程中线程的当前CPU使用情况。属于当前状态的采样数据。
3、jstack： Java提供的命令。可以查看某个进程的当前线程栈运行情况。根据这个命令的输出可以定位某个进程的所有线程的当前运行状态、运行代码，以及是否死锁等等。
4、pstack：Linux命令。可以查看某个进程的当前线程栈运行情况


应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：   
select id from t where num is null   
可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：  
select id from t where num=0    


微服务的高可用怎么保证的？
负载均衡与反向代理，隔离，限流，降级，超时与重试，回滚，压力测试与应急预案


DNS负载均衡
DNS 负责提供域名解析服务，当访问某个站点时，实际上首先需要通过该站点域名的DNS服务器来获取域名指向的IP地址，在这一过程中，DNS服务器完成了域名到IP地址的映射，
同样，这样映射也可以是一对多的，这时候，DNS服务器便充当了负载均衡调度器，它就像http重定向转换策略一样，将用户的请求分散到多台服务器上，但是它的实现机制完全不同。



反射机制通过void setAccessible(boolean flag)方法可以得到一个类的private的方法和属性，使用这些private的方法和属性

TreeSet的底层实现是TreeMap
说白了，HashSet就是限制了功能的HashMap，所以了解HashMap的实现原理



ConcurrentHashMap
对于一个key，需要经过三次hash操作，才能最终定位这个元素的位置，这三次hash分别为：
对于一个key，先进行一次hash操作，得到hash值h1，也即h1 = hash1(key)；
将得到的h1的高几位进行第二次hash，得到hash值h2，也即h2 = hash2(h1高几位)，通过h2能够确定该元素的放在哪个Segment；
将得到的h1进行第三次hash，得到hash值h3，也即h3 = hash3(h1)，通过h3能够确定该元素放置在哪个HashEntry。
每一个Segment都拥有一个锁，当进行写操作时，只需要锁定一个Segment，而其它Segment中的数据是可以访问的。





synchronized
如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：
1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；
2）线程执行发生异常，此时JVM会让线程自动释放锁
那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。


锁的释放
1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁
在finally中必须释放锁，不然容易造成线程死锁
锁状态
无法判断
可以判断


一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。

DNS是指：域名服务器(Domain Name Server)。在Internet上域名与IP地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器

git rebase 和 merge 有什么区别？




1、java事件机制包括哪三个部分？分别介绍。
2、为什么要使用线程池？
3、线程池有什么作用？
4、说说几种常见的线程池及使用场景。
5、线程池都有哪几种工作队列？
6、怎么理解无界队列和有界队列？
7、线程池中的几种重要的参数及流程说明。
8、什么是反射机制？
9、说说反射机制的作用。
10、反射机制会不会有性能问题？
11、你怎么理解http协议？
12、说说http协议的工作流程。
13、http有哪些请求提交方式？
14、http中的200,302,403,404,500,503都代表什么状态？
15、http get和post有什么区别？
16、你怎么理解cookie和session，有哪些不同点？
17、什么是web缓存？有什么优点？
18、什么是https，说说https的工作原理？
19、什么是http代理服务器，有什么用？
20、什么是虚拟主机及实现原理？
21、什么是Java虚拟机，为什么要使用？
22、说说Java虚拟机的生命周期及体系结构。
23、说一说Java内存区域。
24、什么是分布式系统？
25、分布式系统你会考虑哪些方面？
26、讲一讲TCP协议的三次握手和四次挥手流程。
27、为什么TCP建立连接协议是三次握手，而关闭连接却是四次握手呢？为什么不能用两次握手进行连接？
28、为什么TCP TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？
29、什么是DoS、DDoS、DRDoS攻击？如何防御？
30、描述一下Java异常层次结构。
31、什么是检查异常，不受检查异常，运行时异常？并分别举例说明。
32、finally块一定会执行吗？
33、正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行？
34、try、catch、finally语句块的执行顺序。
35、Java虚拟机中，数据类型可以分为哪几类？
36、怎么理解栈、堆？堆中存什么？栈中存什么？
37、为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？
38、在Java中，什么是是栈的起始点，同是也是程序的起始点？
39、为什么不把基本类型放堆中呢？
40、Java中的参数传递时传值呢？还是传引用？
41、Java中有没有指针的概念？
42、Java中，栈的大小通过什么参数来设置？
43、一个空Object对象的占多大空间？
44、对象引用类型分为哪几类？
45、讲一讲垃圾回收算法。
46、如何解决内存碎片的问题？
47、如何解决同时存在的对象创建和对象回收问题？
48、讲一讲内存分代及生命周期。
49、什么情况下触发垃圾回收？
50、如何选择合适的垃圾收集算法？
51、JVM中最大堆大小有没有限制？
52、堆大小通过什么参数设置？
53、JVM有哪三种垃圾回收器？
54、吞吐量优先选择什么垃圾回收器？响应时间优先呢？
55、如何进行JVM调优？有哪些方法？
56、如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？
57、从分布式系统部署角度考虑，分哪几层？
58、如何解决业务层的数据访问问题？
59、为了解决数据库服务器的负担，如何做数据库的分布？
60、什么是著名的拜占庭将军问题？
61、为什么说TCP/IP协议是不可靠的？
62、讲讲CAP理念。
63、怎么理解强一致性、单调一致性和最终一致性？
64、分布式系统设计你会考虑哪些策略？
65、最常见的数据分布方式是什么？
66、谈一谈一致性哈希算法。
67、paxos是什么？
68、什么是Lease机制？
69、如何理解选主算法？
70、OSI有哪七层模型？TCP/IP是哪四层模型。




