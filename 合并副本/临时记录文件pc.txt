HashMap的原理
 底层使用哈希表（数组 + 链表），当链表过长会将链表转成 红黑树以实现 O(logn) 时间复杂度内查找
 
 扩容
 当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列
 元素的下标要么不变，要么变为【原下标+原容量】
 
  `TreeSet` 底层是 `TreeMap`，`TreeMap` 是基于红黑树来实现的。
  
  
  红黑树
  
  
  Comparable 接口和 Comparator 接口实现比较
    - Comparable 是直接在"被比较"的类内部来实现的
    - Comparator则是在被比较的类外部实现的
	
Java 中所有异常都是 `Throwable` 的子类，他的直接子类有两个，一个是 `Error`, 一个是 `Exception（运行+编译）

Java 的 NIO 组合使用了 IO 复用 + 非阻塞 IO 两种 IO 模型

按照 IO 的对象，可以分为 4 类。分别是：
        1. 基于字节操作的 I/O 接口：InputStream 和 OutputStream
        1. 基于字符操作的 I/O 接口：Writer 和 Reader
        1. 基于磁盘操作的 I/O 接口：File
        1. 基于网络操作的 I/O 接口：Socket
		

 单例模式的生命周期
    - 一般来说单例模式创建的对象是由类的 static 变量引用着的，JVM 如果采用可达性分析算法来回收的话，该对象是永远不可能被回收的（从创建以后）。
	
	
分代收集。这种方法没有使用新算法，只是根据对象的特点将堆分为年轻代和老年代，年轻代使用复制算法，老年代使用标记整理算法。
minor GC 和 Full GC 的触发时机
    - minor GC: 当 eden 区满以后会触发。
    - Full GC：
        1. JVM 的一些特性比如分配担保，大对象直接进入老年代，长期存活的对象进入老年代等等都会不断增加老年代的使用率，当老年代空间不足以支持下一次 Minor GC 时会触发一次 Full GC
        1. 当用户代码调用 System.gc 时，系统系统建议执行 Full GC，但是否进行是由 JVM 来决定的。

GC roots 不可达的对象是可以回收的

JDK1.8 中 JVM 做了那些改变
    - 主要是撤销了永久代，引入元空间（本地内存）

	
	介绍一下 Java 的强软弱虚四种引用，问什么时候使用软引用(待定)


双亲委派模型

cglib 动态代理。通过框架转换字节码生成目标类的子类，并覆盖其中的方法实现增强，

 Controller 是单例的，跟 Servlet 一样。

 
 索引为什么用 B 树不用二叉树，有什么好处？
    - 基于 B 树的索引实现，降低了树的高度，减少了磁盘 IO 的次数。
	
一般线程和守护线程的区别


浏览器查询域名的 IP。一般会有以下几个地方：
        1. 浏览器缓存
        1. 操作系统缓存
        1. 路由器缓存
        1. 本地 DNS 服务器
        1. 如果本地 DNS 服务器上没有的话，它会递归的从根 DNS 服务器、顶级 DNS 服务器、权威 DNS 服务器请求，然后把获取到的 IP 返回给浏览器（DNS 协议基于 UDP）。
		
		
如何设计一个高并发的系统
    - 数据库的优化，包括合理的事务隔离级别、SQL语句优化、索引的优化
    - 使用缓存，尽量减少数据库 IO
    - 分布式数据库、分布式缓存
    - 服务器的负载均衡
	
	
	
从 innodb 的索引结构分析，为什么索引的 key 长度不能太长？


参考答案
key 太长会导致一个页当中能够存放的 key 的数目变少，间接导致
索引树的页数目变多，索引层次增加，从而影响整体查询变更的效
率
	
MySQL 的数据如何恢复到任意时间点？
参考答案
恢复到任意时间点以定时的做全量备份，以及备份增量的 binlog 日
志为前提。恢复到任意时间点首先将全量备份恢复之后，再此基础
上回放增加的 binlog 直至指定的时间点。


假如给你一个新产品，你将从哪些方面来保障它的质量？
参考答案
可以从代码开发、测试保障、线上质量三个方面来保障。
在代码开发阶段，有单元测试、代码Review、静态代码扫描等；测
试保障阶段，有功能测试、性能测试、高可用测试、稳定性测试、
兼容性测试等；在线上质量方面，有灰度发布、紧急回滚、故障演
练、线上监控和巡检等
	

	
	concurrenthashmap 的size实现
	http://www.cnblogs.com/ITtangtang/p/3966467.html
	MQ如何保证顺序性
	一个Controller是单例还是多实例
	Redis的内存废弃策略。redis高并发的key怎么处理。默认持久化
	
	Spring MVC的aop实现原理，  是那种方式
dubbo原理
zookeeper原理
netty原理

线上处理经验

Java基础知识和分布式经验应该很熟悉，框架层面源码如果能研读可以加分。但是如果只是会用而不了解原理就要减分。

重点
过往的工作经验是owner一个独立的业务系统，负责系统的设计开发工作。
明确知道系统架构的情况，理解上下游关系。
理解该系统的业务定位，该系统当前存在的问题和后续的规划发展有自己的见解。S
Java基础知识和分布式经验应该很熟悉，框架层面理解原理，适当看源码
重点考察分布式/服务化系统（不是大流量高并发）的设计原理，思路，关注点。
要会理解一些分布式session、全局流水ID号、服务多次重试幂等、同步转异步、服务监控、最终一致性等原理和应用。
2主导一个复杂的系统（多个业务系统完整链路）；或者负责一块五脏俱全的业务。
3 对业务系统的理解会更多从商业价值角度去描述，熟悉这块产品链的模式和玩法，或者工业化成熟度较高的专业实现方案。
4分布式系统设计原则：分库分表分布式事务、性能稳定性的实践。
如果能描述分库分表中间件实现原理（SQLParse、语法树）、单元化/多机房灾备



jre jdk


static方法不能覆盖

值传递，传递了对象副本，就算改变对象副本，也不会改变源对象的值
引用传递，传递的不是实际的对象，而是对象的引用，外部对引用所做的改变，会反应到所有的对象上

线程的就绪状态：线程准备运行，但不一定立马就能开始执行

阻塞：等待，sleep，io阻塞，同步阻塞


死锁避免，指定获取锁顺序，强制线程按照指定的顺序获取锁，线程都按照同样的顺序加锁解锁，就不会死锁了

iterator迭代器可以在迭代的过程中删除底层集合的元素


对象不可达，就可以回收

快速失败和安全失败的区别


jvm中的永久代会垃圾回收吗
java8中已移除永久代，新加一个元数据区的na'tive内存区
