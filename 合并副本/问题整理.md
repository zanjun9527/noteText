

事务特性 ACID   
原子性、一致性、隔离性和持久性

RPC 通信和 RMI 区别

什么是 B+树，B-树，列出实际的使用场景


设计模式，单例模式

分布式事务



## 线程相关
线程池介绍
数据连接池的工作机制

有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行
CountDownLatch也可以实现join的功能。近似的实现了join()功能，

synchronized 和 lock

当一个线程进入一个对象的 synchronized 方法A 之后，其它线程是否可进入此对象的 synchronized 方法B
看锁的对象，方法锁、对象锁、类锁

实现分布式锁


同一把lock的wait 和notify要对应起来使用

创建thread也可以使用子类覆盖run方法的方式，override thread中的run方法


threadlocal操作对象，是获取当前线程的threadlocalmap对象，线程独享，key是threadlocal对象，value是待存值，

线程结束时可以调用threadlocal的remove方法更快释放内存，不调也行，线程结束后可自动释放相关threadlocal变量

使用场景：增加一个使用相同的数据库连接对象

//线程安全
public static final ThreadLocal<Connection> tl = new ThreadLocal<Connection>();


new对象时，可重写其ThreadLocal的initialValue方法，完成初始化，也可以get时候懒加载对象


obj中的 public synchronized void inc(){}  这种是锁的当前实例对象，使用同一个new的obj对象即可
   这里可以将obj通过构造函数方式传入runnable对象中

重点是锁的对象，锁同一对象，才会出现资源竞争的情况


也可将obj设计成final类型，这样可以使用匿名内部类简化线程启动写法，将锁的方法抽象到obj对象中去实现

放在同一类的不同方法中，方便使用同一锁实现资源的互斥模拟。


内存模型
线程访问对象值时，先通过对象引用找到对应在堆内存的变量的值，然后load到本地内存，建立变量副本，最后再回写回去，也就是所说的线程工作内存和主内存之间的操作。


final Semaphore semaphore = new Semaphore(0);

确保b,c在a之后完成
a中直接release(2)

b,c中获取，acquire()，若没有可用则等待

semaphore.acquire();			//申请一个许可  许可池-1   若许可池为0则申请许可失败，阻塞线程
semaphore.release();			//释放一个许可  许可池+1


问题
同一类中2个方法都加了同步锁，多个线程能同时访问同一个类中的这两个方法吗
lock 和  synchronized  

类加载 双亲委派

## jvm相关
JVM 参数，线上问题
生产线上内存参数配置多少


gc常用搜素算法，引用计数法(废弃)  和 根搜索算法(使用)
回收算法，标记清除算法，复制算法，标记整理算法， 分代收集算法（使用）


从gcroot开始搜索，对象不可达就要被回收，即该对象已死。
计数器不行，因为两个对象相互等待，计数器不为0


内存溢出
常见原因，1.内存中加载数据量过大，如一次从数据库取出过多数据
2.集合使用对象引用，使用后未清空，jvm无法回收
3.死循环或循环过多重复对象
4.启动参数设置过小

方案
1.修改jvm启动参数  2.检查错误日志，查看溢出错误前是否有其他异常
3.代码走查分析，寻找可能的错误位置





内存三大部分，
堆，
   堆中数据占用大小在编译时无法确定
栈，
   一个线程一个栈，一个方法一个栈帧，数据运行时确定
   基础数据类型直接在栈空间分配，包装类如Integer等存放在堆中
   声明在函数中一个局部变量 int b，系统自动在栈中为b开辟空间

方法区
   常数池，源代码中命名常量，string常量和static变量保存在方法区
   比如100，"hello"和常量都放在常量池中

## io相关
字节流继承于inputStream和outputStream
字符流继承于inputStreamReader和outputStreamwriter

二者的转换
使用流进行序列化和反序列化，objectoutputStream 和 objectinputStream

只处理纯文本优先用字符流（用writer和reader操作），其他都用字节流，



## 数据结构
map的排序，
都是使用comparator来比较
1.collections.sort()对list<entry>排序，然后放入linkedhashmap中
2.直接使用treemap,自定义comparator，匿名内部类使用

concurrenthashmap中的segment继承自reentrantlock
hashset需要重写equals 和 hashcode方法? 可通过comparator自定义顺序


问题
线程a中执行b的join()，a会等待到b执行完成？



## 数据库

二叉树要看下
preparedstatement是statement的子类，优点在于1sql注入的安全性，启用了预编译，相同的调用不会重复编译
关联查询每步，会产生虚拟表，被用作下个查询步骤的输入

sql注入，使用预编译语句将参数当作字符串取查询+使用#不要用$
#相当于对数据加上双引号当成一个字符串，$相当于直接显示
$一般用于传入数据库对象，如传入表名

not exists 能使用索引，not in 不能使用索引
int,not in,is null, is not null,<>不用索引
连续数值能用between就不要用in，
***可用exists代替in

表达式操作和函数，都不走索引

索引字段尽量使用not null字段

join时，应用兄的结果驱动大的结果，left join左表结果尽量小

limit基数比较大时使用between

解决乱码的核心思想是统一编码

mysql优化
查询优化时，在where以及order by 涉及到的列上建立索引

查询数字型mysql比一次，字符串会对比每个字符

避免where使用or来连接条件，这样不走索引，等价的优化方法是使用union all 来代替

线程中的单例bean不是线程安全的，因为多个线程存在资源的竞争











## 杂项
3*0.1 == 0.3  false  精度问题
float f=3.4; 是否正确？3.4f
冒泡排序
获取月初末天，calendar和localdate都可以，是jdk8新增时间操作   localtime等

equals相等，hashcode必相等

基本数据类型字节大小  char 2    int 4  byte 1   double 8
String 是引用类型，不是基本类型

String s="a";  s=s+"v";  这里String是不可变的，只是指向了另一个string对象，原先的还在

重载和重写也是多态的体现，主要还是接口，静态方法无法重写
对象的三大特性，继承，多态，封装，抽象一般不提
权限修饰符范围


switch不可作用在long,double,float,boolean，包括他们的包装类

get 和 post只是发送机制不同，并不是一个取一个发

请求转发是服务器行为，一次请求，地址不变，访问自身web资源，传输数据不会丢失
重定向是客户端行为，两次请求，浏览器地址变化，可访问自己web外的资源，传输数据会丢失


使用redis共享session，要与业务逻辑代码解耦，否则没有意义
redis是纯内存操作，异步入磁盘
一般是从使用持久化，主机器不要

单点登录的原理
后端生成一个sessionid设置到cookie中，供后面请求用，sessionid本质是获取用户信息数据。
除了cookie，通常 还是用http请求头来传输，这里需要手工处理下传输

跨域
js只能访问与包含它的文档在同一域下的内容
ajax不能向不同的域提交请求

jsonp原理(忽略)
动态添加一个<script>标签，使用该标签的src属性没有跨域的限制的特点实现跨域。
   首先在客户端注册一个callback，并将其名字传给服务器，服务器生成json数据，然后以js语法方式生成一个function，其名字就是传递上来的参数jsonp，最后将json数据直接以入参的方式放置到function，这样就生成一段js语法的文档，返回给客户端，客户端浏览器解析script标签，并执行返回给javascript文档，此时数据作为参数，传入到客户端预先定义好的callback函数里


aop 有两个，核心关注点（业务）和横切关注点（基本相似的处理）
切面将多个类的通用行为封装成可重用的模块

spring只支持方法类型的连接点，就是被拦截到的方法

2018-shiro忽略
控制级别
url级别，方法级别，代码级别，页面标签权限控制


按值传递特点，传递的是值的拷贝，传递后互不相关
按引用传递特点，传递的引用地址，就是变量对应的内存空间地址，传递前后指向同一个引用，

秒杀系统

rm -i 交互删除，给提示



java8
lambda只能引用final或final局部变量，不能在lambda内部修改定义在域外的变量