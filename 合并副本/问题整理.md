重核

设计模式，单例模式
分布式事务
秒杀系统

平台提升即可，在公司的主要工作内容，技术只谈技术，杂的和别人谈
尊重和平等


## 线程相关
线程池介绍，工作机制,优点
  线程池的工作流程和包和策略，主要核心线程参数corePoolSize,maximumPoolSize，队列等

  流程：corePoolSize - 工作队列(workQueue) - maximumPoolSize,必要时创建非核心线程，满了交给饱和策略(无法处理新任务时抛出异常)

  使用线程池的好处:
  线程池可以减少创建和销毁的开销，避免频繁切换线程，任务调度
  控制线程数量,集中管理线程



事务特性 ACID   
原子性、一致性、隔离性和持久性

ThreadLocal对象本质是操作Thread.ThreadLocalMap<ThreadLocal, Object>这个对象

线程中断的概念
只是加中断标记，不立刻执行，按需终止。
interrupt加标记，isInterrupted()判断后决定是否去终止

终止线程常用
1.正常运行结束
2.Interrupt中断
3.异常终止

### 锁相关
实现分布式锁
内存模型(工作内存，主内存，堆栈内存)
线程访问对象值时，先通过对象引用找到对应在堆内存的变量的值，然后load到本地内存，建立变量副本，最后再回写回去，也就是所说的线程工作内存和主内存之间的操作。

CountDownLatch 也可以实现join功能
a，b，c三个线程执行顺序,   a>(b,c)
CountDownLatch(1)，countDown() 和  await()
Semaphore(0)，acquire() 和 release()

当一个线程进入一个对象的 synchronized 方法A 之后，其它线程是否可进入此对象的 synchronized 方法B，不能
对于同一个对象obj的两个synchronized方法a，b，一个线程占用方法a后，另一个线程不能进入对象的方法b，因为这里是前者线程持有了obj的锁，锁的是整个实例对象

自旋锁使用场景
自选等待时间小于持锁时间，减少线程切换

condition是对wait方法的补充，可以选择唤醒顺序
synchronized 和 lock
公平，可重入，可中断

## jvm相关
类加载 双亲委派(向上递归检查，向下递归加载),一个类只能被一个类加载器加载
JVM 参数，线上问题
生产线上内存参数配置多少
分代回收，年轻代、老年代
内存三大部分，堆,栈,方法区
判断对象存活，根路径可达性

什么情况下触发垃圾回收？


## io相关
字节流继承于inputStream和outputStream
字符流继承于inputStreamReader和outputStreamwriter

二者的转换
使用流进行序列化和反序列化，objectoutputStream 和 objectinputStream
只处理纯文本优先用字符流（用writer和reader操作），其他都用字节流，

nio的优点

nio 主要就是一个线程对应多个socket连接
Selector(选择区)用于监听多个通道的事件。因此，单个线程可以监听多个数据通道。

client socket->socketchannel->selector-handle process thread

为什么nio是非阻塞的
    一个线程可以哪个socket空闲处理哪个，不想原来的每个线程socket都可能阻塞

    一个面向流，一个面向缓冲区

  IO
    服务器端的socket编程，最早的Java是所谓的阻塞IO(Blocking IO)， 想处理多个socket的连接的话需要创建多个线程， 一个线程对应一个。数量一多，效率降低
    一个线程控制一个socket来读写，容易阻塞 
  NIO     
    通过多路复用的方式让一个线程去处理多个Socket。	一个线程通过一个selector，控制多个socket的读写 
    只需要使用少量的线程就可以搞定多个socket了，线程只需要通过Selector去查一下它所管理的socket集合，哪个Socket的数据准备好了，就去处理哪个Socket。


## 数据结构
treeMap的自定义排序（comparator，排list<entry>或者key，key是初始化比较器）

ConcurrentHashMap = Segment[] 和 HashEntry[] 组成
一个Segment里包含一个HashEntry数组


## 数据库
覆盖索引 和 回表查询，mysql的索引树,B+树，B-树结构
隔离级别
InnoDB特点
行级锁都是基于索引的，   用不到索引是不会使用行级锁的，走表锁

namespace+id 作为Map<String,MappedStatement>的key使用，namespace不能重复

## 缓存相关
  Redis的内存废弃策略
  MQ如何保证顺序性

## 事务相关
编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于 AOP


## 杂项

dubbo原理
zookeeper原理
netty原理

### 基础知识
filter 拦截器，servlet

内存模型中，线程间的变量值传递，需要通过主内存


简单点说，Java 中的传递，是值传递，而这个值，实际上是对象的引用。
传递的值在栈中，直接拷贝一份值传递，改变的形参不会对实参造成影响
传递的值在栈中存放的是地址（引用），先根据栈中的地址找到在堆上的值，然后把地址拷贝一份（拷贝的地址是一个值），此时形参和实参指向堆上同一个地址，形参的修改导致了实参的改变。


线上处理经验
Java基础知识和分布式经验应该很熟悉，框架层面源码如果能研读可以加分。但是如果只是会用而不了解原理就要减分。
重点
过往的工作经验是owner一个独立的业务系统，负责系统的设计开发工作。
明确知道系统架构的情况，理解上下游关系。
理解该系统的业务定位，该系统当前存在的问题和后续的规划发展有自己的见解。
Java基础知识和分布式经验应该很熟悉，框架层面理解原理，适当看源码
重点考察分布式/服务化系统（不是大流量高并发）的设计原理，思路，关注点。
要会理解一些分布式session、全局流水ID号、服务多次重试幂等、同步转异步、服务监控、最终一致性等原理和应用。
2主导一个复杂的系统（多个业务系统完整链路）；或者负责一块五脏俱全的业务。
3 对业务系统的理解会更多从商业价值角度去描述，熟悉这块产品链的模式和玩法，或者工业化成熟度较高的专业实现方案。
4分布式系统设计原则：分库分表分布式事务、性能稳定性的实践。
如果能描述分库分表中间件实现原理（SQLParse、语法树）、单元化/多机房灾备

######临时记录区域，防止冲突合并######

