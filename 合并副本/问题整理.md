


思路是抓核心，抓重点



事务特性 ACID   
原子性、一致性、隔离性和持久性

RPC 通信和 RMI 区别

什么是 B+树，B-树，列出实际的使用场景


设计模式，单例模式

分布式事务



## 线程相关
线程池介绍
数据连接池的工作机制
需要知道几个核心线程参数corePoolSize等的运行流程，
工作流程和包和策略


newFixedThreadPool 创建的线程池 corePoolSize 和 maximumPoolSize 值是相等的，
它使用的 LinkedBlockingQueue；
newSingleThreadExecutor 将 corePoolSize 和 maximumPoolSize 都设置为 1，也使用
的 LinkedBlockingQueue；
newCachedThreadPool 将 corePoolSize 设置为 0，将 maximumPoolSize 设置为
Integer.MAX_VALUE，使用的 SynchronousQueue，也就是说来了任务就创建线程运
行，当线程空闲超过 60 秒，就销毁线程。
实际中，如果 Executors 提供的三个静态方法能满足要求，就尽量使用它提供的三个方
法，因为自己去手动配置 ThreadPoolExecutor 的参数有点麻烦，要根据实际任务的类型
和数量来进行配置。

lock中
▪ lockInterruptibly：如果当前线程没有被中断，就获取锁；否则抛出
InterruptedException，并且清除中断
▪ tryLock，只在锁空闲的时候才获取这个锁，否则返回 false，所以它不会 block
代码的执行


使用锁的 newCondition 方法可以返回一个该锁的 Condition 对
象，如果说锁对象是取代和增强了 synchronized 关键字的功能的话，那么
Condition 则是对象 wait/notify/notifyAll 方法的替代。在下面这个例子中，lock 生
成了两个 condition，一个表示不满，一个表示不空：

▪ 在 put 方法调用的时候，需要检查数组是不是已经满了，满了的话就得等待，
直到“不满”这个 condition 被唤醒（notFull.await()）；
▪ 在 take 方法调用的时候，需要检查数组是不是已经空了，如果空了就得等待，
直到“不空”这个 condition 被唤醒（notEmpty.await()）：


condition.signal();


CompletionService.class，它是对 ExecutorService 的改进，因为 ExecutorService 只
是负责处理任务并把每个任务的结果对象（Future）给你，却并没有说要帮你“管 理”这些结果对象，这就意味着你得自己建立一个对象容器存放这些结果对象，很
麻烦；CompletionService 像是集成了一个 Queue 的功能，你可以调用 Queue 一样
的方法——poll 来获取结果对象，还有一个方法是 take，它和 poll 差不多，区别在
于 take 方法在没有结果对象的时候会返回空，而 poll 方法会 block 住线程直到有
结果对象返回
▪ ExecutorCompletionService.class，是 CompletionService 的实现类


默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线
程。


有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行
CountDownLatch也可以实现join的功能。近似的实现了join()功能，

synchronized 和 lock

当一个线程进入一个对象的 synchronized 方法A 之后，其它线程是否可进入此对象的 synchronized 方法B
看锁的对象，方法锁、对象锁、类锁



案例代码
Lock lock = ...;
lock.lock();
try{
//处理任务
}catch(Exception ex){
}finally{
lock.unlock(); //释放锁
}


Lock lock = ...;
if(lock.tryLock()) {
   try{
      //处理任务
   }catch(Exception ex){
   }finally{
      lock.unlock(); //释放锁，上面tryLock了
   }
}else {
//如果不能获取锁，则直接做其他事情
}


线程的中断lockInterruptibly 和interrupt看下，用在哪里


lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等
待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同
时通过 lock.lockInterruptibly()想获取某个锁时，假若此时线程 A 获取到了锁，而线程
B 只有在等待，那么对线程 B 调用 threadB.interrupt()方法能够中断线程 B 的等待过
程。
由于 lockInterruptibly()的声明中抛出了异常，所以 lock.lockInterruptibly()必须
放在 try 块中或者在调用 lockInterruptibly()的方法外声明抛出
InterruptedException。
 因此 lockInterruptibly()一般的使用形式如下：

public void method() throws InterruptedException {
lock.lockInterruptibly();
try {
//.....
}
finally {
lock.unlock();
} }
 注意，当一个线程获取了锁之后，是不会被 interrupt()方法中断的。因为本身在前
面的文章中讲过单独调用 interrupt()方法不能中断正在运行过程中的线程，只能中断阻
塞过程中的线程。
 因此当通过 lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待
的情况下，是可以响应中断的


而用 synchronized 修饰的话，当一个线程处于等待某个锁的状态，是无法被中断
的，只有一直等待下去。



注意要是同一个锁对象才会竞争

在 insert 方法中的 lock 变量是局部变量，每个线程执行该方法时
都会保存一个副本，那么理所当然每个线程执行到 lock.lock()处获取的是不同的锁，所以
就不会发生冲突


ConcurrentHashMap 并没有采用 synchronized 进行控制，而是使用了 ReentrantLock。


锁提供了两种主要
特性：互斥（mutual
exclusion）和可见性（visibility）。

volatile 变量不能用作线程安全计数器。虽然增量操作
（x++）看上去类似一个单独操作，实际上它不是原子的

可重入
当一个线程执行到某个 synchronized 方法时，比
如说 method1，而在 method1 中会调用另外一个 synchronized 方法 method2，此时
线程不必重新去申请锁，而是可以直接执行方法 method2。

可中断
如果某一线程 A 正在执行锁中的代码，另一线程 B 正在等待获取该锁，可能由于等待
时间过长，线程 B 不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线
程中中断它，这种就是可中断锁

ReentrantReadWriteLock 并未实现 Lock 接口，它实现的是
ReadWriteLock 接口


NIO，BIO，AIO 忽略

一.IO 是面向流的，NIO 是面向缓冲区的。
二.IO 的各种流是阻塞的，NIO 是非阻塞模式。
三.Java NIO 的选择器允许一个单独的线程来监视多个输入通道，你可以注册
多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道
里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得
一个单独的线程很容易来管理多个通道。


序列化
把对象转换为字节序列的过程称为对象的序列化。
把字节序列恢复为对象的过程称为对象的反序列化。
对象的序列化主要有两种用途：
一.把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；
二.在网络上传送对象的字节序列。
当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类
型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个 Java
对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为
Java 对象。


内存模型
每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。
当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存
的变量的值，然后把堆内存变量的具体值 load 到线程本地内存中，建立一个变
量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副
本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量
副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。

实现分布式锁


同一把lock的wait 和notify要对应起来使用

创建thread也可以使用子类覆盖run方法的方式，override thread中的run方法


threadlocal操作对象，是获取当前线程的threadlocalmap对象，线程独享，key是threadlocal对象，value是待存值，

线程结束时可以调用threadlocal的remove方法更快释放内存，不调也行，线程结束后可自动释放相关threadlocal变量

使用场景：增加一个使用相同的数据库连接对象

//线程安全
public static final ThreadLocal<Connection> tl = new ThreadLocal<Connection>();


new对象时，可重写其ThreadLocal的initialValue方法，完成初始化，也可以get时候懒加载对象


obj中的 public synchronized void inc(){}  这种是锁的当前实例对象，使用同一个new的obj对象即可
   这里可以将obj通过构造函数方式传入runnable对象中

重点是锁的对象，锁同一对象，才会出现资源竞争的情况


也可将obj设计成final类型，这样可以使用匿名内部类简化线程启动写法，将锁的方法抽象到obj对象中去实现

放在同一类的不同方法中，方便使用同一锁实现资源的互斥模拟。


内存模型
线程访问对象值时，先通过对象引用找到对应在堆内存的变量的值，然后load到本地内存，建立变量副本，最后再回写回去，也就是所说的线程工作内存和主内存之间的操作。


final Semaphore semaphore = new Semaphore(0);

确保b,c在a之后完成
a中直接release(2)

b,c中获取，acquire()，若没有可用则等待

semaphore.acquire();			//申请一个许可  许可池-1   若许可池为0则申请许可失败，阻塞线程
semaphore.release();			//释放一个许可  许可池+1


问题
同一类中2个方法都加了同步锁，多个线程能同时访问同一个类中的这两个方法吗
lock 和  synchronized  

何停止一个线程


1. 使用退出标志，使线程正常退出，也就是当 run 方法完成后线程终止。
2. 使用 stop 方法强行终止，但是不推荐这个方法，因为 stop 和 suspend 及 resume一样都是作废方法。
3. 使用 interrupt 方法中断线程。


interrupt 中断线程的意义是啥?
interrupt()方法的使用效果并不像 for+break 语句那样，马上就停止循环。调用 interrupt
方法是在当前线程中打了一个停止标志，并不是真的停止线程。

判断线程是否停止状态
Thread.java 类中提供了两种方法：
1. this.interrupted(): 测试当前线程是否已经中断；
2. this.isInterrupted(): 测试线程是否已经中断；

官方帮助文档中对 interrupted 方法的解释：
测试当前线程是否已经中断。线程的中断状态由该方法清除。 换句话说，如果连续两次调用该
方法，则第二次调用返回 false。

这种也行
if(this.isInterrupted()){
 System.out.println("线程被停止了！");
 return;
 }



synchronized修饰的代码，作用的对象是调用这个代码块的对象
lock需要手动释放锁，tryLock 方法可以非阻塞方式去拿锁


注意这里是针对锁对象
void wait() 导致当前的线程等待，直到其他线程调用此对象的 notify()方法或
notifyAll()方法。
void wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的
notify()方法或 notifyAll()方法，或者超过指定的时间量。

类加载 双亲委派



高内聚，低耦合


这个讲的好像不对，针对同一个进程中的同一个资源锁
，ReentrantLock 的 lock 和 unlock 要求必须是
在同一线程进行，而分布式应用中，lock 和 unlock 是两次不相关的请求，因此肯
定不是同一线程，因此导致无法使用 ReentrantLock



分布式锁的使用数据库乐观锁，本质也是提交时判断冲突，版本号



aba问题

## jvm相关
JVM 参数，线上问题
生产线上内存参数配置多少


gc常用搜素算法，引用计数法(废弃)  和 根搜索算法(使用)
回收算法，标记清除算法，复制算法，标记整理算法， 分代收集算法（使用）


从gcroot开始搜索，对象不可达就要被回收，即该对象已死。
计数器不行，因为两个对象相互等待，计数器不为0


内存溢出
常见原因，1.内存中加载数据量过大，如一次从数据库取出过多数据
2.集合使用对象引用，使用后未清空，jvm无法回收
3.死循环或循环过多重复对象
4.启动参数设置过小

方案
1.修改jvm启动参数  2.检查错误日志，查看溢出错误前是否有其他异常
3.代码走查分析，寻找可能的错误位置





内存三大部分，
堆，
   堆中数据占用大小在编译时无法确定
栈，
   一个线程一个栈，一个方法一个栈帧，数据运行时确定
   基础数据类型直接在栈空间分配，包装类如Integer等存放在堆中
   声明在函数中一个局部变量 int b，系统自动在栈中为b开辟空间

方法区
   常数池，源代码中命名常量，string常量和static变量保存在方法区
   比如100，"hello"和常量都放在常量池中
   常量池，class信息、线程共享

   永久代，非堆

建立对象，保证gc root 到对象之间有可达路径，一直创建就会oom

一. 可通过命令定期抓取heap dump或者启动参数OOM时自动抓取heap dump文件。
二. 通过对比多个heap dump，以及heap dump的内容，分析代码找出内存占用最多的地方。
三. 分析占用的内存对象，是否是因为错误导致的内存未及时释放，或者数据过多导致的内存溢出。


堆是线程共享，

一般来说，一个 Java 的引用访问涉及到 3 个内存区域：JVM 栈，堆，方法区。
 以最简单的本地变量引用：Object obj = new Object()为例：
• Object obj 表示一个本地引用，存储在 JVM 栈的本地变量表中，表示一个 reference
类型数据；
• new Object()作为实例对象数据存储在堆中；
• 堆中还记录了 Object 类的类型信息（接口、方法、field、对象类型等）的地址，这些
地址所执行的数据存储在方法区中；

年轻代的垃圾回收过程，老年代的，简单重点流程即可



双亲委派机制。通俗的讲，
就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载
器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法
完成此加载任务时，才自己去加载

但在 JVM 中一个类用其全名和一个加载类 ClassLoader
的实例作为唯一标识，不同类加载器加载的类将被置于不同的命名空间。


## io相关
字节流继承于inputStream和outputStream
字符流继承于inputStreamReader和outputStreamwriter

二者的转换
使用流进行序列化和反序列化，objectoutputStream 和 objectinputStream

只处理纯文本优先用字符流（用writer和reader操作），其他都用字节流，



## 数据结构
map的排序，
都是使用comparator来比较
1.collections.sort()对list<entry>排序，然后放入linkedhashmap中
2.直接使用treemap,自定义comparator，匿名内部类使用

concurrenthashmap中的segment继承自reentrantlock
hashset需要重写equals 和 hashcode方法? 可通过comparator自定义顺序


问题
线程a中执行b的join()，a会等待到b执行完成？



## 数据库

   二叉树要看下
   preparedstatement是statement的子类，优点在于1sql注入的安全性，启用了预编译，相同的调用不会重复编译
   关联查询每步，会产生虚拟表，被用作下个查询步骤的输入

   sql注入，使用预编译语句将参数当作字符串取查询+使用#不要用$
   #相当于对数据加上双引号当成一个字符串，$相当于直接显示
   $一般用于传入数据库对象，如传入表名

   not exists 能使用索引，not in 不能使用索引
   int,not in,is null, is not null,<>不用索引
   连续数值能用between就不要用in，
   ***可用exists代替in

   表达式操作和函数，都不走索引

   索引字段尽量使用not null字段

   join时，应用兄的结果驱动大的结果，left join左表结果尽量小

   limit基数比较大时使用between

   解决乱码的核心思想是统一编码

   mysql优化
   查询优化时，在where以及order by 涉及到的列上建立索引

   查询数字型mysql比一次，字符串会对比每个字符

   避免where使用or来连接条件，这样不走索引，等价的优化方法是使用union all 来代替

   线程中的单例bean不是线程安全的，因为多个线程存在资源的竞争

   PreparedStatement 和  Statement
   一.PreparedStatement 是预编译的,对于批量处理可以大大提高效率. 也叫
   JDBC 存储过程
   二.使用
   Statement 对象。在对数据库只执行一次性存取的时侯，用
   Statement 对象进行处理。PreparedStatement
   对象的开销比 Statement 大，对于一次性操作并不会带来额外的好处。
   三.statement 每次执行 sql 语句，相关数据库都要执行 sql 语句的编译，
   preparedstatement 是预编译得,
   preparedstatement 支持批处理
   这种转换也给你带来很大的便利，不必重复 SQL 语句的句法，而只需更改其中
   变量的值，便可重新执行 SQL 语句。选择 PreparedStatement 对象与否，在
   于相同句法的 SQL 语句是否执行了多次，而且两次之间的差别仅仅是变量的不
   同。如果仅仅执行了一次的话，它应该和普

   安全性。传递给，主要是sql注入的安全性
   PreparedStatement 对象的参数可以被强制进行类型转换，使开发人员可以确
   保在插入或查询数据时与底层的数据库格式匹配。


   ，使用 select…for update 会把数据给锁住，不过我们需要注意
一些锁的级别，MySQL InnoDB 默认行级锁。行级锁都是基于索引的，如果一
条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这
点需要注意。

乐观锁假设认为数据一般
情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲
突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如
何去做

实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。

总体来说，防治 SQL 注入式攻击可以采用两种方法，一是加强对用户输入内容的检查
与验证;二是强迫使用参数化语句来传递用户输入的内容。在

聚集索引
在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚
集索引


b树中，B 树中每个节点包含了键值和键值对于的数据对象存放地址指针，所以成功搜索一个对象
可以不用到达树的叶节点。

用 UNION 替换 OR (适用于索引列)
通常情况下, 用 UNION 替换 WHERE 子句中的 OR 将会起到较好的效果. 对索引列使用 OR
将造成全表扫描. 注意, 以上规则只针对多个索引列有效. 如果有 column 没有被索引, 查询
效率可能会因为你没有选择 OR 而降低. 在下面的例子中, LOC_ID 和 REGION 上都建有索
引

用 IN 来替换 OR

低效: (索引不被使用)
SELECT DEPT_CODE FROM DEPT ORDER BY DEPT_TYPE
高效: (使用索引)
SELECT DEPT_CODE FROM DEPT WHERE DEPT_TYPE > 0

序，原则上，应该
首先定义最唯一的列，例 如在（COL1，COL2）上的索引与在（COL2，COL1）上的索引是
不相同的，因为两个索引的列的顺序不同；为了使查询优化器使用复合索引，查询语 句中的
WHERE 子句必须参考复合索引中第一个列；当表中有多个关键列时，复合索引是非常有用
的；使用复合索引可以提高查询性能，减少在一个表中所创建的 索引数量。

where 语句中索引独立出现，索引才会起作用，不要放在表达式中(如: 转换函数一般放在值那边，不
要放在列那边)，或发生不合适的隐式转换


转换函数一般放在值那边，不要放在列那边，因为在列那边会隐士转换，或其他原因，造成
索引失效


. 如果条件中有 or，即使其中有条件带索引也不会使用(这也是为什么尽量少用 or 的原因)
要想使用 or，又想让索引生效，只能将 or 条件中的每个列都加上索引


## 事务相关

编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明
式事务由于基于 AOP

Spring 提供两种方式的编程式事务管理，分别是：使用 TransactionTemplate(常用) 和直接使用
PlatformTransactionManager(不常用)。

(忽略)
DataSourceTransactionManager dataSourceTransactionManaer = new DataSourceTransactionManager(); 
//定义一个某个框架平台的 TransactionManager，如 JDBCHibernate
 dataSourceTransactionManager.setDataSource(this.getJdbcTemplate().getDataSource()); // 设置数据源
 DefaultTransactionDefinition transDef = new DefaultTransactionDefinition(); // 定义事务属性
 transDef.setPropagationBehavior(DefaultTransactionDefinition.PROPAGATION_REQUIRED); //设置传播行为属性
 TransactionStatus status = dataSourceTransactionManager.getTransaction(transDef); // 获得事务状态
 try {
 // 数据库操作
 dataSourceTransactionManager.commit(status);// 提交
 } catch (Exception e) {
 dataSourceTransactionManager.rollback(status);// 回 滚
 }






## 杂项

DispatcherServlet 根据 HandlerMapping 找到对应的 Handler,将处理权交给 Handler
（Handler 将具体的处理进行封装），再由具体的 HandlerAdapter 对 Handler 进行具体的
调用。


ModelAttribute忽略

sudo chmod [u 所属用户 g 所属组 o 其他用户 a 所有用户] [+增加权限 -减少权
限] [r w x] 目录名

### 基础知识

Servlet 生命周期：Servlet 加载--->实例化--->服务--->销毁。

Servlet Servlet 容器在启动时自动创建 Servlet，这是由在 web.xml 文件中为 Servlet 设置
的<load-on-startup>属性决定的。从中我们也能看到同一个类型的 Servlet 对象在 Servlet
容器中以单例的形式存在。

在一个 web 应用中，可以开发编写多个 Filter，这些 Filter 组合起来称之为一个 Filter 链。
web 服务器根据 Filter 在 web.xml 文件中的注册顺序<mapping>，决定先调用哪个 Filter，
当第一个 Filter 的 doFilter 方法被调用时，web 服务器会创建一个代表 Filter 链的
FilterChain 对象传递给该方法。在 doFilter 方法中，开发人员如果调用了 FilterChain 对象的
doFilter 方法，则 web 服务器会检查 FilterChain 对象中是否还有 filter，如果有，则调用第
2 个 filter，如果没有，则调用目标资源

public ServletContext getServletContext()：返回 Servlet 上下文对象的引用。
（2）FilterConfig 提供参数，是 Filter 类私有参数，Filter2 的初始化参数，不能在
Filter1 中进行获取
（3） 配置全局参数，<context-param> 进行配置，通过 ServletContext 获得
（4）实验：得到 filter 配置信息
6、注册 Filter
<filter>
<filter-name>testFitler</filter-name>
<filter-class>org.test.TestFiter</filter-class>
<init-param>
<param-name>word_file</param-name>
<param-value>/WEB-INF/word.txt</param-value>
</init-param>
</filter>

<filter-mapping>
<filter-name>testFilter</filter-name>
<url-pattern>/test.jsp</url-pattern>
</filter-mapping>
<filter-mapping>
<filter-name>testFilter</filter-name>
<url-pattern>/index.jsp</url-pattern>
<dispatcher>REQUEST</dispatcher>
<dispatcher>FORWARD</dispatcher>
</filter-mapping>



登录相关
自动登陆 ：未登录、存在自动登陆信息、自动登陆信息正确
在用户完成登陆后，勾选自动登陆复选框，服务器端将用户名和密码 以 Cookie 形式，保
存在客户端 。当用户下次访问该站点，AutoLoginFilter 过滤器从 Cookie 中获取 自动登
陆信息
1、判断用户是否已经登陆，如果已经登陆，没有自动登陆的必要
2、判断 Cookie 中是否含有自动登陆信息 ，如果没有，无法完成自动登陆
3、使用 cookie 用户名和密码 完成自动登陆




权限
（5）使用 Filter 实现 URL 级别的权限认证
（1）情景：在实际开发中我们经常把一些执行敏感操作的 servlet 映射到一些特殊目录
中，并用 filter 把这些特殊目录保护起来，限制只能拥有相应访问权限的用户才能访问这些
目录下的资源。从而在我们系统中实现一种 URL 级别的权限功能。
要求：为使 Filter 具有通用性，Filter 保护的资源和相应的访问权限通过 filter 参数的形式予
以配置。
（2）系统中存在很多资源，将需要进行权限控制的资源，放入特殊路径中，编写过滤器
管理访问特殊路径的请求，如果没有相应身份和权限，控制无法访问
认证：who are you ? 用户身份的识别 ------------ 登陆功能
权限：以认证为基础 what can you do ? 您能做什么？ 必须先登陆，才有身份，有了身
份，才能确定可以执行哪些操作




包装类
ServletRequestWrapper 和 HttpServletRequestWrapper 提供对 request 对象进行包装的
方法，但是默认情况下每个方法都是调用原来 request 对象的方法，也就是说包装类并没有
对 request 进行增强
在这两个包装类基础上，继承 HttpServletRequestWrapper ，覆盖需要增强的方法即可
13、request 对象的增强
（1）Servlet API 中提供了一个 request 对象的 Decorator 设计模式的默认实现类
HttpServletRequestWrapper ， （HttpServletRequestWrapper 类实现了 request 接口中的所有
方法，但这些方法的内部实现都是仅仅调用了一下所包装的的 request 对象的对应方法）
以避免用户在对 request 对象进行增强时需要实现 request 接口中的所有方法。
（2）使用 Decorator 模式包装 request 对象，完全解决 get、post 请求方式下的乱码问题




DispatcherServlet 根据获得的 Handler，选择一个合
适的 HandlerAdapter。（附注：如果成功获得 HandlerAdapter 后，此
时将开始执行拦截器的 preHandler(...)方法）


@ResponseBody 代替了下面的代码
13.
14. // PrintWriterout = null;
15. // response.setContentType("application/json");
16. //
17. // try{
18. // out= response.getWriter();
19. // out.write(result);
20. // }catch (IOException e) {
21. // e.printStackTrace();
22. // }


3*0.1 == 0.3  false  精度问题
float f=3.4; 是否正确？3.4f
冒泡排序
获取月初末天，calendar和localdate都可以，是jdk8新增时间操作   localtime等

equals相等，hashcode必相等

基本数据类型字节大小  char 2    int 4  byte 1   double 8
String 是引用类型，不是基本类型

String s="a";  s=s+"v";  这里String是不可变的，只是指向了另一个string对象，原先的还在

重载（构造函数）和重写（类的覆盖）也是多态的体现，主要还是接口，静态方法无法重写
对象的三大特性，继承，多态，封装，抽象一般不提
权限修饰符范围
   protected 在同包内的类及包外的子类能访问
   默认不写在同包内能访问


switch不可作用在long,double,float,boolean，包括他们的包装类

get 和 post只是发送机制不同，并不是一个取一个发

请求转发是服务器行为，一次请求，地址不变，访问自身web资源，传输数据不会丢失
重定向是客户端行为，两次请求，浏览器地址变化，可访问自己web外的资源，传输数据会丢失


使用redis共享session，要与业务逻辑代码解耦，否则没有意义
redis是纯内存操作，异步入磁盘
一般是从使用持久化，主机器不要

单点登录的原理
后端生成一个sessionid设置到cookie中，供后面请求用，sessionid本质是获取用户信息数据。
除了cookie，通常 还是用http请求头来传输，这里需要手工处理下传输

跨域
js只能访问与包含它的文档在同一域下的内容
ajax不能向不同的域提交请求

jsonp原理(忽略)
动态添加一个<script>标签，使用该标签的src属性没有跨域的限制的特点实现跨域。
   首先在客户端注册一个callback，并将其名字传给服务器，服务器生成json数据，然后以js语法方式生成一个function，其名字就是传递上来的参数jsonp，最后将json数据直接以入参的方式放置到function，这样就生成一段js语法的文档，返回给客户端，客户端浏览器解析script标签，并执行返回给javascript文档，此时数据作为参数，传入到客户端预先定义好的callback函数里


aop 有两个，核心关注点（业务）和横切关注点（基本相似的处理）
切面将多个类的通用行为封装成可重用的模块

spring只支持方法类型的连接点，就是被拦截到的方法

2018-shiro忽略
控制级别
url级别，方法级别，代码级别，页面标签权限控制


按值传递特点，传递的是值的拷贝，传递后互不相关
按引用传递特点，传递的引用地址，就是变量对应的内存空间地址，传递前后指向同一个引用，

秒杀系统

rm -i 交互删除，给提示


java8
lambda只能引用final或final局部变量，不能在lambda内部修改定义在域外的变量





redis INCRBY 
INCRBY key increment  增加指定数字，increment可为负数，表示减少



tcp/ip的四层
1、主机到网络层
      网络接口层：对实际的网络媒体的管理，定义如何使用实际网络来传送数据。
2、网络互连层
      负责提供基本数据封包传送功能，让每一块数据包都能够到达目的主机(但不检查是否被正确接收)，如网际协议（IP）。
3、传输层
   在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP 和 UDP 给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。
4、应用层
      应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等



http 请求由三部分组成，分别是：请求行、消息报头、请求正文

请求行以一个方法符号开头，以空格分开，后面跟着请求的 URI 和协议的版本，格式
如下：
Method Request-URI HTTP-Version CRLF

其中 Method 表示请求方法；Request-URI 是一个统一资源标识符；HTTP-Version 表
示请求的 HTTP 协议版本；CRLF 表示回车和换行（除了作为结尾的 CRLF 外，不允许出
现单独的 CR 或 LF 字符）。

HTTP 请求报文由 3 部分组成（ 请求行+请求头+请求体 ）
HTTP 的响应报文也由三部分组成（ 响应行+响应头+响应体 ）


HTTP 响应也是由三个部分组成，分别是：状态行、消息报头、响应正文
1、状态行格式如下：
HTTP-Version Status-Code Reason-Phrase CRLF
其中，HTTP-Version 表示服务器 HTTP 协议的版本；Status-Code 表示服务器发回的
响应状态代码；Reason-Phrase 表示状态代码的文本描述。
状态代码有三位数字组成，第一个数字定义了响应的类别，


HTTP 消息报头包括普通报头、请求报头、响应报头、实体报头。
每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。

get是向服务器发索取数据的请求
post是向服务器提交数据的请求


为了解决 HTTP 协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议
HTTPS，为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书
来验证服务器的身份，并为浏览器和服务器之间的通信加密。


HTTP 协议
以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 Web 浏览器和网站
服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP 协议不适合传输一些敏
感信息，比如：信用卡号、密码等支付信息。


http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输
协议

HTTPS（Hypertext Transfer Protocol over Secure Socket Layer，基于 SSL
的 HTTP 协议）使用了 HTTP 协议，但 HTTPS 使用不同于 HTTP 协议的默认端口及一个
加密、身份验证层（HTTP 与 TCP 之间）。这个协议的最初研发由网景公司进行，提供了
身份验证与加密通信方法，现在它被广泛用于互联网上安全敏感的通信。
 客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。 （1）客户使用 https 的 URL 访问 Web 服务器，要求与 Web 服务器建立 SSL 连接。
（2）Web 服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份
给客户端。
（3）客户端的浏览器与 Web 服务器开始协商 SSL 连接的安全等级，也就是信息加密的
等级。
（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将
会话密钥加密，并传送给网站。
（5）Web 服务器利用自己的私钥解密出会话密钥。
（6）Web 服务器利用会话密钥加密与客户端之间的通信

这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙
和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个
锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到
被这把锁锁起来的东西。

这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等

客户端解析证书
这部分工作是有客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过
期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。
如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像
上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。
5、传送加密信息
这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户
端和服务端的通信就可以通过这个随机值来进行加密解密了。
6、服务段解密信息
服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行
对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，
不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私
钥够复杂，数据就够安全。
7、传输加密后的信息
这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。
8、客户端解密信息
客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过
程第三方即使监听到了数据，也束手无策。


、SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能
支撑这个消耗（SSL 有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作
系统支持，Windows XP 就不支持这个扩展，考虑到 XP 的装机量，这个特性几乎没用）。

如果站长在采用 HTTPS
协议后仍需制作个“http 可访问版”、或是通过 301 重定向“自动跳入 https 版本”，那
么，采用 HTTPS 协议的代价就不再只是多花 money 的问题了



SSL 的作用
（1）、认证用户和服务器，确保数据发送到正确的客户机和服务器；
（2）、加密数据以防止数据中途被窃取；
（3）、维护数据的完整性，确保数据在传输过程中不被改变。



SSL 证书申请的 3 个主要步骤
对于 SSL 证书的申请，主要有以下 3 个步骤：
（1）、制作 CSR 文件
所谓 CSR 就是由申请人制作的 Certificate Secure Request 证书请求文件，制作过程
中，系统会产生 2 个密钥，一个是公钥就是这个 CSR 文件；另外一个是私钥，存放在服务
器上。
要制作 CSR 文件，申请人可以参考 WEB SERVER 的文档，一般 APACHE 等，使用
OPENSSL 命令行来生成 KEY+CSR2 个文件，Tomcat，JBoss，Resin 等使用 KEYTOOL 来
生成 JKS 和 CSR 文件，IIS 通过向导建立一个挂起的请求和一个 CSR 文件。
（2）、CA 认证
将 CSR 提交给 CA，CA 一般有 2 种认证方式：
①、域名认证：一般通过对管理员邮箱认证的方式，这种方式认证速度快，但是签发的
证书中没有企业的名称。
②、企业文档认证：需要提供企业的营业执照，一般需要 3-5 个工作日。
也有需要同时认证以上 2 种方式的证书，叫 EV 证书，这种证书可以使 IE7 以上的浏览
器地址栏变成绿色，所以认证也最严格。
（3）、证书的安装
在收到 CA 的证书后，可以将证书部署上服务器，一般 APACHE 文件直接将 KEY+CER
复制到文件上，然后修改 HTTPD.CONF 文件；TOMCAT 等，需要将 CA 签发的证书 CER
文件导入 JKS 文件后，复制上服务器，然后修改 SERVER.XML；IIS 需要处理挂起的请求，
将 CER 文件导入



一个 HTTP 请求报文由请求行（request line）、请求头部（header）、空行
和请求数据 4 个部分组成，


1.GET 提交，请求的数据会附在 URL 之后（就是把数据放置在 HTTP 协议头＜requestline＞中）
2.POST 提交：把提交的数据放置在是 HTTP 包的包体＜request-body＞中。


• 这是请求报文的格式：
<method> <request-URL> <version>
<headers>
<entity-body>
• 这是响应报文的格式（注意，只有起始行的语法有所不同）：
<version> <status> <reason-phrase>
<headers>
<entity-body



抓包
来抓个包看看，做个试验：
1. 打开这个链接，去 cn.cocos2d-x.org 注册个账号；
2. 填好注册信息；
3. 打开 Wireshare 进行抓包；
4. 在注册页面，提交注册信息。
查看抓包信息并分析，以下是我抓到的包


forward:转发页面和转发到的页面可以共享 request 里面的数据.
redirect:不能共享数据


从运用地方来说
 forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
 redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等

forward 会将
request state ,bean 等等信息带往下一个 jsp。redirect 是送到 client 端后再
一次 request,所以资料不被保留


一般这个 cookie 的名字都是类似于 SEEESIONID。但 cookie 可以被人为的禁
止，则必须有其他机制以便在 cookie 被禁止时
仍然能够把 session id 传递回服务器。
经常被使用的一种技术叫做 URL 重写，就是把 session id 直接附加在 URL 路径的后面。
还有一种技术叫做表单隐藏字段。就是服务器
会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把 session id 传递回服务
器。












ddos攻击

tcp三次握手的规则,这些计算机会向源 IP 发出 SYN+ACK 或 RST 包来响应这个请求。同
Smurf 攻击一样,黑客所发送的请求包的源 IP 地址是被攻击主机的地址,这样受欺骗的主机
就都会把回应发到被攻击主机处,造成被攻击主机忙于处理这些回应而瘫痪



1。确保服务器的系统文件是最新的版本,并及时更新系
统补丁。

2。关闭不必要的服务。

3。限制同时打开的 SYN 半连接数目,缩短 SYN 半连接
的 time out 时间,限制 SYN/ICMP 流量

4. 正确设置防火墙，限定ip等

认真检查网络设备和主机/服务器系统的日志。只要
日志出现漏洞或是时间变更,那这台机器就可能遭到了攻击。
 6。限制在防火墙外与网络文件共享。这样会给黑客截取
系统文件的机会,主机的信息暴露给黑客,无疑是给了对方入
侵的机会。
 7。充分利用网络设备保护网络资源

  用足够的机器承受黑客攻击

  检查访问者的来源



   据悉，此次 DDoS 攻击流量为数十 G，当晚工
作人员一直在奋力抢修






######临时记录区域，防止冲突合并######



如果应用程序中直接使用 JDBC 来进行持久化，DataSourceTransactionManager 会为你处
理事务边界。为了使用 DataSourceTransactionManager，你需要使用如下的 XML 将其装配
到应用程序的上下文定义中：DataSourceTransactionManager 是通过调用 Java.sql.Connection 来管理事务，而
后者是通过 DataSource 获取到的。通过调用连接的 commit()方法来提交事务，同样，事
务失败则通过调用 rollback()方法进行回滚。



PlatformTransactionManager 通过
getTransaction(TransactionDefinition definition)方法来得到事务，这个方法里面的参数是
TransactionDefinition 类

使用 spring 声明式事务，spring 使用 AOP 来支持声明式事务，会根据事务属性，自动在
方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。