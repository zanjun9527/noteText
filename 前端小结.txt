平和心态，功利心会浮躁，慢避免以后返工，多实践

千万不要怼面试官

开发要放平心态，满就是快，避免返工

觉得写div复杂吗？  觉得复杂就检讨一下心情是不是浮躁了
嵌套就够不够，css写的会麻烦

前端文档   w3c  和mdn
目录  准备看	常规流练习


腾讯课堂html和css



问题记录
	line-height和height具体的尺寸图，区别

-------------------html-------------------  
	主要学的是元素

	html用来描述页面的结构（结构就是有哪些东西）
	二八原则，掌握常规的二，八作为扩展学习
	
	
	vscode集成了方便的emmet插件
		vscode的使用  f1:切换语言输入
		vscode-icons  
		live server  调试窗口，能够实时编译刷新
		！  直接生成标准的html文档结构  速度  /html:5 也可以
		
		Markdown Preview Enhanced   md文件增强预览

		注释键  ctrl+？
		
		
		alt+shift+f  格式化代码
		ctrl+d   	快速选中同标签
		ctrl+回车 	快速换行
		h1*6>{a}		直接6个标签就出来了,包含a内容
		lorem	乱数假文，随机生成的字符串，一般调试p段落排版用
	
	p.red.name			直接p中快捷样式
	p>{lorem3} 	<p>lorem3</p>
	p>lorem3  		<p>a b c</p>
	
	
	挺有意思的写法：
		ul*5>(li>h3>a>lorem)+(li*4>a>lorem3)
	
	***
	md:MarkDown,MD，文档格式标准，仅关注内容本身，不关注格式。这个挺好用的。效率还可以
	
	w3c,为互联网提供各种标准
	mdn：https://developer.mozilla.org/zh-CN/    web文档
	
	浏览器的组成：1.shell：外壳  2.core：内核（js执行引擎、渲染引擎）  
	常见的具备内核的浏览器：ie，firfox，chrome，safari，opera
	微信中页面显示是因为微信中安装了内核插件
	
	
	版本和兼容性，后面特殊处理
	
	<!-- 注释内容 -->
	
	html的基础单位，元素(就是常用的标签)，元素中由元素属性
	
	**
	空元素没有结束标记，比如<img>,<meta>
	 <meta charset="UTF-8">或者 <meta charset="UTF-8"/>，现在可以不写
	 
	 元素可以嵌套，但是不能相互嵌套
	 拥有同一父元素的叫做兄弟元素
	
	文档格式
		<!DOCTYPE html> 是文档的申明，h5标准
		<html> 是根元素
		<head>文档头,内部内容不会显示到页面
			<meta>文档的元数据，网页附加信息
			<body>文档体，所有要显示的都要放在文档体中
			
	*****所有元素与展示效果无关*****  语义化
		语义化，每个标签都有含义，但是显示只和css有关，元素本身和展示效果无关，元素有默认的css样式
		
		问题,想做一个空行需要p元素？，这种想法不对，应该是css决定的
		
		*****
		重要理论：选择什么元素，取决于内容的含义，而不是显示出的效果。
		
		更具内容选标签，样式交给css
		
		****
			h1是语义化，真正的大小是css赋值的
		****
	css必须要依赖元素
	
		HTML5元素周期表
		独占一行是块级元素，其他是行级元素
		元素具有语义化，没有显示效果
		块级元素，独占一行
		行级元素，不独占一行
		h5已经弃用这种说法
		
		
		
		浏览器调试页面，选中元素，然后在element.style中添加修改样式测试
		
		空白折叠，源代码中连续的空白字符，在显示的时候会折叠成一个空格
			常见文本元素
				<span> 	无语义 	仅用于设置样式
				<pre > 	 	预格式化文本元素  不会出现空表折叠，源代码展示。保持格式一致。通常用于在网页中显示代码
				<code>		代码区域，需要显示的
			
			
			html实体字符(HTML Entity)：实际上就是转义字符
				<对应的是&lt;	>对应的是&gt; 空格对应&nbsp; &对应 &amp;等等
			
			
			<a>标签
				1.普通链接		跳转普通地址
				2.锚链接		href="#id"	如果是当前页面，不会刷新;如果是其他页面页面会刷新    href="#"会跳到页头，这#相当于定位页面某个位置
				3.功能链接		比如js---javascript:等
				
				
				其中包含的任何元素都会跳转链接
				
			路径写法：
				站内资源(用相对路径)和站外资源(绝对路径)
				绝对路径和相对路径
				绝对地址：协议名://主机名:端口号/路径		
					当跳转目标和当前页面的协议相同时，可以省略协议，(当站内资源的时候，也可以相同的省略,个人小结)
					
				相对路径  以./开头，这个是可以省略的
					以./开头，表示当前资源所在目录,../表示上级目录
			
			
				图片：<img>	空元素	属性：src；alt  图片资源失效，文字替代
					和<a>元素联用，整个图片跳转链接
					和<map name="cityMap">元素连用，<img usermap="cityMap">实现局部跳转链接，map的子元素area实现定位
					和<figure>连用，包裹图片相关，不常用
					
				多媒体元素
				是h5新元素
					video	默认支持MP4,webm。
						src
						controls:控件显示,布尔属性(可以不写属性值)
						autoplay:自动播放
						muted:静音播放
						loop:循环播放
						
						子元素：source，提供给资源列表
						
					audio 和video完全一致
					
				列表元素
					有序列表 	ol,li,ol中的type设定排序取值方式
					无序列表	ul,li
					定义列表	dl,dt/dd						常用于术语的定义  不常用
				
				容器元素
				划分区域，从大到小，一块一块制作  慢慢写 不要急，(基本全都看作一个个div操作，但是也不要过分细)
					代表一块区域，用于放置其他元素，从大到小，步步精细，每个区域都要一个div划分
					div元素		没有语义，先看大盒子，然后划分小盒子，先不看样式，找不到合适的语义可以使用div
					语义化容器元素  h5新增
						header		页头/文章头
						footer		页脚/文章尾部
						article		整个文章
						section		文章的章节
						aside		附加信息，侧边栏
						nav			导航 				和ul>li类似，只能用于导航
						
						
			元素的包含关系
				mdn文档中查看包含内容，不需要背，记住常用的
			 
				以前：块级元素可以包含行级元素，反之不行，<a>除外
				
				元素的包含关系由元素的内容类别决定。
				
				1.容器元素中可以包含任何元素
				2.a元素中几乎可以包含任何元素
				3.某些元素有固定的子元素(ul>li，ol>li)
				4.标题元素和段落元素不能相互嵌套，并且不能包含容器元素
				
					  <ul>
						<a href=""><li>2</li></a>
					</ul>
					
					li>ul  li中是可以继续包含ul的。列表包含列表
				像这种写法就是不规范的，ul下面固定是li
				
-------------------css记录-------------------
			主要学的是声明，样式规则

				******
					css规则=选择器+声明块
				******
				
					选择器：选中元素				选择器选中元素
						1.元素选择器 2.类选择器(最常用) 3.id选择器
						
					声明块
						包含很多(声明)属性，即样式
					  <p class="big red">Lorem, ipsum dolor.</p>     多个样式空格分隔
					  
				css代码位置
					1.内部样式表，				书写在style元素中，放head中(希望最先加载)
					2.元素样式表(内联样式表)	写在元素的style属性上
					3.外部样式表				独立写在css文件中			<link rel="stylesheet" href="./css/index.css"> 引入		
					
					外部样式表的好处
						1.推荐使用，便于多页面公用维护
						2.有利于浏览器缓存，提高页面响应速度
						3.有利于代码分离
						
				常见样式声明：元素内部文字尺寸大小
				
				预设值,都是单词写好的，比如red,bold
					color：	字体颜色
						1.预设值，red等
						2.光学三元色(红,绿,蓝,每个颜色0-255)		rgb(r,g,b)
						3.hex表示法		16进制表示      			#红绿蓝		#008c8c      #ff4400->#f40  
						
					font-size;	
						1.px:像素绝对单位		简单理解文文字高度占多少像素，
						2.em:相对单位			相对于父元素的字体大小 最终都会换算成px值 	
							没有字体大小会默认继承父元素字体大小(html默认是16px，基准字号，浏览器设置的字号)，一层一层往上找
							每个问题都必须要有字体大小
							
						user agent，ua 用户代理，说白了就是浏览器
						
						<stong> 默认加粗
						
					fong-weight:文字粗细		预设值：normal，bold
					
					font_family:文字类型		宋体等	可设置多字体备用  sans-serif，非衬线字体
						
					font-style:字体样式，		常用来设置斜体
						<i>,<em>元素，默认斜体			<i>常用来表示一个图标
					
					text-decoratioin：	给文本加线，下划线等
						a:-webkit-any-link	any-link指的是超链接，前边的-webkit-是谷歌浏览器的前缀	Webkit枘核浏览器，如chrome and safari
						<del>表示错误的内容，就是中划线
						<s>表示过期的内容
						
					text-indent:段落首行缩进
					
					line-height：行高，每行文本的高度，该值越大，每行文本的距离越大。
						设置行高为容器的高度，可让单行文本垂直居中
						行高设置为纯数字，相对于当前元素的字体大小
						
						
						一个是元素本身，一个是两个行间隔
						其中height是指标签块的高度；元素高度
						而line-height是指元素的行高，形容的是两个元素之间的距离，line-height包括元素高度和空白的高度。
						
					width，height：宽高，元素的宽高
					
					letter-spacing；文字间隔
					
					text-align：元素内部文字的水平排列方式  
				
				选择器
					通配符选择器
						*，选中所有元素
						
					属性选择器
						[href]/[href="aaa"]		选中所有具有href属性的元素
					
					伪类选择器  
						选中某些元素的某种状态
						hover			鼠标悬停状态					a:hover{} 悬停在a标签上的操作
						active			激活状态，鼠标按下状态			a:active{}
						link/visited：	超链接未访问/访问后状态
						
						需要按照link-visited-hover-active顺序写		按照语义化也好理解
						
					伪元素选择器（默认是行盒）
						before(after)			相当于加了个子元素before			
						<span>书名</span>		span::before{content:"《"} <span>《书名</span>
							
							
					选择器的组合
						1.并且					不加任何东西，选择器直接放一起					p.red{}
						***
						2.后代元素-空格			选中元素的后代元素(不是子元素)					div.red li{}    #id a{}
						***
						3.子元素- >				只能选择子元素									.red>li{}
						4.相邻兄弟元素- +		某个元素的下一个元素							.red+li{}
						5.兄弟元素- ~			选中某个选择的后面所有兄弟元素					.red~li{}
						
					选择器的并列
						多个选择器，逗号分隔
						
		*****层叠*****
					生命冲突，同一个样式，多次应用到同一个元素。是样式选择元素
					
					层叠；解决声明冲突，浏览器自动处理(权重计算)
					
						1.比较重要性 (基本不用考虑)
							1)作者样式表(开发者书写的样式)中的!important样式
							2)作者样式表中的普通样式
							3)浏览器默认样式表
							
						2.比较特殊性(这个比较重要)
							总体规则：看选择器，选择器选中的范围越窄，越特殊
							具体规则：通过选择器，计算一个4位数(xxxx)权重 (只要比出一个位数，就可以了)
										1.千位，内联样式计1，否则0		  内联样式(可不写选择器)占最高
										2.百位，选择器中所有id选择器中的数量
										3.十位，选择器中所有类选择器，属性选择器，伪类选择器的数量
										4.个位，选择器中所有元素选择器、伪元素选择器的数量
						
							覆盖样式：写一个样式，特殊性超过原样式，就可以覆盖了，一般不要改别人的样式代码，层叠覆盖就行
								使用场景：搞活的时候，加一个新样式文件，覆盖原样式即可，特殊性覆盖的方法
								
						3.比较源次序
							代码书写靠后的胜出
						
					应用
						1.重置样式表
							书写作者样式，覆盖浏览器的默认样式  常见的重置样式表   reset.css等
								
						2.爱恨法则，a链接   link>visited>hover>active
						
			继承
				简写属性，font  批量设置属性
				
				子元素会继承父元素的某些css属性，后代也会收到影响
				
				通常和文字内容相关属性都能被继承
				
	******属性值的计算过程(一个元素从所有属性没值，到所有属性都有值)******
			
				一个元素一个元素依次渲染，顺序按照页面文档的树形目录结构进行
			
				树形目录：html	-	head	->meta，title
								-	body	->h3,p(strong),a,img
								
				渲染每个元素的前提条件：该元素的所有css属性必须有值，最终没有的会有默认值
				
				
				*********
				 无属性值--->1.确定声明值--->2.层叠冲突--->3.使用继承--->4.使用默认值--->每个属性都有值
				 
				 
				声明值：开发者样式或者浏览器默认样式
				 
				 1.确定声明值：参考样式表中没有冲突的声明，直接作为css属性
				 2.层叠冲突：对样式表中有冲突的声明层叠规则，确定css属性值
				 3.使用继承：对仍然没有值的属性，若可以继承，则继承父元素的值
				 4.对于仍然没有值的属性，使用默认值
				 
				 
				*********
				
				案例：<div><a></div>,对div设置颜色， a元素颜色不变。在第一步就有声明值了
				
				
				使用场景，可以用来reset一些常用的元素样式
				
				inherit  强制继承，将继承提前。
				
				特殊的两个css取值
					1.inherit：强制继承
					2.initial：初始值，将该属性设置为默认值
					
					
		*****盒模型*****
				每个元素在页面都会生成一个盒子区域，  盒子是css的概念
				
				盒子类型
					1.行盒，display=inline		不换行
					2.块盒，display=block		独占一行
					
					display默认为inline。
					
					浏览器默认样式设置的块盒：div，header，p等
					常见的行盒：span，a,img
					
				盒子的组成部分，行盒和块盒都有
				
					1.内容 				content
							涉及属性：weight,height 设置的是盒子内容的宽高
							
							内容部分通常叫做盒子的内容盒，content-box
								
					2.填充(内边距)		padding
							盒子边框到盒子内容的距离
							通过padding设置，padding是简写属性。  padding ： 上	右	下	左
						
						填充区+内容区=填充盒，padding-box
					3.边框				border
					
						边框=边框样式+边框宽度+边框颜色
						border 也是速写属性
						
						边框+填充区+内容区=边框盒，border-box
						
					4.外边距			margin
						
							边框到其他盒子的距离
							
							margin速写属性
					
			盒模型的应用
					1.改变宽高范围
						默认情况下。width和height设置的是内容盒宽高。但是设计的时候往往是边框盒
							1.精确计算，计算好精确数值
							2.css3：box-sizing,指定是边框盒尺寸，现在用这个多点
							
					2.改变背景覆盖范围
						默认情况下，背景覆盖边框盒，可以通过background-clip进行修改，不包括margin
						
					3.溢出处理
						overflow，控制内容溢出边框盒后的处理方式
						
					4.断词规则
						word-break,会影响文字在什么位置被截断换行
						
						normal：cjk字符，文字阶段，非cjk，单词位置截断		默认
						break-all，截断所有，所有字符都在文字处截断
						keep-all，保持所有，所有文字都在单词之间截断
						
					5.空白处理
					
					单行文本文字省略号处理
						wihte-space:nowrap,空白位置处理时不换行
						overflow：hidden
						text-overflow：ellipsis
					
			行盒的盒模型
					常见的行盒：包含具体内容的元素		span，img，em等
					特点：
						1.盒子沿着内容延伸	
						2.行盒不能设置宽高		
						3.内边距			水平方向有效，垂直方向仅影响背景，不会实际占据空间
						4.边框				同内边距
						5.外边距			同上
						
						
					调整行盒的宽高，通过字体大小、行高、字体类型间接调整
				
				行块盒
					display：inline-block
						1.不独占一行，2.盒模型中所有尺寸都有效
					
					使用场景：常用来做分页
					
				空白折叠：发生在行盒内部或行盒(包含行块盒)之间
				
				可替换元素和非可替换元素
					非可替换元素：大部分元素，页面上显示的结果，取决于元素内容
					可替换元素：页面显示结果取决于元素属性。	img  video		类似行块盒
					
					img 中的object-fit  是图片显示属性，保持比例等
					
					
		*******常规流*******属性计算，盒模型 是三大部分
				盒模型：规定单个盒子的规则
				视觉格式化模型(布局规则)：页面中的多个盒子排列规则
				
			******大体上排列三种规则(浮动和定位)******
				***1.常规流 (也叫文档流等)
						所有元素，默认情况下，都属于常规流布局
						*****总体规则：块盒独占一行，行盒水平一次排列*****
						
						包含块(containing block):每个盒子都有包含块。决定了盒子的排列区域
						绝大部分情况下，盒子的包含块是其父元素的内容盒(不包含padding)
					
				
						块盒
							1.每个块盒的总宽度，必须刚好等于包含块的宽度
								宽度的默认值是auto，将剩余空间吸收掉。
								margin取值也可以取值auto，默认是0。
								width吸收能力强于margin
				
								计算完之后，最后的剩余空间被margin-right吸收
								常规流块盒居中，盒子定宽，margin-right  和 margin-right   都为auto，就水平居中了
				
							2.每个块盒垂直方向上的auto值
								height：auto     适应内容的高度
								margin:auto			表示0
								
							3.百分比取值
								******
									padding,宽，margin可以取值百分比,以上所有百分比是相对于包含块的宽度
								******
									
									
									包含块高度是否取决于子元素的高度，设置百分比无效
									...不取决于子元素的高度，自定义，百分比有效
									
							外边距合并，两个常规流块盒，上下外边距相邻，会进行合并，两个外边距取最大
							但是中间隔东西就合并不了
							
				***2.浮动元素
						应用场景：	
							1.文字环绕
							2.横向排列
					
						基本特点：display会强制变为block，块盒
							1.修改float属性：	left(左浮动，元素靠上靠左)  right(右浮动，元素靠上靠右)  默认是none
							2.浮动元素的包含快和常规流一样，是父元素的内容盒
						
						浮动盒子尺寸：1.宽度为auto，适应内容宽度，没有内容就是0，不会像常规流一样吸收尺寸，默认0
									  2.高度为auto，和常规流一致，适应内容宽度
									  3.margin 为auto时，为0，其他值是生效的
									  4.边框，内边距，百分比设置和常规流一致（相对于包含块的宽度，高度特殊点）
	
	
						浮动盒子排列
							1.左浮动，元素靠上靠左
							2.右浮动，元素靠上靠右
							3.在包含块中排列时会避开常规流，反之常规流块盒，无视浮动盒子
							5.行盒在排列时会避开浮动盒子(这个就是环绕的原理，块盒会默认添加行盒)
								如果文字没有在行盒中，浏览器直接生成了一个行盒包裹文字(匿名行盒)，比如div中的文字
								环绕间隔 设置float元素的margin，因为是围绕float，
							6.外边距合并不会发生
	
					******高度坍塌******
						根本原因：常规流盒子的自动高度，计算时无视浮动盒子
						解决方式：清除浮动：clear(left，right),必须出现在之前所有(左/右)浮动盒子的下方，排列时参考浮动盒子
									1.最后加空div，clear样式，不方便,
									2.使用伪元素，：after	，谁高度坍塌就加在哪
										.clearfix::after{
											content:"";
											display:block;  默认是行盒
											clear:both；
										}
									添加常规流盒子，撑开父div
						
			******定位******
				position：	默认static,静态定位(不定位)，不是static，就是一个定位元素
							relative:相对定位
							absolute:绝对定位
							fixed：固定定位
							
				定位元素会脱离文档流(相对定位除外)
				脱离文档流的元素:
					1.文档流中得元素摆放时，会忽略脱离了文档流得元素
					2.文档流中元素计算自动高度时，会忽略脱离了文档流得元素

					相对定位：
						不会导致元素脱离文档流，只是让元素在原来位置上进行偏移，(盒子偏移不会对其他盒子造成任何影响)
						通过left,right,top,bottom偏移
						
					绝对定位：
						1.宽高为auto，适应内容
						2.包含块变化：找祖先元素的第一个定位元素，该元素的填充盒为其包含快(找不到就是整个网页，初始化包含块)
						3.
						
						场景：将一个元素设置relative，这样子元素可以使用绝对定位达到相对的效果。
						给决定定位元素提供包含块
						
					固定定位：其他情况和绝对定位完全一致
						包含块不同：固定为视口(浏览器的可视窗口)，浏览器尺寸大于视口就出现滚动条
						
				定位下的居中
					1.定宽高 2.将四个方向距离设为0  3.将四个方向的margin设为auto           因为margin也是占据盒子空间的
					绝对定位和固定定位中，margin为atuo，会自动吸收剩余空间
					
				多个定位元素重叠时：
					设置z-index,通常情况下，值越大，越靠近用户。
					只有定位元素设置z-index有效，可为负数(遇到常规流和浮动会被覆盖)
				补充：
					绝对、固定定位元素一定是块盒，一定不是浮动，没有外边距合并
					