【现在还不是停止奋斗的时候】


1、	<context:property-placeholder location="classpath:jdbc.properties"/>数据源的配置，	相应的配置文件读取即可。
2、	 <context:component-scan base-package="com.test.blog"/>注解的扫描，无需手动配置bean
3、	solr已键值对形式存储内容

4、	linux语言

	chmod +x *.sh 这个命令是为sh文件增加可执行权限；
	rm -rf * 强制递归删除
	yum -y install 包名（支持*） ：自动选择y，全自动
	yum install 包名（支持*） ：手动选择y or n
	ll是会显示当前目录下的文档详细信息（包括权限、所属用户和组、大小、时间、名称等），		是ls -l的缩写；ls只显示当前目录下的文档名。
	tar zxvf zhcon-0.2.5.tar.gz
	z代表gzip的压缩包；x代表解压；v代表显示过程信息；f代表后面接的是文件
	linux 下  make 编译  make install 安装 make uninstall卸载
	cp 文件 文件路径   复制文件
	cp -r 文件夹 路径  复制文件夹内容到指定路径下

	vim linux下的文本编辑器  进入后，按/，然后输入字符串，回车，按N或者n是向前向后搜索字符串    
	如果在命令行下使用vim，先按下ESC退出编辑模式，然后输入：wq 保存并退	出或者q退出或者q!强制退出，从而回到命令行界面。
	ll *.rb 查找当前文件夹下的rb文件
	mkdir 目录名    创建一个目录
	chmod +x 文件  给出文件的可执行权限
	ps | grep 和 ps aux | grep  显示运行中/所用状态的进程
	
5、	redis 前端启动模式 usr/local/redis/redis-server 默认6379端口
	      后端启动模式 从redis的源码目录中复制redis.config到安装目录，在修改配置文件	daemonize yes后，启动./redis-server redis.config

	关闭指定端口的redis，redis01/redis-cli -p 8080 shutdown

6、	redis集群分布式节点一般一主一备，当任意master挂了没有备份或半数以上的master挂了则集群不可用
	redis的两种持久化方案：1、snapshotting 快照  2、Append-only file  保存命令行形式
	持久化机制 
	redis是一个支持持久化的内存数据库
	snapshotting快照方式，默认的存储方式，默认写入dump.rdb的二进制文件中，可以配置redis在n秒内如果超过m个key被修改过就自动做快照
	append-only file aof方式，使用aof时候redis会将每一次的函数都追加到文件中，当redis重启时会重新执行文件中的保存的写命
	令在内存中。

7、	jedis客户端  单个jedis、jedispool和jediscluster
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	RegisterDAO registerDAO = (RegisterDAO)ac.getBean("RegisterDAO");

	如果是两个以上:
	ApplicationContext ac = new ClassPathXmlApplicationContext(new String[]{"applicationContext.xml","dao.xml"});

	或者用通配符:
	ApplicationContext ac = new ClassPathXmlApplicationContext("classpath:/*.xml");
8、  	缓存要不影响正常程序的运行，先缓存后数据库,

9、   	sso实现单点登录
	spring框架中的digestutils工具类自带md5加密方法.md5DigestAsHex(byte[] bytes)

10、	跨域：不同域名，相同域名但是不同端口
11、	自增 1、uuid 2、redis.incr 3、date+random 4、mysql自增
12、	request.getRequestURL()+"?" + request.getQueryString() 获取请求路径

13、	new dateTime().plus(3).toString("yyyy-mm-dd");当前时间加3天输出

14	springboot工程搭建继承springboot 的parent
	<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-parent -->
  	<dependency>
  	 	<groupId>org.springframework.boot</groupId>
    		<artifactId>spring-boot-starter-parent</artifactId>
    		<version>1.5.3.RELEASE</version>
  	</dependency>
	pom库直接依赖实现pom依赖

15、	invalid LOC header (bad signature) 删除maven库中的文件，重新update即可

16、	创建web后右键propertie后的可以指定deploy的路径，test webcontent一般都删掉，一般指		定src main 下的webapp，这样与deployed resources目录就一致了
17、	classes删除，启动无法加载类，右键build path 重新添加代码路径即可
18、	nginx中的config文件中一个server就是一个虚拟主机
	nginx配置以下三种方式：
	1）、ip
	2）、端口
	3)、域名 		这个是最常用的
	一个域名只能绑定一个ip，一个ip可以被多个域名绑定
	通常ip地址是和dns服务器（根据域名换ip地址）绑定一起的，
	ping www.baidu.com 拿到百度的IP地址
	
	www.baidu.com-->dns服务器---->取得对应的ip地址---->访问百度的服务器,默认的是80端口
	在host文件中，如果配置了ip对应的域名，就会跳过dns解析，进行访问
	一般大公司是可以输入ip地址访问的，但是一些小公司可能运行在同一ip的不同虚拟机上，还		是要域名访问才能精确定位。
	反向代理决定哪个服务器提供服务，最简单的比如轮询，nginx只做请求的的转发给服务器，

19、	在interceptor中取到的信息可以放进request中，再传递到controller中	   			request.setAttribute(a,b)

20.	nginx
	客户端均衡--->nginx--->tomcat 请求经过nginx转发，由tomcat处理，这样叫反向代理，多	台tomcat就叫做负载均衡（仅对httpserver如tomcat有效）

	nginx配置负载均衡：http节点下，添加upstream节点。
		upstream linuxidc { 
     		 server 10.0.6.108:7080; 
      		 server 10.0.0.85:8980; 
		}
  		2.  将server节点下的location节点中的proxy_pass配置为：http:// + upstream名			称，即“http://linuxidc”.默认的分配策略是轮询，其他暂不研究


	高可用：解决高可用的方案就是：添加冗余（备用一主一备）一般用keepalived(集群管理中实现高可用，防止单点故障),不断检查主nginx是否正常，异常就启用备用nginx，主正常，在切换回去。

21、	solr集群 
	在tomcat中需要注册zookeeperr，solrj使用CloudSolrServer参数为zookeeper的ip和port,



	zookeeper	分布式开源、服务协调服务
	主要用处	1、配置管理 2 、集群管理
	可以单击可以集群 集群比单击版多三个参数 initLimit=5 
 						syncLimit=2 
 						server.1=192.168.211.1:2888:3888 
 						server.2=192.168.211.2:2888:3888
	集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下对应上述的server.id
	

	初始三个参数为				tickTime=2000 
 						dataDir=D:/devtools/zookeeper-3.2.2/build 
 						clientPort=2181

22、	./当前目录 ../上级目录 /根路径

23、	springboot启动类的@ComponentScan一定要包括config包
	启动一定要扫描到mapper

24、	域名的分配 
	一级域名	taotao.com
	二级域名	www.taotao.com
	

25、tomcat的热部署
	1)、在tomcat-user.xml中增加配置
	<role rolename="manager-gui"/>
	<role rolename="manager-script"/>
	<user username="tomcat"  password="tomcat" roles="manager-gui,manager-script"/>

	（这样就可以登录tomcat管理者页面，在war file to deploy 进行手工热部署）

	2）、使用maven的tomcat插件实现热部署（打包-上传-热部署）
	修改项目的pom.xml文件,在<build> 节点下面增加如下配置:tomcat7的配置

	<build>
		<plugins>
			<!-- 配置Tomcat插件 -->
			<plugin>
				<groupId>org.apache.tomcat.maven</groupId>
				<artifactId>tomcat7-maven-plugin</artifactId>
				<configuration>
					<port>8081</port>
					<path>/</path>
					<url>http://192.168.25.136:8080/manager/text</url> 	//maven中tomcat7插件的默认热部署路径
					<username>tomcat</username>			   	//tomcat中配置的权限用户
					<password>tomcat</password>				
				</configuration>		
			</plugin>
		</plugins>
	</build>
	
	2)-2 run as maven install 	初次部署可以使用 "clean package tomcat7:deploy" 命令
					如果已经部署过使用 "clean package tomcat7:redeploy" 命令

					部署跳过测试：
					clean package tomcat7:redeploy -DskipTests

	




26、	run as maven build.
	测试	goals 输入 clean test

	打包	goals 输入 clean package

	打包并发送到本地仓库	goals 输入 clean install

27、	<dependency>  
            <groupId>org.myorg.myapp</groupId>  
            <artifactId>app-util</artifactId>  
            <version>${project.version}</version>  
        </dependency>  
	其中${project.version} 是一个属性引用，指向了POM的project/version的值，也就是这个POM对应的version。由于app-dao的version继承于app-parent，因此它的值就是1.0-SNAPSHOT


28、	将jquery的相关js引入到classpath下的js文件夹下，再在页面引入<script  src="js/jquery-1.8.3.min.js">，即可使用。
			最简洁的ajax使用
 			$.ajax({
		             type: "post",
		             url: "http://192.168.1.102:8081/addTalents",
		             data: {"a":"nihao"},
		             dataType: "json",
		             success: function(data){} 
		        	});
		        	
		        	
29、	ajax和js是不允许跨域请求的


30、	单点登录的主要实现方案：
							1、服务接口的开发
							2、在分布式环境中使用redis实现session共享（缓存唯一token和对应的用户信息）
							3、使用cookie在多个系统中共享。（存放token信息）
							4、拦截器的使用方法（访问校验cookie中的token是否存在或过期）
							
31、网站并发数量在1000-2000级别的，用户数量一般在百万级别
32、	redis 127.0.0.1:6379> TTL KEY_NAME 			Redis TTL 命令以秒为单位返回 key 的剩余过期时间。
33、	redis是单线程，不会设计多个线程并发的问题

34、springmvc
基本类容：
需要掌握东西：前端控制器 、处理器映射器（注解和非注解）、处理器适配器、视图解析器
springmvc注解的开发：
	1）、常用注解
	2）、参数绑定（简单类型，pojo，集合类型）
	3）、自定义参数绑定

mvc 模型视图控制器 在一次request请求的生命周期 request--->c(控制器controller)--->m模型处理（dao，service）--->返回c--->v（view）视图渲染

springmvc request--->前端控制器（dispatcherservlet接受请求和响应结果相当于转发器）--->处理器映射器（handlerMappering 根据url匹配相应的handler）--->返回一个执行链（handlerExecution包含interceptor和handler：handler处理器（平时controller），不同的handler由不同的处理器适配器(handlerAdapter：按特定规则执行handler)调用执行）--->返回modelandview到适配器再到前端控制器--->由视图解析器返回view（是个接口，支持不同的view类型）进行视图渲染

handler是需要开发的，view中的jsp也是
handler是需要实现controller接口的处理




搭建springmvc
1、在web.xml中配置前端控制器
1）、配置dispatcherServlet的url-pattern有三种方式：1、*.action 2、/ 3、/* 这种不对，当转发到一个jsp页面时，仍然会由dispatcherServlet解析jsp,不找到handler
2）、dispatcherServlet中的init-param需要指定contextconfiguration和springmvc.xml（配置handleradapter和handlerMappering等 ），默认是加载/WEB-INF/servlet名称―servlet.xml

2、在spring.xml配置handlerAdapter，所有适配器都实现这个接口，（simpleControllerHandlerAdapter，handler实现controller接口，相当于@controller，多种适配器可选）,handlerMappering所有映射器都实现这个接口，（beanNameUrlHandlermapping和simpleurlhandlermapping非注解）和视图解析器，这个是在xml中配置，配置相应的handlerbean，加入spring容器，实现路径和类的匹配，不过现在过时了，现在用的是@requestMapping
非注解，有多种handlerAapter和handlerMapping可选，还是比较麻烦的，不如用注解

spring.xml中不部配置映射器和适配器，是默认加载dispatcherServlet.properties中配置

配置注解的映射器和适配器（怎么处理这个handler，是mv还是request）：
<mvc:annotation-driven></mvc:annotation-driven>  使用这个可以代替xml中配置映射器和适配器。
annotation-driven 默认绑定了很多参数绑定方法，代替了requesrMappingHandlerMapping和requesrMappingHandlerAdapter
返回的mv是一个map，将其填充到request域中，前端页面可取值
 



@requestMapping实现方法和url的映射。、
@Controller注解，即表示改类是Handler处理器。

对标记@controller类中标记@requestMapping的方法进行映射，映射相应的url，注解版，无需再xml中配置url和handler的映射关系 

注解的处理器适配器;和注解的映射器配对使用，



使用mvc注解驱动，<context:componet-scan base-package=""></context:componet-scan>指定controller，添加进入容器

3、视图解析器，xml中配置相应的bean即可。

modelAndView的addObject（）相当于request的setAttribute方法，在jsp中取数据

springmvc和mybatis的整合：
框架层次：表现层（springmvc），业务层（spring）、持久层（mybatis）
spring将各层进整合，通过spring
管理持久层的mapper接口，通过spring管理业务层的service，通过spring管理表现层的handler

1、整合dao层：mybatis和spring整合，mapperscanner扫描
2、整合service：管理service接口，配置或标签，实现事务控制
3、整合springmvc：是spring的模，无需整合

简约版配置：
整合mybatis
1)、配置mybatis的mybatis.xml中只需要配置分页插件
2)、spring-mybatis.xml主要将dao整合到spring中，主要是将sqlsessionfactory（包含mybatis.xml和datasource）注入容器中,再将mapper扫描注入容器（实现@autowire注入）

整合spring
配置spring的事务管理：
1）、事务管理器，spring-jdbc
2）、通知<tx:advice></txadvice>
3)、<aop:config></aop:config>
 
整合springmvc
1）、组件扫描<context:componet-scan base-packge=""></context:componet-scan>扫描controller
2）、mvc注解驱动，<mvc:annotation-driven></mvc:annotation-driven>
3)、视图解析器


在web.xml中通过contextLoaderListener监听器，将各个xml整合文件加入spring容器，参数为						<context-param>
							<param-name></param-name>	
							<param-value></param-value>
						</context-param>





controller的三种返回对象：1、modelandview 2、string（需要形参model） 3、void

redirect 无法共享request return "redirect:queryItem.action" 重定向路径，同级类省略类根路径，地址栏改变
	response.sendirect("url")
	

forward 地址栏不变，共享request return "forward:queryItem.action"
	request.getRequestDipatcher("path").forward(request,response)



解决post乱码：在web.xml中配置字符集过滤
解决个体乱码：1、tomcat中     <Connector URLEncoding="utf-8" port="8080" 		protocol="HTTP/1.1"  connectionTimeout="20000" redirectPort="8443" />
	      2、new String(request.getParammeter("a").getBytes("ISO8859-1"),"utf-8")




高级内容： 

参数绑定:处理器适配器调用springmvc的参数绑定组件（converter）获取形参，执行controller
简单传入：
	1）、简单类型 @requestparam（value，required，defaultvalue） 不使用则  request传入的名称和controller的形参名需一致
	2）、pojo类型
		2I）、不使用标签，页面的name属性和形参pojo的属性name一致，使用的话应该是@modelattribute
	3）、自定义类型 pojo有日期类型，converter<T1,T2>由string转为date，需要自定义，在mvc注解驱动中增加comversion-service="beanid"，目的是在springmvc的绑定组件中注入自定义的转换类。

高级绑定：
	pojo： 传入pojo中的pojo属性：页面中name="userInfo.name"
	数组：页面中共用相同的name值即可，name="userId"，传到后台就是 Integer[] userIds
	list: userInfo中有个List<pojo> pojoList，页面name="pojoList[index].name"
	map:页面中name="userInfo['name']" -----key-value
校验：
主要是后端的服务端校验-validation校验框架，springmvc的校验框架（引入hibernate-validator-4.3.0final.jar,jboss-loggging-3.1.0.CR2.jar,validation-api-1.0.0.GA.jar）
validator需要注入适配器（配置校验器bean和返回bean，这里使用的是返回properties，个人认为是加入容器，快速读取，{}读取即可），通过mvc注解驱动注入，validator="beanname"
在形参校验的bean前加@validated 其后需要跟着BindingResult bindingResult，有一个pojo校验就需要跟一个bindingResult,形参顺序一前一后，在对bindingResult进行判断即可。
多个controller共用一个校验pojo时，pojo中可以指定校验分组，group属性group={validate1.class},校验分组是一个空接口，形参中指定@validated（validate1.class）即可


数据回显：
	使用@modelattribute回显数据，简单点的使用model回显

异常处理：
springmvc提供了全局异常处理器进行统一异常处理（唯一），是抛到前端控制器交给统一异常处理器处理  
	预期异常：
	runtimeException：

定义异常处理器，需要实现handlerExceptionResolver接口，并需要在springmvc.xml中注入
自定义的异常信息类需要继承exception类



上传图片 
json数据交互
restful支持
拦截器	
	
35、response可以修改定义的内容，比如：
	response.setChatacterEncoding("utf-8");
	response.setContentType("application/json;charset=utf-8");
	response.getWriter().writer(jsonString);


36、	可以定义一个dmo的扩展类，专门处理sql查询，方便维护。有的代码，也会抽象出dmo的参数包装对象，作为统一的参数传入。

37、	








