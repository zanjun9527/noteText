合并时间点

1、	相关request和response操作，以及前段页面
	
	1.	request.getRequestURL() http://localhost:8080/jqueryWeb/resources/request.jsp
		request.getContextPath()/jqueryWeb
		request.getServletPath()/resources/request.jsp
		注： resources为WebContext下的目录名 	jqueryWeb 为工程名
	  
	2.	request.getParameter() 是从浏览器传递到服务器中的参数
		request.getAttribute() 是服务器代码暂时保留在request的值，这些值在代码中通过setAttribute后才会有值
		本页使用的变量可以用request.setAttribute("xx", xx);	
		跨页可以这样request.getSession().setAttribute("xx", xx);跨页后相应的request.getSession()然后get出来
	
	3.	response.sendredirect(url);   对服务器的响应进行重定向。当server作出响应后，client客户端的请求的生存周期就终止了。这个时候再用request.getparameter()或request.getattribute()得到的只能是null。 
		response.sendredirect(“sendredirect.htm?name=sparkwu&e-mail=spark.wu@cobra-tech.com”) 这样可以传值  
		
	4.json输出
		// 流的输出 自定义json 串或任意字符 调用方负责组装全部json串 或字符
		JSONObject jsonObject = new JSONObject();
		jsonObject.put("key","value");
		String result = jsonObject.toJSONString();
		public void printDataText(HttpServletResponse response, String result) {
			response.setContentType("text/html;charset=utf-8");
			PrintWriter pw = null;
			pw = response.getWriter();
			pw.print(result);
			pw.flush();
			pw.close();
		}
	5.动态select框
	<select class="VAILD" name="budgetType" id="unitPriceII" value="">
			<c:if test="${budgetType==null}">
			<option value="-1"  selected="selected">请选择预算费用</option>
			</c:if>
			<c:forEach items="${requireBudget}" var="item">
				<c:if test="${item.id==9}">
				<option value="" ></option>
				</c:if>
				<c:if test="${item.id!=9}">
				<option value="" ></option>
				</c:if>
			</c:forEach> 
		</select>
		
		
		<c:forEach var="addType" items="${addSers}" varStatus="addVsType">
			varStatus.index 从0开始的索引
			varStatus.count	从1开始的计数
		
	6.ftl freemarker相关
		ftl中的注释用<#-- -->
			<#if requireType=="1">
			1111
			<#elseif requireType=="4">
			444444
			</#if>  注意值加""

			<#if user??>
			${(user.name)!""}
			判空	<#if userAddress.area??>

					<#else>

					</#if>

	7.	ajax局部刷新页面案列
			<div id="context"></div>
			function toView1(act){
			var url = "${ctx}/admin/incomeCollect/toView1?act="+act;
			var option={
				url:url,
				type:"post",
				target:"#context",
				beforeSubmit:null,
				success:function(){	
				}
			};
			$("#queryInfoForm").ajaxSubmit(option);
	8.label标签没有for属性会默认制定第一个button
		<label>
			点点看<br>
			<input type='button'></input>
			<input type='button'></input>
		</label>
	9.httpServletRequest.getRequestURI()== getContextPath() + getServletPath() + getPathInfo()
		cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案
	10.	cookie：
		读取-	Cookie[] cookies = request.getCookies(); 然后遍历看cookie.getName()有匹配cookiename参数的，有则存在该cookie，
		添加-	cookie添加的时候，需要设置Path默认根路径，Domain域名，MaxAge过期时间
		
	11.data:{"reqAppointInfo":JSON.stringify(dataForm),"userId":$('#userId').val()},如果走的ajax data数据，没有传就拿不到，和表单提交不一样
	12.${}页面取值只能维持一次请求
	13.表单内容序列化
		var dataForm=serialize(releaseReqForm);
		dataForm['phoneScreen']=dataForm.cellShow;
	14.JSP,Servlet获取前一个请求的url路径
		pageContext.getRequest().getAttribute("javax.servlet.forward.request_uri")
		经常用在分页中的下一页传递一个page过去即可。
	
		
	
	
2、	缓存相关

	简单地比较Redis与Memcached：
        1.Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
        2.Redis支持数据的备份，即master-slave（主从）模式的数据备份。
        3.Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。
		
		
3、数据库和sql相关

	1.	ALTER TABLE `service_apply` ADD COLUMN `Price_Mode` int NULL COMMENT 'Price_Mode为0表示一口价' AFTER `Totoal_Price`;
	    UPDATE  pp_withdraw_limit_policy_config SET SINGLE_DAY_LIMIT=2000000,SINGLE_MONTH_LIMIT=2000000 WHERE id=1
	2.mybatis的自动参数绑定@param
	3.关联自身查询：
		<resultMap id="CitiesMap" type="com.xiaoyuer.core.dmo.BaseCountryArea">
  		<id property="id" column="id1"></id>
		<result property="name" column="name1"/>
		<result property="arealevel" column="Level1"/>
	 	 <association property="baseCountryArea" column="parentId1" javaType="com.xiaoyuer.core.dmo.BaseCountryArea">
	 	 		<id property="id" column="id2"></id>
	  		<result property="name" column="name2"/>
	  		<association property="baseCountryArea" column="parentId2" javaType="com.xiaoyuer.core.dmo.BaseCountryArea">
		  		<id property="id" column="id3"></id>
		  		<result property="name" column="name3"/>
		  		<association property="baseCountryArea" column="parentId3" javaType="com.xiaoyuer.core.dmo.BaseCountryArea">
			  		<id property="id" column="id4"></id>
			  		<result property="name" column="name4"/>
	  		</association>
	  	</association>
	  	</association>
  		</resultMap>
		
  		<select id="selectCities" parameterType="java.lang.Integer" resultMap="CitiesMap">
  			select 
			bca1.id as id1,bca1.name as name1,
			bca2.id as id2,bca2.name as name2,
			bca3.id as id3,bca3.name as name3,
			bca4.id as id4,bca4.name as name4
			from base_country_area bca1
			LEFT JOIN base_country_area bca2 on  bca1.Parent_Id= bca2.ID
			LEFT JOIN base_country_area bca3 on  bca2.Parent_Id= bca3.ID
			LEFT JOIN base_country_area bca4 on  bca3.Parent_Id= bca4.ID
			where bca1.id=#{id,jdbcType=INTEGER}
  		</select>
		<!---城市的关联查询--->
		4.	<![CDATA[文本内容]]>标记xml中作为纯文本,但是一般不把<if>标签包括在内，包含sql语句部分即可。
			alter table `pp_withdraw_order` change `Type` `TYPE` tinyint DEFAULT NULL 数据库更改字段名
			ALTER TABLE my_user CHANGE username username VARCHAR(18) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT ”;
			数据库更改字段类型，也可以直接数据库工具修改
			
		5.	数据库操作的时候程序没有完成走完也可以用临时的数据操作，遇到事务回滚才会返回，否则顺利完成，*插入成功没数据 事务回滚
		6.	<insert id="insertSelective" parameterType="com.xiaoyuer.core.dmo.RequireInfo" useGeneratedKeys="true" keyProperty="id">返回自增id
		7.	SYSDATE() 数据库sql中获取系统的当前时间
		8.	<if test="types!=null and types.size>0">
				and type in
				<foreach item="item" index="index" collection="types" open="(" 
					separator="," close=")">
					#{item,jdbcType=TINYINT}
				</foreach>
			</if>			-----------------------------------小写
		9.timestampdiff(second ,datetime_expr1,datetime_expr2)>=#{time}	返回日期之间的整数差。其单位由interval参数给出
		10.	SQL中select round(123.456,2)	123.46	返回数字表达式并四舍五入为指定的长度或精度。
			sql中ifnull（a,0）若a非null，返回a，否则返回0
		11.修改本地数据库的密码，关键的地方是需要关闭进程中的mysql和停止服务中的mysql。cmd中执行sql语句需要加；
			数据库的导入，选中库执行sql。sql中只有表的相关操作。
		12.order by IF(ISNULL(my_field),1,0),my_field; 
			IFNULL(sum(apply_amount),0)
			group by  唯一划分 要放在最后 
		13.	select id,group_concat(name) from aa group by id; 以id分组，把name字段的值打印在一行，分号分隔
			GROUP_CONCAT(bass.ID) AS addSer
			GROUP BY requireId
			搭配使用  
		14.数据库查询如果database没有主键，查询速度会非常慢
		15.sql使用`却别关键字
		16.	update中出现select语句的更新操作,select的结果再通过一个中间表select多一次，就可以避免这个错误
			update message set content='Hello World' where id in( select min_id from ( select min(id) as min_id from mes））
		17.sql表数据转储其他库时，先建表，后倒入数据，可保持数据结构一致
		18.	主键、外键和索引的区别:
				主键--唯一标识，不重复，不为空，
				外键--是另一表的主键, 可重复, 可空，用来和其他表建立联系用的，
				索引--无重复值，可为空，提高查询排序的速度，可有多个唯一索引
			 
				设置联合主键，自增的主键不能放在最左边
				CREATE TABLE `user` (  
				`id` int(11) NOT NULL AUTO_INCREMENT,  
				`username` varchar(255) NOT NULL,  
				`nack` varchar(255) DEFAULT NULL,  
				PRIMARY KEY (`username`,`id`) 
		19.在sql语句中 null只能用is 不能用=

			

	
4、	前端相关操作：
	
	1. 	function goStep2(){
			mill=(parseInt(Math.random()*10000)).toString();
			url="${serverAddr}${cpath}/wservice/release?mill="+mill;
			location.href = url;
		}
		
		
5、	相关快捷键和命令
		alt+↑  代码上移
		alt+ shift+o 显示 选中的属性 高亮
		ctrl + k 和 ctrl + shift+k 快速定位
		/** + 回车  快捷注释类
		
		
		netstat -ano|findstr "8080"  查找系统当前端口号占用情况
		cmd 查看当前目录， dir
		
	
	
	
6、	soa服务化项目：

	1.测试工具 postman
	2.Spring MVC -- @PathVariable和@RequestParam   
					 jersy访问框架restful--@PathPram和@QueryParam
	
	
7、	maven相关

	1.maven依赖jar,但是没有在eclispe中导入项目也看不到源码，除非jar中有resource文件
	2.springboot中
			<plugins>  
            	<plugin>  
                <!-- 自动重动 该工程在spring boot开发过程中非常有用，当工程文件发生变化的时候工程能够自动重启生效变化的内容 -->  
                <groupId>org.springframework.boot</groupId>  
                <artifactId>spring-boot-maven-plugin</artifactId>  
                <!-- <configuration> <fork>true</fork> </configuration> -->  
            	</plugin>  
        	</plugins>  
	3.默认优先依赖本地工程，jar靠后
	4.		
	上传远程仓库  snapshot和release版本
		<version>0.0.6-SNAPSHOT</version>
		<version>3.2.0.RELEASE</version> maven的两种版本管理稳定版和快照版，pom.xml中带release和snapshot的会自动打包拿到nexus相应的目录，其他不识别的打到release目录下，打包的时候需要大写SNAPSHOT才能到正确位置，小写会打到release库下，但是引用大小写都可以。
		<distributionManagement>
			<repository>
				<id>my-nexus-releases</id>
				<url>http://192.168.6.251:8087/nexus/content/repositories/releases/</url>
			</repository>
			<snapshotRepository>
				<id>my-nexus-snapshot</id>
				<url>http://192.168.6.251:8087/nexus/content/repositories/snapshots/</url>
			</snapshotRepository>
		</distributionManagement>
		snapshot实时，但不稳定，release版本则比较稳定。Maven会根据项目的版本判断将构件分发到哪个仓库。
		分发构件到远程仓库需要认证，需在settings.xml中配置认证信息：（nexus的账号和密码），其中server元素下id的值必须与POM中repository或snapshotRepository下id的值完全一致。将认证信息放到settings下而非POM中，是因为POM往往是它人可见的，而settings.xml是本地的。
		默认nexus不允许release重复部署，本地有版本就只会依赖本地版本，不会再远程拉，没有本地才拉远程
	5.打war包名称			
				<build>
    				<!-- pojectName就是打包后的名称：pojectName.war -->
					<finalName>pojectName</finalName>
				</build>
	6.Multiple SCMs Plugin使用 jenkins同时打包两个git项目

	
	
8、	solr相关
	
	1.组合使用优化查询效率
		query.addFilterQuery("status:0 AND biz_type:1 AND class_id:1 AND xxx:123");  
		query.setQuery("xxx:123"); 
	2.solradmin中 sort= id desc实现倒序排序
		id:[533 TO *] 查询533之后的所有
	3.	索引的与或过滤	
		String params = "(title:笔记 OR content:笔记) AND catalog_id:2";
		SolrQuery query = new SolrQuery();
		query.setQuery(params);
	4.solr搜索的schema.xml中的id（主键，不可重命名），默认是doc的主键
	5.solr工程可以使用单核和多核的配置，	6.默认情况下，solr的日志是瞬时的，tomcat重启后，就消失了。引入相应的日志jar后，在solr-4.5.1.war的WEB-INF下建classes目录，在该目录创建文件log4j.properties，即可生成日志文件。一般我们是在使用solrj的系统中增加日志捕获异常并输出日志，不在solr工程增加。
	7.	solr异常解决
		1.SolrException: Error loading class 'solr.VelocityResponseWriter'
		vi /usr/local/tomcat/solr/collection1/conf/solrconfig.xml
		<queryResponseWriter name="velocity" class="solr.VelocityResponseWriter" enable="${solr.velocity.enabled:true}"/>注释或者disabled - enable:false即可
		重启Tomcat

		2.org.apache.solr.common.SolrException:org.apache.solr.common.SolrException: Error opening new searcher
		清空索引
		# cd /usr/local/tomcat/solr/collection1/data/index
		# rm -rf *

		
9、	git
	1.eclispe的workspace中有关联.git的插件，实现与git本地仓库的代码关联
	2.两种查看项目地址的方式：1、preference-git-configuration-repository  2、项目右键查看git respository，查看properties。
	3. 版本的上线合并使用tag ，代码暂时保存需要切换其他分支做点事使用stash，stash会暂存当前的工作区内容，然后将工作区内容保持和上次提交相同，做完切换回来再恢复stash即可
	4.git版本回退：
				1、在history中的选中某个分支改动，reset（hard），之后再右键team-remote-push，选择分支强制推送，实现回退。
			     2、右键replacewith 选择相应的tag实现回退，实现的是将tag版本覆盖本地的dev分支，这时候dev会和远程有git变动
			     3、可以使用checkout挑出tag到本地，单独操作，也可以新建分支，随意
	5.git cherry-pick	用于把另一个本地分支的commit修改应用到当前分支。
	6.tag是基于分支存在的，远程有分支才能pull对应的tag


10、linux相关
		1.linux的常用命令 ：
			1、鼠标选中复制，右键黏贴
			2、cd..返回上级目录
			./startup.sh启动tomcat
			cd空格返回根目录
			cd空格..返回上级目录
			pwd-->示当前的工作目录（pwd:print working directory）
			find / -name dubbo-2.8.4a.jar查找某个文件
			tail -f  文件 可以实时follow日志信息
			ctrl+c 退出tail -f
			cd  / 退回到根路径
			find 查找
			:q!退出命令后加 ! 忽略提示   
			clear清屏   
			linux中的文本中?查找 		或者/
			
			ls和dir查看所有文件命令，more 查看具体的文件
			ctrl+shift+f  快速翻页
			insert或者i进入编辑模式    退出esc+:wq
			输入exit退出root用户
			
		2.linux下配置tomcat的环境变量
		JAVA_HOME=/usr/java/jdk1.8.0_131
		JRE_HOME=${JAVA_HOME}/jre
		PATH=$JAVA_HOME/bin:$PATH
		CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
			
			
11、常用工具类

	1.DecimalFormat 数字进行格式化类
		String val = new DecimalFormat("#0.0").format(12.08);数字转换
		String format1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(date);格式时间生成
		BigDecimal bg = new BigDecimal(d).setScale(2,  BigDecimal.ROUND_HALF_UP); double四舍五入保留2位小数
	2.StringUtils
	3.spring工具类AntPathMatcher， boolean result = new AntPathMatcher().match(patternPath, requestPath) 校验路径是否匹配
	4.simpledateformat只是日期格式的转换	Calendar才是日期的操作类	yyyy-MM-dd HH:mm:ss  大小写哈哈
		

12.框架相关

	ssm
		1.配置mvc视图解析的时候，默认配置视webapp下的路径，配置到/jsp下就可以了
		2.<context:component-scan> ，属性base-package去扫描指定包下的class和jar文件，扫描到有@Component 				@Controller@Service等这些注解的类，并注册为Bean类放到Bean工厂
		3.<Host appBase="webapps" autoDeploy="true" name="localhost" unpackWARs="true">
			---项目的部署路径              
		<Context docBase="D:\apache-tomcat-7.0.70\webapps\XiaoyuerProject" path="" reloadable="true" source="org.eclipse.jst.jee.server:XiaoyuerProject"/></Host>  --实际访问路径     实际的运用中可以配置图片服务器的虚拟路径
		在图片file写入磁盘的时候，采用的是路径+文件名的方式，路径最后要加上/，写入完整的路径。
		
	springboot:
		1.接口测试中：
			@Consumes({ ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8 })	请求指定
			@Produces({ ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8 }) 	返回指定




13.redis相关
	1.redis-cli.exe -h IP -p 6379,  这个要在redis-cli.exe 所在目录下面，-h后面接redis服务器的IP地址，-p后面接端口 
	2.redis加入环境变量并配置开机启动
	将D:\redis加入系统环境变量;使用sc create redis binpath= "D:\redis\redis-server.exe redis.conf" displayname= "redis" start= auto 
	命令注册windows服务使其开机启动。
	3.	redis持久化的方案：
	RDB持久化：指定的时间间隔内将内存中的数据集快照写入磁盘，不过实时的可能会数据丢失，速度快
	AOF持久化：将每一个收到的写命令都通过write函数追加到文件中(默认是 appendonly.aof)，速度慢、体积大，可设置不同的fsync 策略，安全性高
	
14.分布式和高并发相关
	分布式
		session共享
			代码级别的session共享			1、走拦截类，但此时request.getsession是不同步的，只能从redis中取出相应的值，存在则已经登录，但是这是redis使用，表面的登录，此时两个服务器的session是不同步的

			tomcat级别的session共享
			2、tomcat级别的session共享，相当于使用redis实现两个服务器的缓存共享
	
	
	
	高并发
		1.nio
		传统的socket io需要为每个连接创建一个线程，开销巨大；
		使用NIO，可用一个含有限数量的线程的线程池，甚至一个线程来为任意数量的连接服务。由于线程数量小于连接数量，所以每个线程进行IO操作的时候就不能阻塞，如果阻塞的话，有些连接就得不到处理，NIO提供了这种非阻塞的能力。
	
		2.并发锁的问题
			select for update 数据库的悲观锁 在高并发长事务情况下容易发生锁表问题
			改善方案，使用数据库的乐观锁，表中增加version字段，每次更新+1，数据库根据version操作即可
			数据库的update使用时 where 条件需要使用主键或者索引，防止长事务锁表
	
	
15、nginx相关
	1.nginx反向代理原则是，优先匹配全路径，然后再依次匹配后面的路径
	2.nginx.exe -t 检查配置文件是否正确
	3.nginx可以监听80端口将不同域名绑定到tomcat上的不同端口的不同项目
	 nginx是监听的本地ip，所以要改host文件域名，搭配使用，默认http是80端口，https是443端口，浏览器默认不显示端口域名，不得使用已经注册的域名



		
	

		
		
杂知识点：

	1.两个Integer变量不能直接==，需要intvalue（）后判断
	2.内部类：
		静态内部类可以直接创建对象new B.C();
		如果内部类不是静态的，那就得这样
		B b = new B();
		B.C c = b.new C();	 
		
	3.@Value("${PAGE_RETURN_URL}") 属性读取的条件是需要将属性文件加入容器
	4.加载类的时候，默认执行无参构造，使用有参构造，则只执行有参构造
	5.多个tomcat实例运行：
			1、复制多个tomcat目录副本,catalina.bat中不需要改动（已实用）
			修改startup.bat和shutdown.bat文件头下加，实现多个tomcat的运行
			SET JAVA_HOME=C:\Program Files\Java\jdk1.7.0_17
			SET CATALINA_HOME=D:\apache-tomcat-7.0.55-src
			SET CATALINA_BASE=D:\apache-tomcat-jenkins
			2、准备多套base_home的目录，公用一个catalina_home
			set "CATALINA_BASE=%cd%"  
			set "CATALINA_HOME=F:\apache-tomcat-7.0.69"  
			set "EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat"  
			call "%EXECUTABLE%" start 
			tomcat 的 catalina_home（安装目录） 和catalina_base（工作目录）
	6.tomcat的内存优化
		tomcat内存修改      -Xms256M   -Xmx512M   -XX:PermSize=128M   -XX:MaxPermSize=1024M
		eclipse内存优化		eclipse.ini    -Xmx1524m  -XX:MaxPermSize=256M
	
	7.反射相关
			getDeclaredMethod()获取类自身声明的所有方法，包含public、protected和private方法。
			getMethod()获取类的所有共有方法，包括自身的所有public方法，和从基类继承的、从接口实现的所有public方法。
			
	8.创建一个public static final 类型的map 并初始化赋初值，，也可以通过Collections.unmodifiableMap(params)，实现不可更改。  
				public static final Map<String,String> map=new HashMap<String, String>();
				static{
					map.put("1", "a");
					map.put("2", "b");
					map.put("3", "c");
				}
				在别的类中进行修改，重新创建实例可以共享修改的数据map
				
	9.mybatis generator 源码会默认设置追加属性为ture
	10.netstat -aon|findstr "49157" 查看端口的占用情况，然后任务管理器pid对应的进程
	11.modelMap.put(key,value)添加重复的key，会覆盖原来的值.
	12.HTTP Status 400 - Required String parameter 'pwd' is not present  @requestParam绑定缺失
	13.// 手机号码校验，使用正则表达式判断
		Pattern p = Pattern.compile("^17[\\d]{9}|13[0-9]{9}|15[012356789][0-9]{8}|18[\\d][\\d]{8}|147[0-9]{8}$");
		Matcher m = p.matcher(cellPhoneNum)
	14.eclipse中的tomcat找不到war工程 
		The given project is not a virtual component project   让我改property >  Myeclipse> project  facets（可选择相应的web和java版本） 
	15.使用@responseBody标签直接返回json数据，需要引入两个jar包 jackson-core.jar，jackson-databind.jar
	16.poi 实现excel的导出功能。
	17.一般jsp文件不放在web-inf下  	web.xml放在web-inf下
	18.	eclispe部署到root下放入的方案
		1）、部署的路径是webapps下，工程的名字改为root，这种测试中比较快
		2）、解压war工程到root下，运行tomcat即可，这个一般linux自动部署方法
		3）、改变工程访问路径   
		server.xml 中 <Context path="/" docBase="XiaoyuerProject" debug="0"  reloadable="false"></Context> 
		这个和web project setting中设置context root是一致的，倾向后者，在双击tomcat中的modules中也可以设置
	19.	bean的注入失败情况
		1.对应要注入的实现类没有 加注解，如dao层 @Repository  如service层  @Service
		2."You generally autowire to your interface type and not impl."调用的接口是否有具体的实现类。
		3.@Autowired下面，没有类，直接跟了@RequestMapping。【我的是直接跟了method，显示无法注入method，导致不识别的No qualifying bean of type [java.lang.String] found for dependency错误，】
	20.正常类中@Override 时出错误，因为你的Compiler 是jdk1.5，只要把它改为 1.6
	21.	//创建数组
	1）、int[] arr=new int[6];
	2）、int[] x={1,2,3,4};
	3）、int[] y= new int[]{1,2,3,4,5};

	23.sosoapi sosoapi ip权限  和 用户管理员权限（t_proj_mem中修改成员的信息）
	24.连等判断 int a = 2==2 ? 1:0;
	25.		随机数
			Integer res = random.nextInt(n);
			Integer res2 = (int)(Math.random() * n);
	26.注释模板：
		shift+alt+J 自动注释  
		或者/** +enter      
		Window -->preferences--> Java --> Code Style --> Code Templates  中修改注释模板
	27.	<c:set var="fileUrl" value="http://192.168.6.199:8086"/>
	<form id="itemForm" action="${fileUrl}${pageContext.request.contextPath }/editItemsSubmit" method="post" enctype="multipart/form-data"> 
	跨域提交表单的时候，需要写全http://头，否则不识别跳转blank空页面
	表单提交需要刷新回显
	ajax可以实现异步回显
	28.web.xml 和jar正常  java.lang.ClassNotFoundException:org.springframework.web.context.ContextLoaderListener 
		原因是最终的web工程中jar最终是要在web-inf的lib下的，没有重新添加maven的buildPath
	29.	枚举类的使用
			枚举类一定需要private的构造函数
			public class Test {  
			public enum Color {  
				RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4);  
				// 成员变量  
				private String name;  
				private int index;  
				// 构造方法  
				private Color(String name, int index) {  
					this.name = name;  
					this.index = index;  
				}  
				@Override  
				public String toString() {  
					return this.index + "_" + this.name;  
				}  
			}  
			public static void main(String[] args) {  
				System.out.println(Color.RED.toString());  
			}  

		}
	30.取对象属性操作后，对象本身也在变化
		Person person = new Person();
		BaseDict2 baseDict2 = person.getBaseDict2();
		baseDict2.setDescription("123123");
		System.out.println(JSON.toJSON(person).toString());
	31.可以看出DTO传输对象的设计应该具备这几个特点：
		1.按需放入字段。
		2.保证贫血模型，不要放任何逻辑在里面。可以看出DTO传输对象的设计应该具备这几个特点：
		1.按需放入字段。
		2.保证贫血模型，不要放任何逻辑在里面。

	32.@Autowired，首先在容器中查询对应类型的bean
　　　　如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据
　　　　如果查询的结果不止一个，那么@Autowired会根据名称来查找。
　　　　如果查询的结果为空，那么会抛出异常。解决方法时，使用required=false
		弄到方法上就是在实例化这个类的时候，注入方法形参类型的
		@resource（name=“personDaoBean”）默认byName
	33.NAT的典型应用：
	在一个局域网内，只需要一台计算机连接上Internet，就可共享Internet连接，使局域网内其他计算机也可以上网。使用NAT协议，
	局域网内的计算机可以访问Internet上的计算机，但Internet上的计算机无法访问局域网内的计算机。
	34.泛型
		List<T> getList<T param1,T param2>	可以限制返回结果的类型以及两个参数的类型一致。
		List<?>一般就是在泛型起一个限制作用。	public void test(? extends Fruit){};
	35.	svn删除恢复
	找到删除该文件或者文件夹的版本，在Logmessage里右键Revertthechangesfromthisrevision。
	36.	maven本地工程依赖失效，install总的pom工程即可
	37.	日志：logger.error("用户{},获取月份信息失败", "nini"); 日志快捷传参
	38.	拦截器再往上抛出异常，可由统一自定义异常处理
		springmvc的统一异常处理需要实现HandlerExceptionResolver接口
		spring的handle在处理时发现异常后，HandlerExceptionResolver的列表会被赋值，然后进行处理
		这个统一异常处理类需要加入spring容器

		ControllerExceptionResolver implements HandlerExceptionResolver
		{
		public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,
			Exception ex)
		{
			ModelAndView mv= new ModelAndView();
			return mv;
		}
		}
		拦截其中重定向后return true，则重定向无效
	39.WEB-INF下的文件无法直接访问，可以直接把JSP页面放到WEB-INF外的webapp目录下，可以通过转发的方式访问，我用的是Controller来进行转发，
	<%=request.getContextPath()%>	jsp页面中直接获取项目的工程名	
	路径前加“/”是代表绝对路径，不加“/”是代表相对路径。
	相对目录中 同级怒路直接取	<img src="img/solr.png">
	40.	HttpClient  
        HttpEntity  消息载体，post或者response中消息的载体
		httpclient.execute(httppost)
		处理返回消息体：EntityUtils.toString(response.getEntity(), "UTF-8");
		post请求：传参
		List<namevaluepair> formparams = new ArrayList<namevaluepair>();
	41.代码改动没反应，删除classes下的文件，在项目buildpath，把源码src添加进来就可以了

	





				
				
		

	
	
	
	


	


	