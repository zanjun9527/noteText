

这本书 文字太多，不够简洁

1.sql的预编译机制，这个重要的规则是避免使用字符串串联起多个sql查询。

2.悲观锁是避免冲突，遇到就等；乐观锁是提交时才判断冲突。select ... for update ，容易死锁，因为会一直等到锁可用，两个用户都需要a，b资源，这时候会出现互相等待的场景
   在处理跨系统的事务时，等待锁是没意义的，这时候需要涉及超时控制。只需让锁管理对象在锁不可用时抛出异常就行。
	可以给锁增加时间戳，定期清除超时的锁即可
	
	在冲突率很高的并发场景下适合用悲观锁（应该是作为乐观锁的一个补充）
	
	
3.跨域多个请求的事务称为长事务，还有就是使用延迟事务，尽可能晚打开事务

4.客户端的会话状态保存，客户端存储数据，：url参数(常用来传递sessionId)，表单隐藏域(可以再传给server端)，cookie(基于域名传递的)，
	服务端的会话状态是存在内存中的，即session，对应的key是sessionid存放内存映射表中，
	
	
5.try 在for之外，那么异常是会终止循环的，若在之内，捕获后可继续循环

6、spring的循环依赖问题：在注入@Autowired 下加@Lazy 注解即可(两边都加比较保险)
   原因是spring中Bean构造函数入参引用的对象必须已经准备就绪，那么两个相互依赖的bean就有可能出现问题
   
   还有一个解决方式是：将相互依赖的两个Bean中的其中一个Bean采用Setter注入(也就是属性注入)的方式即可。
   
   
   spring对象初始化三个步骤：
	（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象
	（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充
	（3）initializeBean：调用spring xml中的init 方法。
	从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二部。也就是构造器循环依赖和field循环依赖。

	
	Spring容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中。
	因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的Bean将从“当前创建Bean池”中清除掉。
	初始化完的Bean会从池中移除
	
	
	setter是实例化结束的对象放到一个Map，可以获取，构造是放在池中，池不能重复创建同一对象
   
   

7、生产上的tomcat是没有配置ssl的，都是nginx端配置的https，所以请求实际上都是在http上存入缓存


8、default-autowire="byName" 在配置mybatis数据源的地方去掉，否则读取属性文件找不到

	<parent>
	<relativePath>作用

	<!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 
	目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 -->
	<relativePath />
	
	ContextLoaderListener默认去WEB-INF下加载applicationContext.xml配置。
	默认的applicationContext.xml和x-servlet.xml文件
	
	netpay中不能吧openservice也依赖进来，这样就不是远程的服务了
	rpc的公用接口jar一定要和service分离开来
	
	直接拖动相关java文件，对应的会更新引用	

	编译ok 运行异常，肯能是tomcat的运行配置中少了环境
	
	
9、jdk版本切换要点
	cmd  echo %path% 输出系统的环境变量
	更换java_home
	删除path中的变量C:\Program Files (x86)\Common Files\Oracle\Java\javapath;
	删除C:\ProgramData\Oracle\Java，将Java文件直接删除
	然后更换system32中的三个java文件对应版本即可
	最多还要修改下注册表	HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment
				HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Development Kit
	
	
	
10、boot使用数据源或者jndi
	JndiObjectFactoryBean，DataSourceBuilder
	
	
	
11、分页插件
	目前的分页插件PagePlugin，也是网上随便copy的一份下来用的，对mapper有代码侵入，无法封装总页数
	分页插件的原理  物理和逻辑分页
	逻辑分页利用游标分页，好处是所有数据库都统一，坏处就是效率低。 
	物理分页就是数据库本身提供了分页方式，如mysql的limit，好处是效率高

	mybatis-plus 插件	https://www.cnblogs.com/leeego-123/p/10734330.html
		常用的bootmaven依赖 
		<!-- Spring Boot热部署 -->
				<dependency>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-devtools</artifactId>
					<optional>true</optional>
				</dependency>
			</dependencies>

			<build>
				<plugins>
					<plugin>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-maven-plugin</artifactId>
					</plugin>
				</plugins>
			</build>

			
		boot原本配置
		mybatis:
			mapper-locations: classpath:mappers/*.xml
			 虽然可以配置这项来进行pojo包扫描，但我更倾向于在mapper.xml写全类名
			 type-aliases-package: com.rhine.blog.po     配置之后好像可以省略xml中的包名，<resultMap id="userMap" type="UserBean">

		plus插件的配置，但是需要排斥其他的mybatis依赖，在boot中
			<!-- 
			<dependency>
					<groupId>org.mybatis.spring.boot</groupId>
					<artifactId>mybatis-spring-boot-starter</artifactId>
					<version>1.3.2</version>
				</dependency>
			-->
		mybatis-plus:
		  mapper-locations: classpath:mappers/*.xml
		  type-aliases-package: com.rhine.blog.po
		  
		
	pagehelper
		PageHelper.startPage(1,3);
        List<UserBean> byEmail = userMapper.findByEmail("100");//实际查询返回的是page对象，也是实现list接口的额，
        PageInfo page = new PageInfo(byEmail);
        long total = page.getTotal();

			<dependency>
				<groupId>com.github.pagehelper</groupId>
				<artifactId>pagehelper-spring-boot-starter</artifactId>
				<version>1.2.5</version>
				<exclusions>
					<exclusion>
						<groupId>org.mybatis.spring.boot</groupId>
						<artifactId>mybatis-spring-boot-starter</artifactId>
					</exclusion>
				</exclusions>
			</dependency>

		//分页时，实际返回的结果list类型是Page<E>，如果想取出分页信息，需要强制转换为Page<E>，
		//或者使用PageInfo类对结果进行包装，可以拿到多有的page属性
		PageInfo page = new PageInfo(list);
		Page<UserBean> byEmail = (Page)userMapper.findByEmail("100");
	
	总结：PageHelper首先将前端传递的参数保存到page这个对象中，接着将page的副本存放入ThreadLoacl中，这样可以保证分页的时候，参数互不影响，接着利用了mybatis提供的拦截器，取得ThreadLocal的值，重新拼装分页SQL，完成分页。

	在threadlocal中设置分页参数，之后在查询的时候，获取当前线程中的分页参数，执行查询的时候通过拦截器再sql中添加分页参数，之后实现分页查询，查询结束后在finally语句中清除threadlocal中的查询参数

	原理：使用ThreadLocal来传递和保存Page对象，每次查询，都需要单独设置PageHelper.startPage()方法

	PageHelper.startPage()和查询方法连着用，实际就是拦截器再查询方法的时候，从线程变量中拿到分页信息组装的结果。

	这个类实现了org.apache.ibatis.plugin.Interceptor接口。在com.github.pagehelper.PageInterceptor.intercept(Invocation)方法的最后finally块中调用了afterAll:
	在你要使用分页查询的时候，先使用PageHelper.startPage这样的语句在当前线程上下文中设置一个ThreadLocal变量，再利用mybatis提供的拦截器（插件）实现一个com.github.pagehelper.PageInterceptor接口，这个分页拦截器拦截到后会从ThreadLocal中拿到分页的信息，如果有分页信息，这进行分页查询，最后再把ThreadLocal中的东西清除掉。
	最后实在finally中清除的


	使用pageinfo后面的关联问题
	实际山查询出来的是一个page(list)信息，后面封装了pageinfo的参数

	继承arraylist后，数据都是放在elementData数组中的
	返回的page<e>就是一个数组，元素在elementData中（list中的数据组），

		

12、Java泛型中的标记符含义： 
	 E - Element (在集合中使用，因为集合中存放的是元素)
	 T - Type（Java 类）
	 K - Key（键）
	 V - Value（值）
	 N - Number（数值类型）
	
	
13、ThreadPoolTaskExecutor可以配置线程池相关，是spring的线程池技术，可以配置相关参数
	调用demo
	SpringThread t = new SpringThread(i);
	executor.execute(t);

	
14、日期的时间变化，注意时分秒的精度
	SELECT DATE_SUB('2019-07-02 17:21:08', INTERVAL 1 DAY)
	SELECT DATE('2019-07-02 17:21:08'-INTERVAL 1 DAY)
	
15、移动端的日志插件
	 <script type="text/javascript" src="https://www.w3cways.com/demo/vconsole/vconsole.min.js?v=2.2.0">
	 <script>
			var vConsole = new VConsole();
	 </script>
		
		
	后面直接使用日志打印即可，移动端会有vconsole的显示
	
	try{
						
	}catch(err){
	   console.log(err)
	   console.log(err.message);
	}

16、boot、dubbo
	jar 启动时候可以用java -jar app.jar --spring.profiles.active=dev  来指定运行的环境，目前采用的是pom中指定profile加载的属性文件
	
	注册服务
		spring.dubbo.application.name=controller-consumer
		spring.dubbo.registry.address=zookeeper://172.17.0.2:2181
		spring.dubbo.scan=com.gaoxi						扫描dubbo的注解，使用注解
		
		import com.alibaba.dubbo.config.annotation.Service;
		@Service(version = "1.0.0")
		@org.springframework.stereotype.Service

	发现服务
		@Reference(version = "1.0.0")
		spring.dubbo.application.name=controller-consumer # 本服务的名称
		spring.dubbo.registry.address=zookeeper://IP:2182 # zookeeper所在服务器的IP和端口号
		spring.dubbo.scan=com.gaoxi # 引用服务的路径

	其中可以将权限缓存在本地的map中，
	

17、在继承arraylist后，转为json对象，后面只能解析出list元素中的东西，使用fastjson是这样的
	实际是判断list继承后解析的，只解析了list总的元素值，在eclipse中显示正常，但是在idea中显示缺少
	
	
18、全局异常处理
	使用@ControllerAdvice注解，全局捕获异常类，只要作用在@RequestMapping上，所有的异常都会被捕获
	HandlerExceptionResolver，旧版的是在web.xml中配置错误页面
	
	
19、shiro相关
		shiro配置的两种方式，代码注入和配置ini文件加载

		配置的几个关键的东西：securityManager,ShiroFilterFactoryBean,自定义Realm（创建时候可能需要加密的方式配置HashedCredentialsMatcher），

		登录之后，存在session中，这样够缓存用户的信息，每次请求都创建一个subject，从缓存中新建的对象
		权限更新后需要更新内存中的权限

		使用shiro的注解需要配置AuthorizationAttributeSourceAdvisor	
		HashedCredentialsMatcher 是密码加密相关

		SecurityUtils.getSubject()是每个请求创建一个Subject, 并保存到ThreadContext的resources（ThreadLocal<Map<Object, Object>>）变量中，也就是一个http请求一个subject,并绑定到当前线程。 


		login的时候，获取一个subject.login(new UsernamePasswordToken(name, userParam.getPassword()));这样在realm中认证的时候，用户的name 和密码信息就会被拿到了
		然后再认证中返回 new SimpleAuthenticationInfo(userName, passwordInDB, ByteSource.Util.bytes(salt),getName());
		最终是通过securitymanager调用AuthenticationInfo info = realm.getAuthenticationInfo(token);实现认证

		可以初始化权限路径，将资源权限加载进来
		  String permission = "perms[" + resources.getResurl()+ "]";
		  filterChainDefinitionMap.put(resources.getResurl(),permission);

		<!-- 过滤链定义，从上向下顺序执行，一般将/**放在最为下边 -->:这是一个坑呢，一不小心代码就不好使了;
		SimpleAuthenticationInfo第一个参数一般传的是userinfo对象，有的也传username，暂时不确定，后续待验证


		首先shiro会先从缓存中获取认证信息(对应getCachedAUthenticationInfo方法),如果没有才会继续从Realm中获取,
		认证的时候 ByteSource credentialsSalt = ByteSource.Util.bytes("vip");
		Object obj = new SimpleHash(hashAlgorithName, password, credentialsSalt, hashIterations);
		会使用SimpleAuthenticationInfo中公用的salt，和token中的密码相对比，一致就校验通过



		除了通用的过滤器外，可以自定义过滤器
		//下面的配置路径 都需要在上面配置 authc 否则访问不到filter
		filterChainDefinitionMap.put("/online","requestURL");


		自定义路径拦截器继承PathMatchingFilter（可以实现用户路径权限的判断）

		filtersMap.put("requestURL", getURLPathMatchingFilter());
		shiroFilterFactoryBean.setFilters(filtersMap);

		相关的配置文件：INI配置文件一般适用于用户少且不需要在运行时动态创建
		INI文件优势 : 简单易懂 , 集成方便.
		INI文件缺点 : 采用硬编码方式把认证授权信息写在INI文件中,可维护性差.
		推荐相关配置放在数据库中动态读取


		常见的realm，我们需要缓存功能,认证功能,授权功能,三大功能 .认证原则:什么样的用户是怎样的角色.拥有什么的权限.
		shiro的默认的拦截器执行是有一定的顺序的，一般全匹配的放最后面，如果匹配到就不继续匹配了，所以把 /放到最前面，则 后面的链接都无法匹配到了。 

		拦截器的通配符的写法
		?：匹配一个字符
		*：匹配零个或多个字符
		**：匹配零个或多个路径

		也可以使用一个过滤器，将每个路径都过滤一遍
		感觉实现自己的路径拦截会更灵活点，在项目中配置注解，维护性差

		Subject.login()登录成功后用户的认证信息实际上是保存在HttpSession中的。如果此时Web应用程序部署了多实例，必须要进行Session同步。


		其实在SecurityManager中设置的CacheManager组中都会给Realm使用，即：真正使用CacheManager的组件是Realm。


		首先需要对session进行同步，因为shiro的认证信息是存放在session中的；其次，当前端操作在某个实例上修改了权限时，需要通知后端服务的多个实例重新获取最新的权限数据。


		当用户登录之后就会被缓存在session中，再次访问会根据sessionid渠道对应的pricipals，

		principal, 就是传入的认证信息的第一个参数,传递的类型就是后面获取的值。UserBean user = (UserBean)subject.getPrincipal()
		  public SimpleAuthenticationInfo(Object principal, Object hashedCredentials, ByteSource credentialsSalt, String realmName) {
				this.principals = new SimplePrincipalCollection(principal, realmName);
				this.credentials = hashedCredentials;
				this.credentialsSalt = credentialsSalt;
			}

			
20、ruoyi
	获取request的方式，	1.从controller一层层往下传，
						2.RequestContextHolder，直接在需要用的地方使用如下方式取HttpServletRequest即可
						HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();  本质上还是使用了threadlocal变量
						
	job的配置：quartz调度三大核心元素Scheduler(任务调度器)、Trigger(触发器)、Job(任务)
	Spring整合Quartz进行配置遵循下面的步骤：
			
	1：定义工作任务的Job
	，通常也是jobdetail        
	2：定义触发器Trigger，并将触发器与工作任务绑定
	（两种方式，静态和动态，动态的配置文件不用配置）        
	3：定义调度器，并将Trigger注册到Scheduler
		

	触发的方式
	在项目中建一个类继承包中的QuartzJobBean类（这个方法是在时间到来时自动执行的方法）
	是一个抽象类需要重载executeInternal（JobExecutionContext）方法

	在设置jobdetail的时候，可以使用QuartzJobBean完成统一的触发入口，
	也可每个detail都定义实现job统一接口，完成触发也行
	jobDetail.getJobDataMap().增加参数		

	session和缓存相关
			查看唯一登录的情况，登录踢出的功能，就是实现用户信息和session绑定的情况，

			其实在SecurityManager中设置的CacheManager组中都会给Realm使用，即：真正使用CacheManager的组件是Realm。

			踢出的功能，是引入了一个 Deque<Serializable> deque，其中存放的是用户的sessionid，存放在相应的cache中，
			当队列中size大于限制数，踢出对应的session， 将对应的session中设置kickout为true，当用户访问时，只要当前session中
			的kickout为true，就logout并重定向。

			shiro中常用的sessionmanager，DefaultWebSessionManager（可以不依赖容器管理会话）
			cache是缓存的操作，session是会话的操作

			Queue strings = new ArrayDeque<Serializable>();  队列顺序有点像栈
			可以用linkedlist代替，但是list的顺序是按照添加的顺序

			核心的路径匹配就是perm.implies(permission)

			使用自定的redis作为缓存需要自己实现
			CacheManager，主要管理缓存，提供一个缓存实例即可
			Cache，操作具体的实例来完成
			userRealm.setCacheManager(cacheManager);  表示开启了内存缓存
			Cache<Object, AuthorizationInfo>，将权限信息缓存进了cache中，下次可以直接使用
			
			dependencyManagement只是申明依赖，可以实现统一版本，子模块按需自己引入相应的jar

			SnakeYAML可以加载yaml文件，存进map中使用

			动态数据源，在查询的时候拦截选定指定数据源，后面执行数据操作的时候匹配相应的数据源，主要的是继承AbstractRoutingDataSource

			nested exception is org.springframework.core.NestedIOException: 
			Failed to deserialize object type; nested exception is java.lang.ClassNotFoundException: com.xiaoyuer.pay.web.SessionData
			以redis为缓存中心，当系统需要从redis中获取缓存信息的时候，其中的类需要反序列化出来，系统中需要有相应的类
			
			
			

			


21.	可以测试支付调用主站时候的"转码，url中的正常&是不能转义的
	String param = dataForSign.replaceAll("\"", "%22").replaceAll("}", "%7d").replaceAll("\\{", "%7b").replaceAll(" ", "%20");

	单纯的select * from a,b是笛卡尔乘积。
	但是如果对两个表进行关联:select * from a,b where a.id = b.id 意思就变了，此时就等价于：select * from a inner join b on a.id = b.id。即就是内连接。

	nignx先断3秒后关机,留给上一个请求处理时间
	
	数据库备份数据，不要勾选视图和存储过程

	HAVING类似于WHERE（唯一的差别是WHERE过滤行，HAVING过滤组），是跟着group by 使用的，以组为查询的维度
	
	为日志增加变量输出
		MDC.put(STR_USER, accountNo);
		MDC.remove(STR_USER);    这个最终在finally中需要删除掉

		
		
	正则表达式：
		.（点号）也是一个正则表达式，它匹配任何一个字符
		.*	任意字符匹配多次	a*   多个字符匹配多次  依次匹配
		.*?	任意字符匹配一次	a*?
		\s+	匹配任意多个上面的字符。另因为反斜杠在Java里是转义字符，所以在Java里，我们要这么用\\s+
		. 匹配除换行符以外的任意字符

		\w 匹配字母或数字或下划线或汉字 等价于 '[^A-Za-z0-9_]'。
		\s 匹配任意的空白符
		\d 匹配数字
		\b 匹配单词的开始或结束
		^ 匹配字符串的开始
		$ 匹配字符串的结束

		^\d+(\.\d+)?

		1,^ 定义了以什么开始
		2,\d+ 匹配一个或多个数字
		? 设置括号内的选项是可选的
		\. 匹配 "."
		可以匹配的实例："5", "1.5" 和 "2.21"。

		特殊字符必须转义之后才能当做字符串
		java中\\代表一个\

		^匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。
		
	正则表达式：
			字符串 String 的 split 方法，传入的分隔字符串是正则表达式！部分关键字（比如.[]()\|等）需要转义. |
			"a.ab.abc".split("\\."); // 结果为["a", "ab", "abc"]
			"a|ab|abc".split("\\|"); // 结果为["a", "ab", "abc"]
		
		
	两端交互的时候，发送端指定编码，接收方使用固定编码接收即可	
		response.setCharacterEncoding("UTF-8");//发送方固定统一编码utf8  然后接收方 的流处理使用统一编码解码即可
		
22.dubbo注解配置相关
			EnableDubboConfiguration 是使用dubbo注解的，spring的扫描注解正常配置,不影响
			
			http://jm.taobao.org/2018/06/13/Provider配置/    		dubbo配置
			http://dubbo.apache.org/zh-cn/blog/dubbo-annotation.html	官方文档

			@Component
			@PropertySource("classpath:application.properties")
			@ConfigurationProperties(prefix = "application.dubbo.demo.server")
			无敌属性类

			代码配置 dubbo配置，后续使用注解配置，@DubboComponentScan("com.xiaoyuer")
			@Configuration
			public class Dubboconfig
			注册
			  @Bean
					public RegistryConfig registryConfig() {
						RegistryConfig registryConfig = new RegistryConfig();
						registryConfig.setAddress(dubboProperties.getAddress());
						registryConfig.setClient(dubboProperties.getClient());
						return registryConfig;
					}

			<dependency>
				<groupId>org.apache.dubbo</groupId>
				<artifactId>dubbo-spring-boot-starter</artifactId>
				<version>2.7.3</version>
			</dependency>
		
		
		boot 中 @ImportResource 是加载xml文件用的，也可以用来加载dubbo.xml文件内容
		
	jdk升级的tomcat问题:
			Tomcat 从7升级到8的时候出现了 java .lang.IllegalArgumentException: An inval id domain [.xxx.com] was specified for this cookie 
			在 tomcat context.xml中配置 <CookieProcessor className="org. apache .tomcat.util. http .LegacyCookieProcessor" />
			
	日志相关
		stdout 输出到控制台，对应linux会输出到catalina.out
		自己配置日志路径	<property name="logbackpath" value="C:/Users/xiaoyuer/Desktop/xye-log"></property>  可行
		C:\Users\xiaoyuer\Desktop\xye-log  不行	
		
		additivity="false"  不继承父logger的输出，
		若是additivity设为false，则子Logger只会在自己的appender里输出，而不会在父Logger的appender里输出。
		
		logback中   appender是打印器  需要绑定到logger中  而root是根logger
		
	<logger name="org.springframework" level="ERROR" />
	这个是单独配置的级别  其中的参数默认覆盖root中的，其他的按照root默认来，会优先匹配logger，匹配不到才使用root的
	
	案例：
		<logger name="orderValidate" additivity="false">
			<level value="INFO" />
			<appender-ref ref="orderValidate" />
			<appender-ref ref="STDOUT" />      不加控制台不打印，加上打印，不加orderValidate，控制台也不打印，一个appender也不指定，也不会继承root，因为这里已经匹配了相应的logger了
		</logger>
		<root>
			<level value="INFO" />
			<appender-ref ref="STDOUT" />
			<appender-ref ref="ERROR" />
		</root>

		orderValidate不加STDOUT，控制台是看不到的额，因为指定匹配了logger，没有使用root的
		
		<logger name="ch.qos.logback" level="ERROR" />  和 root 和日志级别关系    additivity="false"这个属性注意下
		root的作用是收集下面所有反馈上来的信息流并根据配置在root中appender进行输出，looger中配置了additivity="false"，就不会反馈到root中。


		
		
23.rpc相关
		zookeeper和服务端建立的是长连接，可以定时进行心跳检测。这肯定是的啊  基础知识

		服务端的底层实现包括服务扫描，服务启动，服务注册等特性。

		定制@rpcservice注解，带有@service注解，这样启动可以被spring扫描到。然后通过反射创建该类的实例，加入容器管理，
		并建立服务名称和服务实例之间的映射关系，便于从后续rpc请求中获取服务名称，拿到实例，反射调用目标实例
		使用ApplicationContextAware获得上下文，初始化的时候，拿到所有标有@rpcservice的类，并将接口名和实例对象绑定
		
	静态内部类，可以实现延迟加载（初始化时候才加载），支付那边的就使用类，第一次调用加载，后续直接用只有在加载内部类的时候才初始化
	
	soa数据库加载使用
			
	在profile中现在dev环境也会默认指定的
		<resources>
			<resource>
				<directory>../vars/${pay_env}/datasource</directory>
				<filtering>true</filtering>
				<targetPath>config</targetPath>
			</resource>
		</resources>
		小秘书中的属性加载需要看resource中得默认指定的
		
		
		具体就是运行文件所在的目录
		C:/Users/xiaoyuer/git/xye-soa-pom/conf/xye-datasource.properties		pc
		/usr/local/java_project/webapps  这是生产jar使用的位置					linux
		
	solr	
		CommitWithin
			简单的说就是告诉solr在多少毫秒内提交，比如如果我指定<add commitWithin=10000>，将会高速solr在10s内提交我的document。用法
			1.可以在add方法设置参数，比如 server.add(mySolrInputDocument, 10000);
				
			solrServer.add(doc, Constants.CREATE_INDEX_MS);
	
	
24.数据库相关
		mysql中的主从复制是基于Binary log实现的
		
		分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。

		分库分表
			分库分表的取模运算
				分库分表的策略比前面的仅分库或者仅分表的策略要更为复杂，一种分库分表的路由策略
				如下：
				? 	中间变量=user_id%（库数量×每个库的表数量）； ? 
					库=取整（中间变量/每个库的表数量）； ? 
					表=中间变量%每个库的表数量。

		数据库行锁住之后，是可以查询的 ，更新不行

		乐观和悲观锁选择的标准是：冲突的频率和严重性，若冲突很少或者冲突后果不严重，选乐观
		但是若冲突结果是严重的痛苦的，那么就需要使用悲观锁，使用乐观在检测到冲突的时候还是需要面临合并冲突处理的情况，但是一般业务是很难自动合并的，只能扔掉从头开始

		任何读取的数据都需要跟共享数据进行版本标记比较，任何不同都意味着冲突的发生
		
		between '2019-09-18' AND '2019-09-19' 相当于 '2019-09-18 00:00:00' AND '2019-09-19 00:00:00'
		
		mysql多表联合更新
		UPDATE  t1,t2	set  ... 	WHERE ...
		
		分库之后，夸库业务，由原来的联合查询转变为多次查询，写入类的如要保证事务，可能要引入分布式事务
		
		mysql有很多字符串函数 find_in_set(str1,str2)函数是返回str2中str1所在的位置索引，str2必须以","分割开。
		
		db_xiaoyuer.log_user_trade  在sqlyog中是可以夸库查询的

		mysql---同服务器下跨数据库更新
			update 
				A数据库.表名,B数据库.表名 
			set 
				B数据库.表名.字段名 = A数据库.表名.字段名 
			where 
			条件（A数据库.表名.id = B数据库.表名.join_shop_id）;
			
		-- 批量插入
		<insert id="batchInsert" parameterType="java.util.List">
			insert into log_user_trade(trade_code,asset_from_code) values
			<foreach collection="logTrades" item="item" separator=",">
				#{item.tradeCode},
				#{item.assetFromCode}
			</foreach>
		</insert>

		
		留个参考
		update require_info
		<trim prefix="set" suffixOverrides=",">
			<trim prefix="Pay_User_Count=case id" suffix="end,">
				<foreach collection="infos" item="item">
					when #{item.id} then Pay_User_Count+#{item.orderCount}
				</foreach>
			</trim>
			<trim prefix="Status=case id"  suffix="end">
				<foreach collection="infos" item="item">
					when #{item.id} then #{item.status}
				</foreach>
			</trim>
		</trim>
		where id in
			(reqIds)
			
			
					
		
25.属性文件相关
		classpath 是xml中和属性文件中用的语言，直接属性文件加载不用，类似classpath*:a/b/c
		
		PropertiesConfiguration 快速读取属性文件，使用apache的PropertiesConfiguration接收
		
		  //先看看Properties
			String propertiesFileName="a.properties";
			Properties props = new Properties();
			props.load(new FileInputStream(propertiesFileName));
			String value =props.getProperties("key");

			//然后是PropertiesConfiguration
			PropertiesConfiguration propsConfig=new PropertiesConfiguration();
			propsConfig.setEncoding("UTF-8") //默认的编码格式是ISO-8859-1，所以才在读取文件之前先设置了编码格式
			propsConfig.load(propertiesFileName);
			String strValue=propsConfig.getString("key");
			String longValue=propsConfig.getLong("longKey");
			String[] strArray=propsConfig.getStringArray(arrayKey);
			//值得一提的是。propsConfig的默认分割符是','，换句话说，如果值使用','分割，使用getString去取的话是会抛出异常的，因为这被认为是个数组，分割符可以使用setListDelimiter设置。
			...
			三、总结
			告别java.util.Properties。



		
		
26.springboot 相关
		编译不行直接在pom中加入
		<plugin>
			<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-compiler-plugin</artifactId>
			<configuration>
				<compilerVersion>1.7</compilerVersion>
				<source>8</source>
				<target>8</target>
			</configuration>
		</plugin>

		boot整合redis，使用redistemplate，再加个工具类redisutil即可
		
		配置首页addViewControllers
		
		
27.dubbo相关
		dubbo默认服务提供方的IP为内网IP，生产上需要映射成公网ip
		
		几个soa问题：多级调用的延迟，调试跟踪困难，安全监测，qos支持，高了用，易伸缩
		
28.maven相关
		Maven默认用的是JDK1.5去编译，使用高版本的maven需要在pom中配置
		<build>
		   <plugins>
			 <plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.5.1</version>
				<configuration>
				<source>1.8</source>
				<target>1.8</target>
				</configuration>
			  </plugin>
			</plugins>
		</build>
		
		
29.事务相关
		事务的特性   要么全部完成 要么什么都不做
		乐观锁：通过冲突检测和事务回滚来防止并发业务事务中的冲突，提交的时候才有锁冲突，导致其他的无效操作
		悲观锁：每次只允许一个业务事务访问数据以防止并发业务事务中的冲突，一开始就拿到锁
			
		乐观事务锁的缺点是：只能在提交数据时才能发现业务事务将要失败，某些情况下，发现太迟，代价也大

	乐观锁中使用版本号，返回行数如果是0，要将事务系统回滚以防止不一致的数据进入数据库，即业务事务必须要么被取消，要么解决冲突并重试
	关键的修改需要加日志，版本号进行增量操作
	
	使用场景
		乐观并发管理使用业务事务冲突低的情况。因为冲突频繁发生，直到提交数据才通知冲突很不友好，会默认为经常失败。
		悲观锁在冲突率很高或者冲突代价很高更适用

	获取乐观锁动作必须要和提交记录数据在同一个系统事务中完成，才能保证数据一致性。检测到并发冲突因回滚事务，应该在发生任何异常时都将系统事务回滚。

	
	两阶段提交保持一致性
		 采用两阶段提交保证多master数据一致性，
		   1.开启事务
		   2.通知每个master执行某操作
		   3.所有master接到请求后，锁定执行此操作需要的资源，如扣款动作，就冻结相应款项，冻结完毕后返回
		   4.收到所有master的反馈后，如均为可执行此操作，则继续之后的步骤，如有一个master不能执行或者一段时间内无反馈，则通知所有master回滚操作
		   5.通知所有master完成操作

		先冻结，全部冻结ok了，就执行，全部执行ok就成功了，有一个不成功，就反馈回滚
		   
		   
		三阶段提交
		   是在两阶段提交的基础上增加了percommit过程，当所有master收到percommit后，并不执行动作，直到收到commit或超过一定时间后才完成操作
		 
		在实现两阶段或者三阶段提交时，为了避免通知所有master时出现问题，通常会借助消息中间件或让任意一个master接管成为通知者
		
		
		可见性。
			共享变量写入到内存的行为称为“冲刷处理器缓存”。也就是把共享变量从处理器缓存，冲刷到内存中。
			此时，线程 B 刚好运行在 CPU B 上，指令为了获取共享变量，需要从内存中的共享变量进行同步。
			这个缓存同步的过程被称为，“刷新处理器缓存”。也就是从内存中刷新缓存到处理器的寄存器中。
			经过这两个步骤以后，运行在 CPU B 上的线程就能够同步到，CPU A 上线程处理的共享变量来。也保证了共享变量的可见性。
						
		
30.其他
		每次request请求完成后，下一次是重新的request，不会保留上次请求的信息，这叫无状态
		
		集群就是水平扩展，做负载均衡

		int i=0;
		int i=i++;  最后值为0			
					
		JVM 在处理 i = i++; 时 , 会建立一个临时变量来接收 i++ 的值 , 然后返回这个临时变量的值 ,
		返回的值再被等号左边的变量接收了 , 这样就是说 i 虽然自增了但是又被赋值了0 , 这样输出的结果自然就是 0 了

		不妨我们用 temp 临时变量来接收 i++ 的值 , 来看一下结果 :
		int i = 0;
		int temp = i++; //temp的值是 : 0
		
		类是对事物的抽象(抽象了属性和行为)，抽象类是对类的抽象，接口是对抽象类的抽象。
		
		request.getHeader("User-Agent")  是拿到前段浏览器的请求信息
		
		final的方法不能被重写。所以父类中的private方法默认是final的，子类将无法访问、覆盖该方法
		
		Java字符串用\\表示\
		AntPathMatcher是URLs匹配工具类
		
		使用lambada的条件，必须只能是函数式接口（概述:接口中只有一个抽象方法）才适用。可以使用@FunctionalInterface 来提前校验函数式接口，编译时提前发现错误。
		单来看lambda像一个没有名字的方法，它具有一个方法应该有的部分：参数列表int x，方法body　return x+1,和方法相比lambda好像缺少了一个返回值类型、异常抛出和名字
		Runnable a=()->{System.out.println("测试新表达方式");};
		
		countDownLatch 是并发包使用的一个计数器，		调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
		
		Redis是单线程的，是线程安全的。
		
		当接口有多个实现类时，提供了@order注解实现自定义执行顺序，也可以实现Ordered接口来自定义顺序。(数字越小，优先级越高,)
		注意：，也就是@Order(1)注解的类会在@Order(2)注解的类之前执行
		
		CGLib代理，不受接口的限制，底层采用ASM字节码生成框架，效率高比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。

		其中需要使用 //Enhancer类是CGLib中的一个字节码增强器，它可以方便的对你想要处理的类进行扩展
		jdk使用的invocationhandler接口
		cglib使用的是MethodInterceptor接口
		
		
31.前后端缓存相关
		客户端状态信息
	前段参数传递，url参数，表单的隐藏域和cookie
	cookie只工作在同一个域名的站点中，若一个站点包含了多个域名，cookie不会在之间传递
	
	在分布式的session中，各个server间的缓存同步是不合适的（tomcat中的session复制，sessionid一样，是非常低效的），
	需要间缓存放在cache server中（以sessionid作为key）后面存在统一的redis中，
		
		
	Spring-session 技术是解决同域名下的多服务器集群 session 共享问题的，不能解决跨域 Session 共享问题
	在使用spring session过程中，发现spring session 往客户端写sessionID的策略要么是cookies要么是header。
	其实在开发中实际上有时候既要支持cookies，也要支持header方式，比如在PC端，
	一般是使用cookies，这样可以实现单点登录（不过还是没有解决跨域，要跨域只能用cas单点登录方案），
	手机app的话，不支持cookies，只能使用header，服务器响应请求的时候，往header里面写sessionId。
	
	
	登录相关
		xxl的单点更加简单，就是一个sso server基于cookie和session中缓存统一管理，没有就返回
		一般登陆ok是有两个cookie，一个是server端的 一个是client端的
		app,非cookie登陆就是从header存储信息

		我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。
		sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。
		这样可以实现顶域下的跨域处理，但是Cookie顶域的特性这种是属于伪跨域

		单调的简单原理： 		https://yq.aliyun.com/articles/636281
		server验证ok（写sso当前域）后需要ST 返回验票，成功后写app1当前域，
		app2跳转后sso已经登录，直接st返回即可，流程同1

		xxl-sso
		1   cookie 和缓存都没有  跳转server
		2   server成功返回，cookie没有  缓存有，设置cookie
		3   登录后再访问，cookie有直接返回，不用设置cookie


验证st（有一定时效性的）的必要性在于：
其实这样问题时很严重的，如果我在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，
是不是业务系统也认为登录了呢？这是很可怕的。所以需要统一server端验证


	
	
	
	
		
		
		
32.线程相关
	每个cpu（或者多核cpu中的每核cpu）在同一时间只能执行一个线程，
	线程上下文切换(抢占式)，当io阻塞或者有高优先级线程要执行时，就会切换，切换时要存储目前线程的执行状态，并且恢复要执行线程的状态。
	
	实现异步future+callable 实现返回值线程请求，对执行结果进行监听. 
	final List<Future<String>> resultList = new ArrayList<Future<String>>(); 
		for(Seckill seckill:list){
			resultList.add(executor.submit(new createhtml(seckill)));
		}
	   for (Future<String> fs : resultList) { 
		   try {
				System.out.println(fs.get());//打印各个线任务执行的结果，调用future.get() 阻塞主线程，获取异步任务的返回结果
			} catch (InterruptedException e) {
				e.printStackTrace();
			} catch (ExecutionException e) {
				e.printStackTrace();
			}
	   } 
		return Result.ok();
	}
	
	class createhtml implements Callable<String>  {
		Seckill seckill;

		public createhtml(Seckill seckill) {
			this.seckill = seckill;
		}
		@Override
		public String call() throws Exception {
			system.out.println(seckill.getSeckillId());
			return "success";
		}
	}

	
	main函数内部是无法访问非静态内部类的
	Future是返回各个线程的处理结果，并且多个线程，get的时候如果还没处理完就会阻塞（这是同步的），返回的对个future都是绑定固定的线程号的，线程只要执行完就能拿到结果。
	线程是进行中的，调用future.get()时会阻塞主线程，获取异步任务的返回结果
	
	
	/***开启新线程之前，将RequestAttributes对象设置为子线程共享*/
		ServletRequestAttributes sra = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
		RequestContextHolder.setRequestAttributes(sra, true);
		
		//在新的子线程中获取request
		HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();

	

	
	

33.单例模式，延迟加载
		/**
		 * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例
		 * 没有绑定关系，而且只有被调用到才会装载，从而实现了延迟加载（调用时候再加载，而不是一开始就加载）
		 */
		private static class SingletonHolder{
		
			 //静态初始化器，由JVM来保证线程安全,外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存，当使用了静态内部类才加载
			private  static AlipayClient alipayClient = new DefaultAlipayClient(Configs.getOpenApiDomain(), Configs.getAppid(),Configs.getPrivateKey(), PARAM_TYPE, CHARSET,
														Configs.getAlipayPublicKey(),"RSA2");
			
			private  static AlipayTradeService tradeService = new AlipayTradeServiceImpl.ClientBuilder().build();
		}


		延迟一次性加载，后续直接使用
		public class CommercePayRegister
		{
			 private static CommercePayRegister instance;
				
				private CommercePayRegister(){}
				 
				public static CommercePayRegister getInstance()
				{
					if (instance == null)
					{
						instance = new CommercePayRegister();
					}
					return instance;
				}
		}
		
		CommercePayRegister使用静态延迟创建一个实例，然后进行属性复制，后面这个静态类可以直接使用获得同一实例对象了。
		使用的是饥汉模式，自己内部定义自己一个实例，使用时创建，单例模式。
		这里使用延迟加载的都private了构造函数，这样这个就是单例的。
		后面维护统一的初始化类，一般通用配置类会考虑使用单例，本来就是一次性加载的东西，单例更好提现

		private static  只能在内部静态调用
		静态内部类的形式去创建单例的，故外部无法传递参数进，静态变量是和类一起加载的，static实现共享，延迟实例化，调用的时候实现共享

		静态内部类 单例   延迟加载  https://blog.csdn.net/mnb65482/article/details/80458571

		

34.多线程和锁相关
			线程直接run就是普通的方法，并没有开线程。必须new Thread(Runnable target).start 才开新线程
			
				使用两种锁锁方法
		   public static void lock(int i){
				lock.lock();
				num1 ++;
				lock.unlock();
			}
			public static synchronized void sync(int i){
				num2 ++;
			}
				
			事物提交是在整个方法执行完才会提交。
			select... for update  和update都可以实现悲观锁(一般伴随事务一起使用，数据锁定时间可能会很长)
			String nativeSql = "UPDATE seckill  SET number=number-?,version=version+1 WHERE seckill_id=? AND version = ?";这个是乐观锁的实现方式之一，是具体的案例，
			乐观锁这种场景，	并发高的时可能会出现失败次数多的情况
		
			select * from table_xxx where id='xxx' for update; 
			注意：id字段一定是主键或者唯一索引，不然是锁表
			
			两者本质上是一样的 只不过是封装了下，这个和理解的是一致的
			ExecutorService executorService = Executors.newFixedThreadPool(11);
			new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>()); 这样默认的是最大的队列值
			
			
			ListenableFuture是guava中的多线程能得到结果的方法,可得到多线程调用的结果  这个知道概念就行了
			
			
			
35.分布式锁相关
		使用private static  Lock lock = new ReentrantLock(true);/  系统是放在@service中，因为容器中的实例能保证是单例的，这样并发下lock只有一个实例
		
		redisson获取锁，不成功则订阅释放锁的消息，获得消息前阻塞。得到释放通知后再去循环获取锁。后续删除key后会发送消息，所以上文提到获取锁失败后，阻塞订阅此消息。
		和redis的setnx的方法差不多
		
		
		分布式锁的使用场景：
			Java提供的原生锁机制在多机部署场景下失效了
			因为两台机器加的锁不是同一个锁(两个锁在不同的JVM里面)。需保证两台机器加的锁是同一个锁。 Lock或synchronize只能解决单个jvm线程安全问题
			场景1	即同一请求多次操作一个资源 ，也肯能执行定时任务时就会遇到同一任务可能执行多次的情况，
			场景2	不同请求操作统一资源
			常见方案
				1、数据库实现（效率低，不推荐），线程出现问题，容易出现死锁
				2、redis实现（使用redission实现，但是需要考虑思索，释放问题。繁琐一些）   锁的失效时间难控制、容易产生死锁、非阻塞式、不可重入    这个怎么理解呢,待定
				3、Zookeeper实现   （使用临时节点，效率高，失效时间可以控制）
				4、Spring Cloud 实现全局锁（内置的）
				
			Zookeeper实现原理	
					zk节点唯一的！ 不能重复！节点类型为临时节点
					jvm1创建成功时候，jvm2和jvm3创建节点时候会报错，该节点已经存在。这时候 jvm2和jvm3进行等待。
					jvm1的程序现在执行完毕，执行释放锁。关闭当前会话。临时节点不复存在了并且事件通知Watcher，jvm2和jvm3继续创建。
					设置有效时间，超过时间就删除节点
			
		zookeeper
				zookeeper=文件系统+监听通知机制。
				
				主要的开源框架	两款开源框架ZKClient和Curator。可以用来操作zookeeper
				
				ZooKeeper目录树中每一个节点对应一个Znode。每个Znode维护着一个属性结构，它包含着版本号(dataVersion)，时间戳(ctime,mtime)等状态信息。
				ZooKeeper正是使用节点的这些特性来实现它的某些特定功能。每当Znode的数据改变时，他相应的版本号将会增加。
				
				ZooKeeper的临时节点不允许拥有子节点
									
			四种类型的znode：  持久 临时 有序
				-持久化目录节点：客户端与zookeeper断开连接后，该节点依旧存在
				-持久化顺序编号目录节点：断开后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号
				-临时目录节点：断开后，该节点被删除
				-临时顺序编号目录节点：断开后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号
		
			监听通知机制
				客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。
		
			ZooKeeper为我们保证了数据的强一致性。锁服务可以分为两类，一个是保持独占，另一个是控制时序。

			使用监听器时间同步等待的过程
					@Override
					void waitLock() {
					   IZkDataListener iZkDataListener = new IZkDataListener() {
						  // 节点被删除
							public void handleDataDeleted(String arg0) throws Exception {
								if (countDownLatch != null) {
									countDownLatch.countDown(); // 计数器为0的情况，await 后面的继续执行
								}
						 }
							// 节点被修改
							public void handleDataChange(String arg0, Object arg1) throws Exception {

							}
						};
						// 监听事件通知
						zkClient.subscribeDataChanges(lockPath, iZkDataListener);
						// 控制程序的等待
						if (zkClient.exists(lockPath)) {  //如果 检查出 已经被创建了 就new 然后进行等待
							countDownLatch = new CountDownLatch(1);
							try {
								countDownLatch.wait(); //等待时候 就不往下走了   当为0 时候 后面的继续执行
							} catch (Exception e) {
								// TODO: handle exception
							}
						}
						//后面代码继续执行
						//为了不影响程序的执行 建议删除该事件监听 监听完了就删除掉
						zkClient.unsubscribeDataChanges(lockPath, iZkDataListener);

					}
				}
			使用TimeUnit类来实现线程的sleep也可以
			
			
36.回调的思想是:
		类A的a()方法调用类B的b()方法
		类B的b()方法执行完毕主动调用类A的callback()方法

		同步回调和异步回调, 主要体现在其是否需要等待. 同步调用, 如果被调用一方的APi(第三方API), 
		处理问题需要花很长时间, 我们需要等待, 那就是同步回调, 如果调用完之后不需要理解得到结果, 
		我们调完就走, 去做其他事情, 那就是异步调用, 异步调用需要在我们调用第三方API处, 开启一个新的线程即可, 而同步调用和平常的调用没有任何区别.

		目前就是a调用b方法，并把实现callback接口的实例传过去，b方法调用完直接用实例回调方法即可

		a调用了b的方法，b开始执行，b执行完了，再调用a的方法，这就是回调。


37.多个微服务的dubbo的架构问题， 可以同时为提供者和消费者	
	不使用事务就是直接提交 没法控制
	
	信息的加密
		可分为对称加密：	加密后的信息可以解密成原值	des(适用数据库密码的加密)
		非对称加密：		无法解密还原为原值			比如 md5

		
38.浏览器敲get  对应的sessionid放哪里了
	第一次访问服务器，浏览器会带回一个sessionid，
	并set-cookie操作：Set-Cookie: SESSION=7004b0d6-dfb0-4756-898e-60379fb8b884; Domain=xiaoyuer.com; Path=/; HttpOnly
	当再次访问会将sessionid待入服务器，Cookie: SESSION=7004b0d6-dfb0-4756-898e-60379fb8b884; UM_distinctid=170a97fef53902-05e6115cbcea8b-4446062d-1fa400-170a97fef54e3; CNZZDATA1255347938=2105466369-1583388160-%7C1583388160

	查询  map 和list<map>  一行就是一条记录，对应的是一个resultType，如果类型是map，多条记录就是list<map>
	
	
39.做一个回退的merge测试，目前回退  更新   pick
	1.A->B  同源
	2.A回退，改动提交
	3.B cherry pick A,这时会有冲突，因为改动已经不是基于B一开始的源头了,B的源头已经改变了。

	同源测试更新是可以的，同源就是在原文件上，没有改动，单一改动，merge过来。

	
40.spring的启动后创建自动代理类，
	aspectj支持编译期织入且不需生成代理类。spring 集成了aspectj,但其不属于spring aop的范围。
	实现了pojo级别的代理实现
	aspectj中  切点直接声明在增强方法出，叫做匿名切点。想要复用就使用@Pointcut命名一个(目前系统再用的方式)。


	aop和aspectj是建立在动态代理的基础上实现的
	aop:advisor 与 aop:aspect都可以配置aop
	advisor只持有一个Pointcut和一个advice，而aspect可以多个pointcut和多个advice
	
	mybatis构造方法必须要有无参的构造方法
	
41.查看进程 和端口号    kill进程
	ps -ef | grep java	ps 静态的进程统计信息    e：所有   f:完整格式显示   grep  搜索
	netstat -ano | findstr "8080"
	kill -9  pid
	
42.针对post url中需要转义的， 转义param中的value即可，对整个param转义 会将&也转义了，这样request接收到的只有作为整个key="",

43.jar包中日志logger需要和项目中的log.xml匹配，统一logback，不然没有日志	
	每次重启solr后，admin控制台的日志会清除
	
	
44.maven配置
	远程仓库：中央仓库+私服+其他公共库，maven使用的默认是中央仓库，私服和阿里云镜像可以同时使用
	依赖的优先级：本地仓库 > 私服（profile）> 远程仓库（repository）。全局和pom中的优先，局部配置优先于全局配置

	mirror：拥有远程仓库的所有 jar，包括远程仓库没有的 jar，定义了两个Repository之间的镜像关系（大部分jar包都可以在阿里镜像中找到，部分jar包在阿里镜像中没有，需要单独配置镜像）
	配置多个mirror，默认只有第一生效（只有当第一个无法连接的时候才会接着往下匹配，但是注意第一个中a.jar没有是不会接着往下面的mirror中找的），可以都放着不影响，择优第一个就行。
	mirror相当于一个拦截器，将远程库的地址重定向到mirror里配置的地址。每个仓库只能使用一个镜像。
	mirrorOf配置了*，相当于代理所有的远程仓库，就只能去该镜像中下载，其他配置的多个库就失效了（因为拦截机制）。可以用来私服下载特定的jar

	全局多仓库设置，是通过修改maven的setting文件实现的。可以将常用的公共库，私服库配置进去。不建议在项目pom配置
	  在setting文件中添加多个profile（也可以在一个profile中包含很多个仓库），并激活（即使是只有一个可用的profile，也需要激活）。
		<activeProfiles>
		<activeProfile>myRepository1</activeProfile>
		<activeProfile>myRepository2</activeProfile>
	  </activeProfiles>

	setting.xml中的<server>，是pom中<distributionManagement>上传的认证配置，server元素的id必须与pom.xml中需要认证的repository元素的id完全一致。正是这个id将认证信息与仓库配置联系在了一起。
	配置多个远程仓库时，如果在一个远程找不到，依次从下一个仓库里找，在activeProfiles设置启用的仓库。默认会有一个ID是central的官方远程仓库。
		
	