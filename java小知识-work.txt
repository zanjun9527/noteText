学习小结：
1-学习新的东西，最直接标准的就是官方的API文档。
2-不要绕业务逻辑，抓重点
3-背景色：R:204, G:232, B:207
	  红199  绿237  蓝204 豆沙绿



1	request.getRequestURI() /jqueryWeb/resources/request.jsp
	request.getRequestURL() http://localhost:8080/jqueryWeb/resources/request.jsp
	request.getContextPath()/jqueryWeb
	request.getServletPath()/resources/request.jsp
	注： resources为WebContext下的目录名
	jqueryWeb 为工程名


2	用response.sendRedirect(response.encodeURL(url))的好处就是他能将用户的session追加到网址的末尾,
	也就是能够保证用户在不同的页面时的session对象是一致的. 
	这样做的目的是防止某些浏览器不支持或禁用了COOKIE导致session跟踪失败


3       如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：

        1 、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
        2 、Redis支持数据的备份，即master-slave模式的数据备份。
        3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。


4       缓存
        浏览器缓存在用户触发“后退”操作或点击一个之前看过的链接的时候很管用。
        同样，如果你在网站上访问同一张图片，该图片可以从浏览器缓存中调出并几乎立即显现出来。

5、     mybatis在xml中的典型实现
	<mapper namespace="com.xiaoyuer.core.dao.BaseCountryAreaMapper" >
 	 <resultMap id="BaseResultMap" type="com.xiaoyuer.core.dmo.BaseCountryArea" >
    	<id column="ID" property="id" jdbcType="INTEGER" />
    	<result column="AreaLevel" property="arealevel" jdbcType="INTEGER" />
    	<result column="Parent_Id" property="parentId" jdbcType="INTEGER" />
    	<result column="Name" property="name" jdbcType="VARCHAR" />
    	<result column="Date_Insert" property="dateInsert" jdbcType="TIMESTAMP" />
    	<result column="Date_Update" property="dateUpdate" jdbcType="TIMESTAMP" />
    	<result column="User_Insert" property="userInsert" jdbcType="INTEGER" />
    	<result column="User_Changed" property="userChanged" jdbcType="INTEGER" />
   	 <result column="Delete_Mark" property="deleteMark" jdbcType="INTEGER" />
    	<result column="Is_Parent" property="isParent" jdbcType="INTEGER" />
  	</resultMap>
  	<sql id="Base_Column_List" >
   	 ID, AreaLevel, Parent_Id, Name, Date_Insert, Date_Update, User_Insert, User_Changed, 
  	  Delete_Mark, Is_Parent
  	</sql>
  	<select id="selectById" resultMap="BaseResultMap" parameterType="java.lang.Integer" >
  	  select 
    	<include refid="Base_Column_List" />
   	 from base_country_area
 	 where ID = #{id,jdbcType=INTEGER}
	</select>

6、  	ALTER TABLE `service_apply`
	ADD COLUMN `Price_Mode` int NULL COMMENT 'Price_Mode为0表示一口价' AFTER `Totoal_Price`;

7、 	function goStep2(){
	mill=(parseInt(Math.random()*10000)).toString();
	url="${serverAddr}${cpath}/wservice/release?mill="+mill;
	location.href = url;
}

8、	request.getServletPath()   获取项目名后的路径 
9、	在方法参数的前面写上@Param("参数名"),表示给参数命名,名称就是括号中的内容
	public Student select(@Param("aaaa") String name,@Param("bbbb")int class_id); 
	给入参 String name 命名为aaaa,然后sql语句....where  s_name= #{aaaa} 中就可以根据aaaa得到参数值了


10、		<dependency>
			<groupId>com.xiaoyuer</groupId>
			<version>0.0.11-SNAPSHOT</version>
			<artifactId>xye-order-asset</artifactId>
			<exclusions>
				<exclusion>
					<artifactId>*</artifactId>
					<groupId>*</groupId>
				</exclusion>
			</exclusions>
		</dependency>
11、		date.getTime()所返回的是一个long型的毫秒数

12、    
		SELECT
		ra.ID, ra.Require_Info_ID, ra.User_Id,ra.Apply_Status,ra.Apply_Price, ra.Apply_Time,
		ra.description,ra.Require_Att_RealName, ra.Require_Att,ra.Fish_Food,ra.finish_time,
		ra.add_resume,ra.offer_bill,ra.Date_Insert, ra.Date_Update,ra.User_Insert,ra.User_Changed,
		ra.Delete_Mark,ra.Cell_Phone,ums.Server_Goal AS Server_Goal,ums.id AS user_goal_id
		FROM
		require_apply ra
		LEFT JOIN user_goal ums ON ums.User_ID=ra.user_id
		WHERE
		ra.Require_Info_ID =
		2337
		
			AND (ra.Apply_Status =2 OR ra.Apply_Status =4)
		
		
		ORDER BY (CASE ra.Apply_Status WHEN 2 THEN 1 WHEN 4 THEN 2 ELSE 0 END
		) DESC
		排序规则
 
13、		postman测试工具   google测试插件

14、		maven依赖jar但是没有在eclispe中导入项目也看不到源码，除非jar中有resource文件


15、 		try catch 快捷键   alt+shift+z

16、 		前台绑定内部类，不直接绑定内部类参数，先接收再传入

17、 		gameinfo 代码最新的但是远程的jar包不是最新的，才导致依赖找不到。


18、		request.getParameter() 是从浏览器传递到服务器中的参数
		request.getAttribute() 是服务器代码暂时保留在request的值，这些值在代码中通过setAttribute后才会有值

19、		优化查询效率		
		query.addFilterQuery("status:0 AND biz_type:1 AND class_id:1 AND xxx:123");  
		query.setQuery("xxx:123");  

20、		list添加数据时 引用类型要new一个新地址出来
21、 	  	sql语句查询精确查询id等字段需要#{ }，根据字段排序用${ }

。、
22、 		eclispe的workspace中有关联.git的插件，实现与git本地仓库的代码关联
23、		/**
		*注释内容		
		/别人引用下方属性时能看到注解信息
24、 		1+"" 和"1"是不一样

25、        	long a=0l
		a=b.geta()
26、 		The required Server component failed to start so Tomcat is unable to start.
		暂时重新设置下java环境变量就好了
27、 		alt+↑  代码上移
28、		变量放if里，影响代码结构和作用域
29、		传空数组 传null
30、 		@Value("${PAGE_RETURN_URL}")
		protected String returnUrl;属性直接取值
31、		alt+ shift+o 显示 选中的属性 高亮
32、		两个Integer变量不能直接==，需要intvalue（）后判断
33、		更新    UPDATE  pp_withdraw_limit_policy_config SET SINGLE_DAY_LIMIT=2000000,SINGLE_MONTH_LIMIT=2000000 WHERE id=1
34、		response.sendredirect(url);   对服务器的响应进行重定向。当server作出响应后，client客户端的请求的生存周期就终止了。这个时候再用request.getparameter()或request.getattribute()得到的只能是null。 
		response.sendredirect(“sendredirect.htm?name=sparkwu&e-mail=spark.wu@cobra-tech.com”) 这样可以传值  
35、		静态内部类可以直接创建对象new B.C();
		如果内部类不是静态的，那就得这样
		B b = new B();
		B.C c = b.new C();	 
36、		通过new 对象分方式中使用@value，无法获取项目属性值  
37、		<plugins>  
            	<plugin>  
                <!-- 自动重动 该工程在spring boot开发过程中非常有用，当工程文件发生变化的时候工程能够自动重启生效变化的内容 -->  
                <groupId>org.springframework.boot</groupId>  
                <artifactId>spring-boot-maven-plugin</artifactId>  
                <!-- <configuration> <fork>true</fork> </configuration> -->  
            	</plugin>  
        	</plugins>  

38、		<!---城市的关联查询--->
		<resultMap id="CitiesMap" type="com.xiaoyuer.core.dmo.BaseCountryArea">
  		<id property="id" column="id1"></id>
		<result property="name" column="name1"/>
		<result property="arealevel" column="Level1"/>
	 	 <association property="baseCountryArea" column="parentId1" javaType="com.xiaoyuer.core.dmo.BaseCountryArea">
	 	 		<id property="id" column="id2"></id>
	  		<result property="name" column="name2"/>
	  		<result property="arealevel" column="Level2"/>
	  		<association property="baseCountryArea" column="parentId2" javaType="com.xiaoyuer.core.dmo.BaseCountryArea">
		  		<id property="id" column="id3"></id>
		  		<result property="name" column="name3"/>
		  		<result property="arealevel" column="Level3"/>
		  		<association property="baseCountryArea" column="parentId3" javaType="com.xiaoyuer.core.dmo.BaseCountryArea">
			  		<id property="id" column="id4"></id>
			  		<result property="name" column="name4"/>
			  		<result property="arealevel" column="Level4"/>
	  		</association>
	  	</association>
	  	</association>
  		</resultMap>
  		<select id="selectCities" parameterType="java.lang.Integer" resultMap="CitiesMap">
  			select 
			bca1.id as id1,bca1.name as name1,bca1.AreaLevel as Level1,bca1.Parent_Id as parentId1,
			bca2.id as id2,bca2.name as name2,bca2.AreaLevel as Level2,bca2.Parent_Id as parentId2,
			bca3.id as id3,bca3.name as name3,bca3.AreaLevel as Level3,bca3.Parent_Id as parentId3,
			bca4.id as id4,bca4.name as name4,bca4.AreaLevel as Level4,bca4.Parent_Id as parentId4
			from base_country_area bca1
			LEFT JOIN base_country_area bca2 on  bca1.Parent_Id= bca2.ID
	
			LEFT JOIN base_country_area bca3 on  bca2.Parent_Id= bca3.ID
	
			LEFT JOIN base_country_area bca4 on  bca3.Parent_Id= bca4.ID
	
			where bca1.id=#{id,jdbcType=INTEGER}
  		</select>
		<!---城市的关联查询--->
		<!---这里是索引存储--->
		if (requireInfo.getDistrictId() != null) {
				BaseCountryArea baseCountryArea = baseCountryAreaMapper
						.selectCities(requireInfo.getDistrictId());
				while (baseCountryArea != null
						&& baseCountryArea.getBaseCountryArea() != null) {
					doc.addField("city", baseCountryArea.getName());
					baseCountryArea = baseCountryArea.getBaseCountryArea();
				}
			}
		<!---这里是索引存储--->

39、		"addServices": [
   
         	"2" ,"1"
  		]
		{ }内需要传键值对


40  		hashmap和treemap（有序）


41、            DecimalFormat 数字进行格式化类

42、		<![CDATA[文本内容]]>标记xml中作为纯文本
43、		alter table `pp_withdraw_order` change `Type` `TYPE` tinyint DEFAULT NULL 数据库更改字段名
		UPDATE  pp_withdraw_limit_policy_config SET SINGLE_DAY_LIMIT=2000000,SINGLE_MONTH_LIMIT=2000000 WHERE id=1

44、		<#if cardNo?exists && cardNo != "">
	    	AND card_no = :cardNo
	    	</#if>

45、流的输出 	
		String json="{\"requireCount\":\""+requireCount+"\"," +
				"\"serviceCount\":\""+serviceCount+"\"}";
		this.printDataText(response, json);
		// 自定义json 串或任意字符 调用方负责组装全部json串 或字符
		public void printDataText(HttpServletResponse response, String result) {
			response.setContentType("text/html;charset=utf-8");
			PrintWriter pw = null;
			try {
			pw = response.getWriter();
			pw.print(result);
			pw.flush();
			pw.close();
			} catch (IOException e) {
			e.printStackTrace();

			} finally {
			if (null != pw) {
				pw.close();
			}
			}
		}

46、          	git恢复先前的版本replace
47、 		java.lang.NoClassDefFoundError	 	找不到maven的依赖

48、		数据库操作的时候程序没有完成走完也可以用临时的数据操作，遇到事务回滚才会返回，否则顺利完成，*插入成功没数据 事务回滚

49、		<insert id="insertSelective" parameterType="com.xiaoyuer.core.dmo.RequireInfo" useGeneratedKeys="true" keyProperty="id">

50、		Spring MVC -- @PathVariable和@RequestParam   springboot--@PathPram和@QueryParam

51、		索引的与或过滤	
		String params = "(title:笔记 OR content:笔记) AND catalog_id:2";
		SolrQuery query = new SolrQuery();
		query.setQuery(params);

52、		m2eclipse首先查看是否能够从本地工程库中得到对应的maven依赖，如何存在，则将本地工程依赖进来；如何不存在，
		则从本地仓库/远程仓库中加载解析对应的jar包依赖。			jar打包目录根据项目路径包对应打包

53、		加载类的时候，默认执行无参构造，使用有参构造，则只执行有参构造

54、		创建一个public static final 类型的map 并初始化赋初值，，也可以通过Collections.unmodifiableMap(params)，实现不可更改。  
				静态常量
				public static final Map<String,String> map=new HashMap<String, String>();
				static{
					map.put("1", "a");
					map.put("2", "b");
					map.put("3", "c");
				}
				在别的类中进行修改，重新创建实例可以全局共享修改的数据map。同样静态字符串常量也是一样的。	

55、		solradmin中 sort= id desc实现倒序排序
		id:[533 TO *] 查询533之后的所有

56、          	maven的仓库管理软件――Sonatype Nexus搭建私服

57、		
		maven：
上传远程仓库
		<version>0.0.6-SNAPSHOT</version>
		<version>3.2.0.RELEASE</version> maven的两种版本管理稳定版和快照版，pom.xml中带release和snapshot的会自动打包拿到nexus相应的目录，其他不识别的打到release目录下，打包的时候需要大写SNAPSHOT才能到正确位置，小写会打到release库下，但是引用大小写都可以。
		<distributionManagement>
			<repository>
				<id>my-nexus-releases</id>
				<url>http://192.168.6.251:8087/nexus/content/repositories/releases/</url>
			</repository>

			<snapshotRepository>
				<id>my-nexus-snapshot</id>
				<url>http://192.168.6.251:8087/nexus/content/repositories/snapshots/</url>
			</snapshotRepository>
		</distributionManagement>
		snapshot实时，但不稳定，release版本则比较稳定。Maven会根据项目的版本判断将构件分发到哪个仓库。
		分发构件到远程仓库需要认证，需在settings.xml中配置认证信息：（nexus的账号和密码），其中server元素下id的值必须与POM中repository或snapshotRepository下id的值完全一致。将认证信息放到settings下而非POM中，是因为POM往往是它人可见的，而settings.xml是本地的。


58、		反编译软件jd-gui


59、		实现springboot的多环境的配置，对应的resource目录下有三个文件夹各有一个application.properties
		<profiles>
				<profile>
					<id>dev</id>
					<properties>
				<env>dev</env>
					</properties>
					<activation>
						<activeByDefault>true</activeByDefault>
					</activation>
				</profile>
				<profile>
					<id>sit</id>
					<properties>
						<env>sit</env>
					</properties>
				</profile>
				<profile>
					<id>pre</id>
					<properties>
						<env>pre</env>
					</properties>
				</profile>
				<profile>
					<id>prd</id>
					<properties>
						<env>prd</env>
					</properties>
				</profile>
			</profiles>
	
			<build>
				<plugins>
					<plugin>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-maven-plugin</artifactId>
	           		 <dependencies>
	               		 <!-- spring热部署-->
	               		 <dependency>
	                   		 <groupId>org.springframework</groupId>
	                    		<artifactId>springloaded</artifactId>
	                    		<version>1.2.5.RELEASE</version>
	                		</dependency>
	            		</dependencies>
					</plugin>
				</plugins>
				<resources>
					<resource>
						<directory>src/main/resources</directory>
						<includes>
							<include>application-words.properties</include>
							<include>*.xml</include>
						</includes>
					</resource>
					<resource>
						<directory>src/main/resources/${env}</directory>
						<includes>
							<include>application.properties</include>
						</includes>
					</resource>
				</resources>
			</build>

			直接使用xml
	<profiles>
		<profile>
			<id>dev</id>
			<properties>
				<webXmlPath>src/webxml/web-dev.xml</webXmlPath>
			</properties>
			<activation>
				<activeByDefault>true</activeByDefault>
			</activation>
		</profile>
		<profile>
			<id>pre</id>
			<properties>
				<webXmlPath>src/webxml/web-pre.xml</webXmlPath>
			</properties>
		</profile>
		<profile>
			<id>prd</id>
			<properties>
				<webXmlPath>src/webxml/web-prd.xml</webXmlPath>
			</properties>
		</profile>
	</profiles>


60、			<profile>中默认的激活属性配置
			<activation>
				<activeByDefault>true</activeByDefault>
			</activation>
61、			默认nexus不允许release重复部署
			
62、			属性文件的读取
			String filename = "com/luhy/test/ReadProperties.properties";  
        		Properties props = new Properties();  
       			props.load(ReadProperties.class.getClassLoader().getResourceAsStream(filename));  
       			String h = props.getProperty("v");  
			

63、			servletconfig.getInitParameter("port"),web.xml中配置的servlet属性可以这样读取
			 <init-param>
      				<description>port</description>
      				<param-name>port</param-name>
      				<param-value>8080</param-value>
    			</init-param>
64、			<build>
    				<!-- pojectName就是打包后的名称：pojectName.war -->
  				<finalName>pojectName</finalName>
			</build>		


65、			linux的常用命令 ：
			1、鼠标选中复制，右键黏贴
			2、cd..返回上级目录
			./startup.sh启动tomcat
			cd空格返回根目录
			cd空格..返回上级目录
			pwd-->示当前的工作目录（pwd:print working directory）
			find / -name dubbo-2.8.4a.jar查找某个文件
			tail -f  文件 可以实时follow日志信息
			ctrl+c 退出tail -f
			cd  / 退回到根路径
			find 查找
			:q!退出命令后加 ! 忽略提示   
			clear清屏
			mv abc.txt 1234.txt 重命名 
			rm -rf ../logs/ 删除logs以及目录下的所有文件  
			tar zxvf
				x : 从 tar 包中把文件提取出来
				z : 表示 tar 包是被 gzip 压缩过的，所以解压时需要用 gunzip 解压
				v : 显示详细信息搜索
				f xxx.tar.gz :  指定被处理的文件是 xxx.tar.gz

			ls和dir查看所有文件命令，more 查看具体的文件
			ctrl+shift+f  快速翻页
			CTL + b :上翻
			CTL + f : 下翻
			查找 ?或/   查找下一个  N前翻 n后翻 
			g第一行 G最后一行
			cp -r 文件夹1  文件夹2 复制到当前目录
			whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。只能用于查找文件
			which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置
			/etc/sysconfig/iptables linux需要在该文件中开放指定的端口才能对外访问
			开启指定的端口后，service iptbales restart更新配置
			nohup是永久执行
			&是指在后台运行
			tar -zxvf apache-rocketmq.tar.gz -C rocketmq/  解压文件到指定的目录
			kill -9 pid
			lsof -i :22 查看22端口被哪个进程占用


66、			多个tomcat实例运行：
			1、复制多个tomcat目录副本,catalina.bat中不需要改动
			修改startup.bat和shutdown.bat文件头下加，实现多个tomcat的运行
			SET JAVA_HOME=C:\Program Files\Java\jdk1.7.0_17
			SET CATALINA_HOME=D:\apache-tomcat-7.0.55-src
			SET CATALINA_BASE=D:\apache-tomcat-jenkins
			2、准备多套base_home的目录，公用一个catalina_home
			set "CATALINA_BASE=%cd%"  
			set "CATALINA_HOME=F:\apache-tomcat-7.0.69"  
			set "EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat"  
			call "%EXECUTABLE%" start 

			tomcat 的 catalina_home（安装目录） 和catalina_base（工作目录）


67、			solr中的doc=3581 就是需求id 也就是solr设置的主键


68、			嵌套的查询
			<select id="selectMaxApp" resultType="java.util.Date">
				SELECT
				require_apply.Apply_Time
				FROM require_apply
				where id =
				(
				select max(ID) as
				ID FROM require_apply WHERE
				Require_Info_ID=#{requireId}
				)
			</select>


69、  			权重排序，打分排序
			query.setParam("bf","addSerJJ^0.8 require_goal^0.6 recip(rord(deal_money),1.0,10000.0,10000.0)^0.1");
			bf="ord(popularity)^0.5 recip(rord(price),1,1000,1000)^0.3，一般也不这样用，简单的排序规则就可以了



70、			Utils.resultJson(response, new JSONObject().toJSONString());
			public static void resultJson(HttpServletResponse response, String jsonString) {
				PrintWriter pw = null;
				try {
					pw = response.getWriter();
					pw.print(jsonString);
					pw.flush();
					pw.close();
				} catch (IOException e) {
					e.printStackTrace();
				} finally {
					if (null != pw) {
				pw.close();
					}
				}
			}
			
				JSONObject jsonObject = JSONObject.fromObject(student对象);


71、			tomcat内存修改      -Xms256M   -Xmx512M   -XX:PermSize=128M   -XX:MaxPermSize=1024M

72、			maven release版本会本地有版本就只会依赖本地版本，不会再远程拉，没有本地才拉远程

73、			fl=*,score查询权重得分

74、			springboot中的@path要符合restful接口，方法的中的参数都要加相应的@标签才能获取

75、			getDeclaredMethod*()获取的是类自身声明的所有方法，包含public、protected和private方法。
			getMethod*()获取的是类的所有共有方法，这就包括自身的所有public方法，和从基类继承的、从接口实现的所有public方法。

76、			tomcat默认的访问文件夹是webapps下的root文件夹，tomcat首页也在这个文件夹中
			
77、			ctrl + k 和 ctrl + shift+k 快速定位

78、			<if test="id != null" >
			  where ri.ID = #{id}
	 		</if>

79、			timestampdiff(second ,lrp.Pay_time,now())>=#{time}	
			返回日期或日期时间表达式datetime_expr1 和datetime_expr2the 之间的整数差。其结果的单位由interval 参数给出

80、			相关知识整理
				
				
				创建一个public static final 类型的map 并初始化赋初值，，也可以通过Collections.unmodifiableMap(params)，实现不可更改。  
				静态常量
				public static final Map<String,String> map=new HashMap<String, String>();
				static{
					map.put("1", "a");
					map.put("2", "b");
					map.put("3", "c");
				}
				在别的类中进行修改，重新创建实例可以共享修改的数据map
				
				
				
				
				在启动Web项目时，容器会读web.xml配置文件中的两个节点<listener>和<contex-param>,容器会将读取到<context-param>转化为键值对,并交给ServletContext。
				容器对于web.xml的加载过程是context-param >> listener  >> fileter  >> servlet
				servletconfig可以getInitParameter获取web.xml中的初始化的参数值。
				
				
				
				
				
				spring分别提供了用于启动WebApplicationContext的Servlet和Web容器监听器，在web应用启动的时候来初始化WebApplicationContext:
				org.springframework.web.context.ContextLoaderServlet;
				org.springframework.web.context.ContextLoaderListener.
				
				配置例子如下：
				<context-param> 
				<param-name>contextConfigLocation</param-name> 
				<param-value>/WEB-INF/applicationContext.xml</param-value> 
				</context-param> 

				<listener> 
				<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> 
				</listener> 
				
	
				spring的启动过程：

				1、首先，对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境；

				2、其次，在web.xml中会提供有contextLoaderListener。在web容器启动时，会触发容器初始化事件，此时contextLoaderListener会监听到这个事件，其contextInitialized方法会被调用，
				在这个方法中，spring会初始化一个启动上下文，这个上下文被称为根上下文，即WebApplicationContext，这是一个接口类，确切的说，其实际的实现类是XmlWebApplicationContext。
				这个就是spring的IoC容器，其对应的Bean定义的配置由web.xml中的context-param标签指定。在这个IoC容器初始化完毕后，spring以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取；

				3、再次，contextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这个servlet可以配置多个，以最常见的DispatcherServlet为例，这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请求。DispatcherServlet上下文在初始化的时候会建立自己的IoC上下文，
				用以持有spring mvc相关的bean。在建立DispatcherServlet自己的IoC上下文时，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE先从ServletContext中获取之前的根上下文(即WebApplicationContext)作为自己上下文的parent上下文。有了这个parent上下文之后，
				再初始化自己持有的上下文。这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，大概的工作就是初始化处理器映射、视图解析等。这个servlet自己持有的上下文默认实现类也是mlWebApplicationContext。初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为Key，
				而是通过一些转换，具体可自行查看源码)的属性为属性Key，也将其存到ServletContext中，以便后续使用。这样每个servlet就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文(第2步中初始化的上下文)定义的那些bean。	


81、				ResourceBundle resourceBundle = ResourceBundle.getBundle("filters.redis"); 加载classpath下的属性文件获取，resourceBundle.getString("redis.port")直接获取属性文件中的值


82、				netstat -ano|findstr "8080"  查找系统当前端口号占用情况

83、				 <select id="selectByOrderStatus"  resultMap="BaseResultMap">
  				select  ro.*
  				from require_order ro 
				where ro.Status in
				<foreach item="item" index="index" collection="orderStatus" open="(" separator="," close=")">
        			#{item}
  				</foreach>
 				 </select>  


84、				SYSDATE() 数据库sql中获取系统的当前时间
				
				ALTER TABLE `service_apply`
				ADD COLUMN `Price_Mode` int NULL COMMENT 'Price_Mode为0表示一口价' AFTER `Totoal_Price`;


85、				final static常量String不能被重新赋值，只能被替换，替换不改变原来的值，而是返回这个新值
			
86、				select MAX(height) from users where height < (select MAX(height) from users );

87、			<![CDATA[AND (ri.Apply_End_Time- SYSDATE() )>0
		AND ri.`Is_Outline`!=1
		AND ri.Choose_User_Count < ri.Server_Count
		AND (ri.Require_Type!=3 OR ri.Apply_Count < ri.Server_Count)
		AND (ri.Status!=4 AND ri.Status!=5)]]>


88、		<foreach item="item" index="index" collection="idStr" open="("
			separator="," close=")">
			${item}
		</foreach>

89、		 #{depositNo,jdbcType=VARCHAR},制定数据类型


90、增值服务的传递参数类型问题
		<select id="selectByCodes" resultMap="BaseResultMap">
		select  ID, Code, Title, Description, Price, Fresh_Price, DeadLine, Type, Include, Number, 
    	Unit_Price from base_add_service_setting
		where 1=1
		<if test="codes!=null ">
			and Code in
			<foreach item="item" index="index" collection="codes" open="(" 
				separator="," close=")">
				#{item,jdbcType=VARCHAR}
			</foreach>
		</if>
		ORDER BY id DESC
	</select>
	
	<if test="types!=null and types.size>0">
	
		<select id="selectByCode" parameterType="java.lang.String" resultMap="BaseResultMap">
		select  ID, Code, Title, Description, Price, Fresh_Price, DeadLine, Type, Include, Number, 
    	Unit_Price from base_add_service_setting
		where 1=1
		<if test="code!=null ">
			and Code =#{code,jdbcType=VARCHAR}
		</if>
		ORDER BY id DESC
	</select>

91、	String val = new DecimalFormat("#0.0").format(12.08);数字转换
	String format1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(date);时间


92、	去除字符串中某个重复字段
	String b="加急 ,匿名,加急推送";
		String combine="";
		String[] c=b.split(",");
		
		
		for(int i=0;i<c.length;i++){
			if(combine.indexOf("加急")==-1||c[i].indexOf("加急")==-1){
				combine=combine+c[i];
			}else{
				combine=combine+c[i].replaceFirst("加急", "");
			}
		}


93、	eclipse-project-build automatically 改代码后自动的编译运行

94、	<select class="VAILD" 
			name="budgetType" 
			id="unitPriceII" 
			data-errorMsg="请选择预算费用" 
			data-group="4"
			value="${budgetType},${reqBudgetBean.toPrice}"
	>
		<c:if test="${budgetType==null}">
		<option value="-1"  selected="selected">请选择预算费用</option>
		</c:if>
		<c:if test="${budgetType!=null}">
		<c:if test="${budgetType==9}">
		<option value="${budgetType},${reqBudgetBean.toPrice}" >${ reqBudgetBean.description}${reqBudgetBean.fromPrice }元以上</option>
		</c:if>
		<c:if test="${budgetType!=9}">
		<option value="${budgetType},${reqBudgetBean.toPrice}" >${ reqBudgetBean.description}${reqBudgetBean.fromPrice }~${reqBudgetBean.toPrice}元</option>
		</c:if>
		</c:if> 
		<option value="-1">请选择预算费用</option>
		<c:forEach items="${requireBudget}" var="item">
		<c:if test="${item.id==9}">
		<option value="${item.id},${item.toPrice}" >${ item.description}${item.fromPrice }元以上</option>
		</c:if>
		<c:if test="${item.id!=9}">
		<option value="${item.id},${item.toPrice}" >${ item.description}${item.fromPrice }~${item.toPrice}元</option>
		</c:if>
		</c:forEach> 
	</select>
95、	linux下载地址  http://mirrors.melbourne.co.uk/ubuntu-releases/14.04/
96	$(#id)中不能带,号

97、	左关联的实例	
	SELECT
		* FROM
		(
		SELECT
		user_classify_score.user_id ,
		user_classify_score.id ,
		user_classify_score.class_id ,
		IF(user_base_info_ext.RunStatus IS
		NULL,0,user_base_info_ext.RunStatus) AS STATUS
		FROM user_classify_score
		LEFT JOIN user_base_info_ext ON
		user_base_info_ext.User_Id=user_classify_score.user_id
		WHERE
		user_classify_score.class_id=367 AND
		user_classify_score.user_id!=203
		ORDER BY FLOOR(send_count/2)
		ASC,class_scores DESC,service_scores
		DESC,credit_scores DESC
		)userc
		WHERE userc.status=0


98、java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for  mapper声明路径不对


99、		完整的ajax调用
		/**
		*取消修改
		*/
		function cancelModify(idStr) {
			if (idStr != null && idStr != '') {
				var url = "${serverAddr}${cpath}/require/release/" + idStr + "/canceledit";
				var option = {
					url : url,
					dataType:"json",
					type : "post",
					beforeSubmit : null,
					success : function(json) {
						if (json.data == "success") {
								XYE.Alert.alert({str:"取消成功",callBack : function(obj){
								$(obj).find('.cen_butgoon').click(function(){
								window.location.reload();
									});
								}}
							);				
						}else if(json.data == "failed"){
							alert("取消失败");
						}else{
							alert(data.result);
						}
					}
				};
				XYE.Alert.prompt( {
				str:"您确认取消修改吗？",
				success : function(obj){
				    jQuery.ajax(option);
				    return;
				}
				});
			}
		}
100、 			eclipse加大内存   			-Dmaven.multiModuleProjectDirectory=$M2_HOME -Xmx1524m  -XX:MaxPermSize=256M

101、 		count 和sum

102		主站和soa之间的地址访问时不是是否涉及跨域问题，controller中的调用接口，接口在spring-dubbo.xml中有注册，通过注册的地址，实现远程调用，并不是从前端页面直接跳转过来，不存在跨域问题
		soa服务化和主站对接   注册zookeeper，启动soa，主站依赖soa的api，通过jar引入主站的spring管理，通过dubbo配置，实现调用。
		
		
		跨域实现
		Tomcat下的配置 下载cors-filter-1.7.jar，java-property-utils-1.9.jar这两个库文件，放到lib目录下。（可在 http://search.maven.org上查询并下载。）工程项目中web.xml中的配置如下： [html] view plaincopy在CODE上查看代码片派生到我的代码片 <filter> <;filter-name>CORS</filter-name> <filter-class>com.thetransactioncompany.cors.CORSFilter</filter-class> <init-param> <param-name>cors.allowOrigin</param-name> <param-value>*</param-value> </init-param> <init-param> <param-name>cors.supportedMethods</param-name> <param-value>GET, POST, HEAD, PUT, DELETE</param-value> </init-param> 
		<init-param> <param-name>cors.supportedHeaders</param-name> <param-value>Accept, Origin, X-Requested-With, Content-Type, Last-Modified</param-value> </init-param> 
		<init-param> <param-name>cors.exposedHeaders</param-name> <param-value>Set-Cookie</param-value> </init-param> <init-param> <param-name>cors.supportsCredentials</param-name> 
		<param-value>true</param-value> </init-param> </filter> <filter-mapping> <filter-name>CORS</filter-name> <url-pattern>/*</url-pattern> </filter-mapping>

		还可以通过跳转controller中使用httpclient来实现访问，作为中间层来回调数据，这也是目前系统最稳定的方案。
		其他的还有方案是：jsonp 跨域浏览。


103、	
		增值服务去重
		String addSerString1="";
		String addSerString2="";
		String addSerString3="";	
		String addSerString="推送,加急推送,推送,推送,推送,匿名";
		String[] c=addSerString.split(",");
		for(int i=0;i<c.length;i++){
			String cc=c[i];
			if(addSerString1.indexOf("推送")==-1||c[i].indexOf("推送")==-1){
				addSerString1=addSerString1+cc; 
				addSerString2=addSerString2+cc+",";
				
			}else{
				addSerString1=addSerString1+cc.replaceFirst("推送", "");
				addSerString2=addSerString2+cc.replaceFirst("推送", ",");
				addSerString2=addSerString2.replaceAll(",,", ",");
				
			}
		}
		String replaceAll = addSerString2.replaceAll(",,", ",");
		String[] splits = replaceAll.split(",");

104、		</span><b>'+name+'</b></div>' name是js变量
		var name=$(this).parent().siblings('input').eq(1).val(); 获取同级第二个input元素

105、		edismax	
		query.setQuery(keyField + ":" + xyeSolrParam.getQueryStr());
		query.set("qf", keyField + "^2");

106、		StringUtils.isNotEmpty（）  java字符串判空工具类

107、		属性文件载入容器管理
		<bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"> 
   			<property name="locations"> 
   			 <list> 
     			<value>classpath: conf/sqlmap/jdbc.properties </value> 
    			</list> 
   			</property> 
			</bean>

			<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"> 
			<property name="driverClassName" value="${jdbc.driverClassName}" /> 
   			<property name="url" value="${jdbc.url}" /> 
   			<property name="username" value="${jdbc.username}" /> 
   			<property name="password" value="${jdbc.password}" /> 
		</bean>

		标签引入<context:property-placeholder location="classpath:jdbc.properties" />



108		关联自身表查询
		//查询技能标签
		<select id="getUserClass" resultMap="ResultMapName" parameterType="java.lang.Integer">
				select
				user_classify.* ,bc1.Name as className1
				,bc2.Name as className2
				,bc3.Name as className3 
				FROM user_classify
				LEFT JOIN
				base_classify bc1 ON
				bc1.id=user_classify.Class_Id_1
				LEFT JOIN
				base_classify bc2 ON
				bc2.id=user_classify.Class_Id_2
				LEFT JOIN
				base_classify bc3 ON
				bc3.id=user_classify.Class_Id_3
				WHERE
				user_classify.User_Id=#{userId}
		</select>
		//查询技能标签

109、		数据库查询空字段使用is null，数据库的模糊查询like		
		select * from where 字段名 like '%"+str1+"%'; 查询变量      			concat(concat('%',#{username}),'%')
		SELECT * FROM user_base_info WHERE cell_phone LIKE '%/_%' ESCAPE '/'

110、		mybatis generator 源码会默认设置追加属性为ture

111、		redis-cli.exe -h IP -p 6379,  这个要在redis-cli.exe 所在目录下面，-h后面接redis服务器的IP地址，-p后面接端口，  一般没做过修改redis.conf情况下端口是6379

112、		solr搜索的schema.xml中的id（主键，不可重命名），默认是doc的主键

113、		 	默认的servlet加载顺顺序
			<servlet>
    			<description>spring mvc servlet</description>
    			<servlet-name>springMvc</servlet-name>
    			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    			<init-param>
     			 <description>spring mvc 配置文件</description>
     			 <param-name>contextConfigLocation</param-name>
      			<param-value>classpath:config/spring-mvc.xml</param-value>
    			</init-param>
    			<load-on-startup>1</load-on-startup>
  			</servlet>
 	 		<servlet-mapping>
    			<servlet-name>springMvc</servlet-name>
    			<url-pattern>/</url-pattern>
  			</servlet-mapping>

		<context-param>
   		 <param-name>contextConfigLocation</param-name>
    		<param-value>classpath:config/spring.xml,classpath:config/spring-mybatis.xml,classpath:config/spring-dubbo.xml</param-value>
  		</context-param>	

114、		1.启动一个WEB项目的时候,容器(如:Tomcat)会去读它的配置文件web.xml.读两个节点: <listener></listener> 和 <context-param></context-param>
		2.紧接着,容器创建一个ServletContext(上下文),这个WEB项目所有部分都将共享这个上下文.

115、 		关联的问题
		<resultMap id="ResultMap2" type="com.xiaoyuer.model.RequireAdditionService"
		extends="BaseResultMap">
		<association property="baseAddServiceSetting" column="Base_Addser_Id"
			javaType="com.xiaoyuer.model.BaseAddServiceSetting">
			<id property="id" column="Base_Addser_Id"></id>
			<result property="title" column="Title" />
			<result property="description" column="Description" />
			<result property="price" column="Price" />
			<result property="code" column="Add_Ser_Code" />
			
		</association>
		</resultMap>

116、		    protected void doPost(HttpServletRequest req, HttpServletResponse resp)  
            		throws ServletException, IOException {  
        		//获取servlet初始化参数:  
        		String initParam = getServletConfig().getInitParameter("initParam");  
        		System.out.println("initParam: ---->" + initParam);  
       		 	//获取全局初始化参数:  
        		String contextParam = getServletContext().getInitParameter("contextParam");  
        		System.out.println("contextParam: ---->" + contextParam);  
        		//获取用户提交过来的数据:  	
			String username = req.getParameter("username");  
        		String password = req.getParameter("password");  
        		System.out.println("用户提交的数据:" + username + " , " + password);  
    		} 


		<init-parm>配置在<servlet>标签中,用来初始化当前的Servlet的,属于当前Servlet的配置,因此存放在servletConfig对象中;
       		 通过getServletConfig().getInitParameter("initParam")的方式获取;
		<context-param>直接配置在web.xml的<web-app>标签中,属于上下文参数,在整个web应用中都可以使用,它是全局的,因此存放在servletContext对象中(即application对象);
        	通过getServletContext().getInitParameter("contextParam")的方式获取;
		<context-param>搭配ContextLoaderListener监听类使用，是spring默认的初始化容器的监听类，默认是 WEB-INF/applicationContext.xml下的路径，可以通过<context-param>自由配置路径	

		getServletContext()取得的是 <context-param>配置的参数 
               	getServletConfig()取得的是 <servlet> <init-param>配置的参数

117、		Servlet和Filter是可以配置mapping的，即针对哪些地址的请求使用这些Servlet或者Filter，而Listener则是根据实现接口来判断什么情况下调用这个Listener的，
		基本的Listener仅仅在启动时执行一些任务。如果一个请求，同时调用到这三个，则执行顺序是：context- param -> listener -> filter -> servlet 

118、		继承自 SqlSessionDaoSupport后，数据处理	
		BaseDict bt = new BaseDict();
		List<Object> list = dataDictService.selectByObject(bt,BaseDictMapper.class);
		BaseMapper baseMapper = (BaseMapper)sqlSession.getMapper(object);
		return baseMapper.selectByObject(entity);

119、		web.xml 启动停止监听类
		ServletContextListener 接口，它能够监听 ServletContext 对象的生命周期，即监听 Web 应用的生命周期。
		当Servlet 容器启动或终止Web 应用时，会触发ServletContextEvent 事件，该事件由ServletContextListener 来处理。在 ServletContextListener 接口中定义了处理ServletContextEvent 事件的两个方法。
		* 当Servlet 容器启动Web 应用时调用该方法。在调用完该方法之后，容器再对Filter 初始化， 并且对那些在Web 应用启动时就需要被初始化的Servlet 进行初始化。 contextInitialized(ServletContextEvent sce)   
 		* 当Servlet 容器终止Web 应用时调用该方法。在调用该方法之前，容器会先销毁所有的Servlet 和Filter 过滤器。 contextDestroyed(ServletContextEvent sce)  
		在Container 加载Web 应用程序时（例如启动 Container 之后），会呼叫contextInitialized() ，而当容器移除Web 应用程序时，会呼叫contextDestroyed () 方法。

120、		web.xml中 处理内存泄漏的问题
		JDK中的java.beans.Introspector类的用途是发现Java类是否符合JavaBean规范，专门用来处理Introspector内存泄漏问题的辅助类。如果有的框架或程序用到了Introspector类,那么就会启用一个系统级别的缓存,此缓存会
　  		存放一些曾加载并分析过的JavaBean的引用。当Web服务器关闭时,由于此缓存中存放着这些JavaBean的引用,所以垃圾回收器无法回收Web容器中的JavaBean对象,最后导致
     		内存变大。IntrospectorCleanupListener会在Web服务器停止时清理Introspector缓存,使那些Javabean能被垃圾回收器正确回收。Spring自身不会出现这种问题，因为Spring在加载并分析完一个类之后会马上刷新
     		JavaBeans Introspector缓存,这就保证Spring中不会出现这种内存泄漏的问题。但有些程序和框架在使用了JavaBeans Introspector之后,没有进行清理工作(如 Quartz,Struts),最后导致内存泄漏
		<listener>
    		<listener-class>org.springframework.web.util.IntrospectorCleanupListener</listener-class>
 	 	</listener>
 
121、		项目中的mapper，和xml通过spring-mybatis.xml注入容器，一般的interface和impl通过@service注入+扫描包注入容器，java的实体类没有注入容器管理
		依赖的api通过dubbo.xml注入容器，并通过zookeeper的地址实现调用，filter过滤属性文件到resource下的属性文件后，通过注入容器，可以直接在xml中使用，也可以通过属性文件的加载读取（加载方式为流读取）。

122、		@Component 注释外，还定义了几个拥有特殊语义的注释，它们分别是：@Repository、@Service 和 @Controller。@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注

123、		释放jdbc连接-------[14:02:32] DEBUG datasource.DataSourceUtils "Returning JDBC Connection to DataSource"
[14:02:32] DEBUG datasource.DataSourceUtils "
		取回jdbc连接-------Fetching JDBC Connection from DataSource"
2017-03-22 14:02:32.630 [http-bio-8080-exec-3|]
		使用jdbc链接-------DEBUG c.x.c.d.U.getServiceTops-ooo Using Connection [com.mysql.jdbc.JDBC4Connection@3e57601]
2017-03-22 14:02:32.630 [http-bio-8080-exec-3|]
		sql查询------------DEBUG c.x.c.d.U.getServiceTops-==>  Preparing: select se.Id as id, se.Service_Image_Att as img, se.Serv_Code as code, se.Serv_Title as title, se.Per_Price as price, se.Cash_Uint as uint, se.Apply_Count as applyCount, se.Self_Cash_Uint as seltUint, ui.Nick_Name as nickName, ui.id as userId, bsa.Name as cityName from user_service_collection us left JOIN service_info se ON us.Service_Id=se.ID left JOIN user_base_info ui on ui.id=se.User_Id left JOIN base_country_area bsa ON se.City_Id=bsa.ID where us.User_ID = ? order by us.id desc limit 0,9 
2017-03-22 14:02:32.630 [http-bio-8080-exec-3|] DEBUG c.x.c.d.U.getServiceTops-==> Parameters: 1427(Integer)
[		14:02:32]
	 	释放jdbc连接-------DEBUG datasource.DataSourceUtils "Returning JDBC Connection to DataSource"
2017-03-22 14:02:32.641 
		启用dubbo连接------[DubboClientHandler-192.168.6.85:20881-thread-6|] DEBUG c.a.d.r.transport.DecodeHandler- [DUBBO] Decode decodeable message com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcResult, dubbo version: 2.8.4x-SNAPSHOT, current host: 192.168.6.31
[14:02:32] 
		空指针错误---------ERROR usercenter "java.lang.NullPointerException"

124、		跨系统之间的数据类传输需要序列化处理，特点是保持对象的属性状态。但不是每个类都可序列化，例如涉及线程的类与特定JVM有非常复杂的关系。

125、		依赖的jar是如何加入spring管理 引入的jar包需要包名统一为com.包，通过spring.xml扫描配置注入容器，再通过springdubbo.xml实现服务化的调用
		ConcurrentHashMap里面put(requestID, callback)
		dubbo的并发调用会传递requestID，保证唯一性


126、		.gitconfig 文件下需要配置[receive]
    denyCurrentBranch = ignore才能远程提交
		git的两个仓库之间传输，需要两个仓库独立存在，pull 和push通过url连接，push需要更新后才能执行
		git提交到本地仓库以后可以revert远程版本实现回退

127、		request.getRequestDispatcher("/list.jsp").forward(request, response); 
		提交的request做处理完了，分发到下一个JSP页面或者下一个Action继续处理。会有forward()和redirect()两种情况，forward()是request中的参数继续传递，redirect()则是重新生成request了。

128、		Spring Boot应用程序在启动后，会遍历CommandLineRunner接口的实例并运行它们的run方法，实现启动类的加载，从容器中寻找。

129、		大数据处理	BigDecimal	处理类似科学计数法的大数据类  new BigDecimal(大数据).toString()；

130、		final static String 常量类不能放在主函数内 共享常量   方法里声明变量是私有的

131、		netstat -aon|findstr "49157" 查看端口的占用情况，然后任务管理器pid对应的进程

132、		solr工程可以使用单核和多核的配置，

133、		默认情况下，solr的日志是瞬时的，tomcat重启后，就消失了。引入相应的日志jar后，在solr-4.5.1.war的WEB-INF下建classes目录，在该目录创建文件log4j.properties，即可生成日志文件。
		一般我们是在使用solrj的系统中增加日志捕获异常并输出日志，不在solr工程增加。

134、		通过vars下的properties过滤到.xml下的读取直接用$[]读取，通过属性文件的加载配置PropertyPlaceholderConfigurer读取的使用${}读取

135、		SQL中select round(123.456,2)	123.46	返回数字表达式并四舍五入为指定的长度或精度。
		sql中ifnull（a,0）若a非null，返回a，否则返回0

136、		比较		Date signDate = DateUtil.parseDate(userSigninCount.getSigningDate(), "yyyy-MM-dd");
					Date currentDate=DateUtil.getCurrentDateDate("yyyy-MM-dd");
					if(currentDate.compareTo(signDate)==0){
						//已签到
						return true;
					}

137、		不同环境的问题，有配置和tomcat集群的问题

138、		java反射用例中，setAccessible(true) 并不是将方法的访问权限改成了public，而是取消java的权限控制检查。所以即使是public方法，其accessible 属相默认也是false
		利用反射，可以使用BeanUtils.copyProperties()来复制属性，对象的名称要匹配，不匹配不转，复杂属性类型需一致，否则argument type mismatch，常规属性类型的可以不一致，复杂类的属性复制，this.value=value全属性覆盖
		PropertyUtils的工具类，它也提供copyProperties()，并且还提供类型转换的功能，但两者都不支持date类型，这种的速度相对要慢
		反射本身的field可以直接设置，也可以通过setMethod.invoke()设值

139、		configfilter数据库加密   	java -cp druid-1.0.16.jar com.alibaba.druid.filter.config.ConfigTools you_password   1.0.16版本加密默认带有公钥，私钥。1.0.13版本默认不带公钥。
		通过设置<property name="filters" value="config" />
			<property name="connectionProperties" value="config.decrypt=true;config.decrypt.key=$[xye_jdbc_publicKey]" />来解密。
		加密的带公钥的需要传入公钥，未公钥加密的不需要传入公钥。

140、		传参是map类型的查询语句，Map<String,Object> map = new HashMap<String,Object>();Integer updateFishfoodActiveByUserId(@Param("map")Map<String,Object> map);
		 <update id="updateFishfoodActiveByUserId" parameterType="java.util.Map" >
  			update 
  				user_base_account
  			set 
  				fishfood_active = #{map.fishfoodActive,jdbcType=INTEGER}
  			where 
  				user_id = #{map.userId,jdbcType=INTEGER}
  		</update>

141、		两种查看项目地址的方式：1、preference-git-configuration-repository  2、项目右键查看git respository，查看properties。

142、		依赖的jar是如何加入spring管理 ，spring加入容器管理：通过注解标签+扫描路径的方式。

143、		资金归集生产问题，1、tomcat下prd实时日志，根据错误1、反序列化失败，2、redis获取null重新登陆，3、userbankcard中也有系统账户号，取消过滤即可。
		测试prd更改，直接将com.xiaoyuer.pay.web.controller.gateway.WithdrawController.class（在对应工程的target下的jar）的文件夹放到tomcat下的classes下，虽然依赖的jar中有这个类，但是会优先使用classes下的文件。

144、		modelMap.put(key,value)添加重复的key，会覆盖原来的值.

145、		linux中的文本中?查找
146、		ftl中的注释用<#-- -->
147、		HTTP Status 400 - Required String parameter 'pwd' is not present
148、		后台接受参数诗意前台jsp页面的那么属性来获取的。

149、		自定义标签的常用输出方法：pageContext.getOut().print("Hello Tag!!!");  
		<c:if test="${!fn:contains('nihao','k')}">
		不包含
		</c:if>
		this.pageContext.setAttribute(var, Constants.XYE_PAYCORE_HOSTS); 前段页面的属性赋值

150、		git历史库中可以新建tag使用，并

151、		// 手机号码校验，使用正则表达式判断
		Pattern p = Pattern.compile("^17[\\d]{9}|13[0-9]{9}|15[012356789][0-9]{8}|18[\\d][\\d]{8}|147[0-9]{8}$");
		Matcher m = p.matcher(cellPhoneNum)

152、		修改本地数据库的密码，关键的地方是需要关闭进程中的mysql和停止服务中的mysql。cmd中执行sql语句需要加；
		数据库的导入，选中库执行sql。sql中只有表的相关操作。

153、		数据库的操作是原子性的，是单线程的，代码对象的更新数据库，在多人同时操作的时候，有可能出现高并发的问题。

154、		jenkins打包的maven  release版本需要删除maven库中的，重新拉取。

155、		js的var变量在定义在函数外面的时候再页面加载好了之后就会赋值，定义在函数里才是实时数据（全局变量除外）。

156、		FileOutputStream fs = new FileOutputStream(outPath);//实例了文件输出流，参数是文件输出路径
		OutputStreamWriter ow = new OutputStreamWriter(fs,"UTF-8");//在写输出流的时候做编码格式转化，以免乱码！
		BufferedWriter bWriter = new BufferedWriter(ow);//将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入	

		（1）以utf-8的格式构造一个文件输出流FileOutputStream，（2）然后将这个文件输出字符流封装成字节输出流OutputStreamWriter，（3）然后将这个字节输出流封装成缓冲字节输出流。	

157、		maven    jar重复打包失败，切换版本再打回来。

158、		开源中国  	http://www.oschina.net

159、		一般的jar是不让看到源码的，fastjson-1.2.2-sources.jar，jar包中加入类似的sources文件就可以看了

160、		忘记本地数据库 
		1、cmd mysql的bin目录下
		mysqld --skip-grant-tables
		2、重开cmd ，bin目录下mysql，进入

		修改mysql的root密码后，出现Host 'localhost' is not allowed to connect to this MySQL server 错误。

		解决办法：
		C:\Program Files\MySQL\MySQL Server 5.5\my.ini
		在[mysqld]下加下面两行，
		skip-name-resolve
		skip-grant-tables
		重启mysql的windows服务
	




161、		修改数据库字段的编码    
		1.网上查到一段代码可以直接修改 已经测试过（可以使用） 留作参考

		ALTER TABLE my_user CHANGE username username VARCHAR(18) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT ”;

		2.最简单的一个办法

		在SQLyog中选择 表 右键改变表右侧有一个 隐藏语言选项 取消即可 进行修改 

162、		Multiple SCMs Plugin使用 jenkins同时打包两个git项目


163、		solr异常解决
		1.SolrException: Error loading class 'solr.VelocityResponseWriter'
		vi /usr/local/tomcat/solr/collection1/conf/solrconfig.xml
		<queryResponseWriter name="velocity" class="solr.VelocityResponseWriter" enable="${solr.velocity.enabled:true}"/>注释或者disabled - enable:false即可
		重启Tomcat

		2.org.apache.solr.common.SolrException:org.apache.solr.common.SolrException: Error opening new searcher
		清空索引
		# cd /usr/local/tomcat/solr/collection1/data/index
		# rm -rf *


164、		eclipse中的tomcat找不到war工程
		The given project is not a virtual component project   让我改property >  Myeclipse> project  facets 

165、		logback中的		private static Logger logger = LoggerFactory.getLogger("test"); 
					 <logger name="test" >
					<level value="error" />
					<appender-ref ref="FILE" />
					<appender-ref ref="STDOUT" />
					</logger> 
			会默寻找 name相符合的log名称，找不到会默认继承根log，打日志

		lo4j中的日志设置		log4j.logger.packag1= info, packag1    默认packag1包下类和"packag1"的字符串

		protected static final Logger logger = Logger.getLogger(""); 参数只可能是1-字符串，2-*.class类，1就字符串匹配packag1名；2就作为类需要在packag1包下

166、		ajax局部刷新页面案列
			<div id="context"></div>
	
			function toView1(act){
			var url = "${ctx}/admin/incomeCollect/toView1?act="+act;
			var option={
				url:url,
				type:"post",
				target:"#context",
				beforeSubmit:null,
				success:function(){	
				}
			};
			$("#queryInfoForm").ajaxSubmit(option);

			@requestMapping(value="/toView")
			ModelAndView mv = new ModelAndView("admin/userbill/incomeCollect/toIncomeView");	
			return mv;

167、	The content of element type "select" must match "(include|trim|where|set|foreach|choose|if|bind)"
	<IF>标签需要小写
168、	order by IF(ISNULL(my_field),1,0),my_field;  

169	group by的实际用例
	SELECT a.price AS Price,a.ordertype AS OrderType,a.r_date1 AS r_date,rd.total_price AS Total_Price,ba.title AS base_add_title,ui.nick_name AS nickName FROM 
	(
	SELECT po.price AS Price,po.ordertype AS OrderType,po.Date_Insert AS r_date1,po.Require_Service_Id AS Require_Service_Id,po.User_Id AS User_Id FROM platform_order po 
	WHERE po.ordertype IN ('RFJFW') AND po.Price > 0 AND po.OrderStatus = 0 
	AND po.Date_Insert >= '2017-01-01 00:00:00.0' 
	AND po.Date_Insert <= '2017-12-31 23:59:59.0' 
	GROUP BY po.Require_Service_Id 
	)a 
	LEFT JOIN require_addition_service rd ON a.Require_Service_Id=rd.Require_Info_Id 
	LEFT JOIN user_base_info ui ON a.User_Id=ui.id 
	LEFT JOIN base_add_service_setting ba ON rd.Add_Ser_Code=ba.code 
	WHERE 1=1 AND (rd.status=1 OR rd.status IS NULL ) AND rd.Add_Ser_Code = 'PBBJ' ORDER BY r_date DESC LIMIT 0,15  

	判null实现
	IFNULL(sum(apply_amount),0)

170、	form参数绑定
	<form:form id="queryInfoForm" modelAttribute="platformOrder">
	<span>类型：</span>
	<form:select path="addSerCode" id="addSerCode">
		<option value="" selected>全部</option>
			<c:forEach var="addType" items="${addSers}" varStatus="addVsType">
				<c:choose>
			             <c:when test="${addType.key==platformOrder.addSerCode}">
					  <option value="${addType.key}" selected="selected">
						 ${addType.value}
					   </option>
						 /c:when>					
					 <c:otherwise>
					 <option value="${addType.key}">
						 ${addType.value }
					 </option>
				      </c:otherwise>
				</c:choose>
			</c:forEach>				
		</form:select>
		 <input type="submit"  class="bth" value="查询" />
		div id="partlist"></div>
 	 </form:form>

171、	<c:forEach var="addType" items="${addSers}" varStatus="addVsType">
	varStatus.index 从0开始的索引
	varStatus.count	从1开始的计数
172、	<label>
		点点看<br>
		<input type='button'></input>
		<input type='button'></input>
	</label>

	label标签没有for属性会默认制定第一个button

173、	maven依赖中出现依赖不一致的情况，可能出现了两次以上的maven依赖，maven出现！情况，但是jar引用存在，多是因为jar中缺少相关代码，打包与工程对应的正确的jar即可。
174、	library 和lib区别
		library是用来编译里面的src中java文件的
		部署到tomcat时,仅仅只复制了WEB-INF/lib里面的jar包,
		出现eclipse可以正常编译但tomcat运行是找不到类

175、
	 JSP,Servlet获取前一个请求的url路径
	 pageContext.getRequest().getAttribute("javax.servlet.forward.request_uri")
	 经常用在分页中的下一页传递一个page过去即可。

176、	pw.print("{\"result\":\"" + result + "\"}"); json串的转义输出

177、	使用@responseBody标签直接返回json数据，需要引入两个jar包 jackson-core.jar，jackson-databind.jar

178、	手动获取spring的ApplicationContext和bean对象    写一个工具类实现ApplicationContextAware接口,并将这个加入到spring的容器，具体方法网上有

179、	Field对于到一个成员对象, 这个和类定义是相关的.如果Field拿到的是static, 则get(null)取得当前field的值.
	如果Field是一个实例成员对象, 那么我们传入一个 对象实例, 拿到对象实例 的实例成员 的值. 案例代码如下：	
	
	Field f=Counter.class.getField("count"); //拿到Counter类的count 实例域
	Counter c=new Counter();                 //一个Counter对象实例
	Long l=(Long) f.get(c);                  //拿到对象实例的 域成员的值


180、	查询语句 order by要放在最后 

181、	BigDecimal bg = new BigDecimal(d).setScale(2,  BigDecimal.ROUND_HALF_UP); double四舍五入保留2位小数

182、	poi 实现excel的导出功能。

183、	代码改动没反应，删除classes下的文件，在项目buildpath，把源码src添加进来就可以了

184、	java对象转为json格式 需要引入json-lib jar包，以及以几个jar 	JSONObject.fromObject()
	json对象转为java对象						JSONObject.toBean(jsonObject, Student.class)
				commons-lang 2.5
				commons-beanutils 1.8.0
				commons-collections 3.2.1
				commons-logging 1.1.1
				ezmorph 1.0.6

185、	xml中<![CDATA[ ]]>标记的作为纯文本，编辑器忽略编译，但是一般不把<if>标签包括在内，包含sql语句部分即可。
 
186、	一般jsp文件不放在web-inf下  	web.xml放在web-inf下

187、	<url-pattern>/</url-pattern>  会匹配到/login这样的路径型url，不会匹配到模式为*.jsp这样的后缀型url
	<url-pattern>/*</url-pattern> 会匹配所有url：路径型的和后缀型的url(包括/login,*.jsp,*.js和*.html等)

188、	配置mvc视图解析的时候，默认配置视webapp下的路径，配置到/jsp下就可以了

189、	redis加入环境变量并配置开机启动
	将D:\redis加入系统环境变量;使用sc create redis binpath= "D:\redis\redis-server.exe redis.conf" displayname= "redis" start= auto 
	命令注册windows服务使其开机启动。

190、	 版本的上线合并使用tag ，代码暂时保存需要切换其他分支做点事使用stash，stash会暂存当前的工作区内容，然后将工作区内容保持和上次提交相同，做完切换回来再恢复stash即可
	
191、	springboot搭建	

	1）、springboot默认contextpath的路径为/,部署在了root下       @RestController =@Controller +  @ResponseBody  

	2）、springboot支持需要添加tomcat-jsp解析包
        	<dependency>
            		<groupId>org.apache.tomcat.embed</groupId>
            		<artifactId>tomcat-embed-jasper</artifactId>
        	</dependency>
	3）、springboot的入口类 如果按官方的项目结构加上@SpringBootApplication即可，自定义特殊的目录结构需要加上自动配置和扫描等标签
	4）、 sprinboot工程maveninstall失败，unable to find a main class，pom中指定启动类即可
		 <properties>
        		<start-class>com.boot.Application</start-class>
        		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        		<java.version>1.7</java.version>
   		 </properties>
	5）、springboot整合mybatis需要引入数据库连接依赖，主要是配置sqlsessionfactory（注入datasource目前是application中配置，内含*mapper.xml配置，@Configuration和
		@EnableTransactionManagement(proxyTargetClass=true)）和mapper扫描（需要在sqlsessionfactory配置完成之后，@Configuration和@AutoConfigureAfter(MybatisConfig.class)），
		具体实现是mybaitsConfig.java和mapperScanner.java，   	
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
		</dependency>
	6）、springboot也支持xml配置，在启动类上加上@ImportResource({"classpath:config/spring-mvc.xml"})即可注入配置 ，配置spring-mvc 建议使用官方的xml头文件
        	

192、	一般java代码都放在src-main-java下  src-main-resources下的的一般放xml等配置文件
	java文件无法导入相应的类，出现the resource is not on the build path问题，右键重新build src即可。出现问题的时候java文件的图标也是相对不一样的


193、	创建web工程的时候，project facets是web工程的一个重要属性，可以选择相应的web和java版本
	
194、	部署tomcat的时候 Project facet Dynamic Web Module version 3.0 is not supported. 这个dynamic web module version是与servlet版本有关的，
	若使用tomcat7.0，一般是3.0；若tomcat6，则一般是2.4或2.5.选择Navigator选项卡，打开org.eclipse.wst.common.project.facet.core.xml，修改相应版本即可


195、	select id,group_concat(name) from aa group by id; 以id分组，把name字段的值打印在一行，分号分隔
	GROUP_CONCAT(bass.ID) AS addSer
	GROUP BY requireId
	搭配使用  

196、	spring.xml和spring-mvc.xml中配置的是不同的上下文，service交给spring管理，conroller交给spring-mvc管理，两个xml中的各自配置各自的属性文件，否则对应的访问不到，controller中的注入的bean一定要是spring-mvc.xml中注入的的bean
	配置多个PropertyPlaceholderConfigurer时 重点是：ignoreUnresolvablePlaceholders属性需要设置为true

197、	netstat -aon|findstr "9443"  查看端口占用情况，找到pid，关闭进程中对应的进程即可
	以左边的local地址为主，查看进程pid

198、	nginx可以监听80端口将不同域名绑定到tomcat上的不同端口的不同项目

199、	eclispe部署到root下放入的方案
	1）、部署的路径是webapps下，工程的名字改为root，这种测试中比较快
	2）、解压war工程到root下，运行tomca即可，这个一般linux自动部署方法
	3）、改变工程访问路径   
	server.xml 中 <Context path="/" docBase="XiaoyuerProject" debug="0"  reloadable="false"></Context> 
	这个和web project setting中设置context root是一致的，倾向后者，在双击tomcat中的modules中也可以设置

200、	bean的注入失败情况
	
	1.对应要注入的实现类没有 加注解，如dao层 @Repository  如service层  @Service

	2."You generally autowire to your interface type and not impl."调用的接口是否有具体的实现类。

	3.@Autowired下面，没有类，直接跟了@RequestMapping。【我的是直接跟了method，显示无法注入method，导致不识别的No qualifying bean of type [java.lang.String] found for dependency错误，】	

201、	手机的html在root下访问不了，原因是root下的内容不干净，混有ids的工程

202、	nginx是监听的本地ip，所以要改host文件域名，搭配使用，默认http是80端口，https是443端口，浏览器默认不显示端口域名，不得使用已经注册的域名。


203、	init()方法，然后用@PostConstruct 需要搭配@Component并被spring扫描到才行，启动时执行初始化

204、	正常类中@Override 时出错误，因为你的Compiler 是jdk1.5，只要把它改为 1.6

205、	filter类实现filter接口即可，在web.xml中配置，其中共有三个方法 
	1）、init（）是在启动项目的时候进行初始化
	2）、dofilter（）是在拦截打匹配的路径时候进行处理，处理完用chain.doFilter(request, response)进行继续访问请求
	3）、destroy（）当应用服务被停止或重新装载了，则会执行Filter的destroy方法，Filter对象销毁。比如改动项目的代码重新reload时候（Reloading Context）
  
206、	spring工具类AntPathMatcher， boolean result = new AntPathMatcher().match(patternPath, requestPath) 校验路径是否匹配

207、	httpServletRequest.getRequestURI()== getContextPath() + getServletPath() + getPathInfo()

208、	AtomicInteger提供原子操作来进行Integer的使用，通过线程安全的方式操作加减，因此十分适合高并发情况下的使用。但是效率相对低，高并发适用。

209、	modelAttribute使用时需要在进入jsp和跳转自jsp的controller中都要绑定相应的参数。

210、	在表单交时候，用get方法提交时 表单里德数据会把你的url里的参数给挤掉。 post下不会。

211、	拦截顺序，拦截路径的时候，先进入filter的dofilter()方法，在进入intercepor的prehandle()方法
	
	
212、	requestUrl：https://www.yu.com/ids/login?redirectUrl=http://www.yu.com/XiaoyuerProject/&method=GET
	location /ids {
            proxy_pass https://192.168.6.222:9446/ids;
        }
		
	location ids/login {
           proxy_pass https://192.168.6.222:9446/ids/login;
 }
	location /login {
           proxy_pass https://192.168.6.222:9446/ids/login;
 }    主站登录优化用
	nginx反向代理原则是，优先匹配全路径，然后再依次匹配后面的路径


213、	Tomcat中指定URL用UTF-8编码server.xml：
	<Connector port="8080" protocol="HTTP/1.1"   connectionTimeout="20000"   redirectPort="8443" useBodyEncodingForURI="true" URIEncoding="UTF-8" />  

214、	具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案

215、		//构造XML
			Document document = DocumentHelper.createDocument();
			Element root = document.addElement("root");
			root.addElement("user").addText(ids[1]);
			root.addElement("sessionIdentifier").addText(ids[0]);
			response.setContentType("application/xml;charset=UTF-8");
			response.getWriter().write(document.asXML());
			response.getWriter().flush();
216、	单点登录
	1）、单点登录常规做法是重定向到认证中心去登录，然后再重定向回系统应用的原因。(而且为了安全，CAS本身也不提倡跨域远程登录，比如ajax不支持跨域)

217、	log日志中没有相关信息的话，肯定是没走打日志的地方，一般日志的位置在重要信息和error的地方。

218、	在sql语句中 null只能用is 不能用=

219、	数据库查询如果database没有主键，查询速度会非常慢

220、	//创建数组
	1）、int[] arr=new int[6];
	2）、int[] x={1,2,3,4};
	3）、int[] y= new int[]{1,2,3,4,5};

221、	HttpServlet 包含  init()、destroy()、service()方法
	init()：启动加载，可设置Servlet 的初始化参数，并用它的 ServletConfig 对象参数来启动配置。
	service()：客户请求一个HttpServlet 对象，该对象的service() 方法就要被调用，而且传递给这个方法一个"请求"(ServletRequest)对象和一个"响应"(ServletResponse)对象作为参数。
		   servlet中首先执行doService(),判断是请求是get还是post,get就调用doGet(), post就调用doPost()。也可以直接过载doService()方法，这样不管是get还是post，都会执行这个方法。  

	当服务器调用sevlet 的Service()、doGet()和doPost()这三个方法时，均需要 "请求"和"响应"对象作为参数。"请求"对象提供有关请求的信息，而"响应"对象提供了一个将响应信息返回给浏览器的一个通信途径。  
	使用GET，form中的数据将编码到url中，而使用POST的form中的数据则在http协议的header中传输



222、	重头戏:servlet、filter、interceptor的区别

	执行顺序：url请求----->filter----->interceptor----->servlet

	filter：用途是过滤字符编码、做一些业务逻辑判断(登录、权限：session中的权限不够可以直接重定向)，用于请求预处理(Request、Response)，也可对HttpServletResponse进行后处理，是个典型的处理链。Filter只是链式处理，请求依然放行到目的地址
		HttpRequest ----> Filter ----> Servlet ----> Controller/Action/... ----> Filter ----> HttpResponse                           filter的处理过程

	
	interceptor: 	不是在web.xml,并且不是针对URL的，而是针对action,当页面提交action时，进行过滤操作，
			与filter不同点：（１）不在web.xml中配置，而是在struts.xml中完成配置，与action在一起 ( 2 ) 可由action自己指定用哪个interceptor 来在接收之前做事

			spingmvc中的HandlerInterceptor的web请求流程：HttpRequest ----> DispactherServlet ----> HandlerInterceptor ---->Controller----> HandlerInterceptor ----> HttpResponse    
	


	1）、Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的响应。
	2）、Filter与Servlet的区别在于：它不能直接向用户生成响应。完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。
	3）、servlet,filter都是针对url之类的，而listener是针对对象的操作的，如session的创建，session.setAttribute的发生，在这样的事件发生时做一些事情。
	4)、拦截器只能对Action请求起作用，而过滤器则可以对几乎所有请求起作用。
	5）、Filter面对的是所有的请求，而HandlerInterceptor是面对具体的Controller。Filter总是先于HandlerInterceptor发挥作用，在Filter中甚至可以中断请求，从而使它无法到达相应的Servlet。
	     而且两者的配置也不一样，Filter是在web.xml中进行配置，HandlerInterceptor是在具体的applicationContext.xml中进行配置。

	6)、 	1.针对url：servlet，filter都是针对url进行的操作，
 		2.针对对象：listener是针对对象的操作，它是在某个对象发生某些动作的时候执行，所以listener是提前封装好的对特定的对象的操作，只需要声明名称和类的位置即可。
 		3.针对action：interceptor是针对action对象进行操作的，它在配置的时候需要和action一起配置才能起作用，当页面提交action时，进行过滤操作。

	7）、1）Filter基于回调函数，而Interceptor则基于java本身的反射机制,这是两者最本质的区别。
	     2）Filter的过滤范围比Interceptor大,Filter除了过滤请求外通过通配符可以保护页面，图片，文件等等，而Interceptor只能过滤请求。

223、	double保留两位小数	
	private  Double getDouble2(Double d){
		
		BigDecimal bg = new BigDecimal(d).setScale(2,  BigDecimal.ROUND_HALF_UP); //本身不改变new BigDecimal(d)的值
		
		return bg.doubleValue();

		DecimalFormat df = new DecimalFormat("0.00");
		df.form();建议使用java自带的转换方法

224、		cookie：
		读取-	Cookie[] cookies = request.getCookies(); 然后遍历看cookie.getName()有匹配cookiename参数的，有则存在该cookie，
		添加-	cookie添加的时候，需要设置Path默认根路径，Domain域名，MaxAge过期时间

225、		nginx相关
		nginx.exe -t 检查配置文件是否正确
		2.命令行输入 /安装路径/sbin/nginx -t 查看nginx配置是否正确
		3.命令行输入 /安装路径/sbin/nginx -s reload 重新加载nginx

		nginx配置多域名转发的时候：
		if ($http_host ~* "^(.*?)\.yu\.com$") {
					set $domain $1;
	    		}
		 		 location / {
		 			if ($domain ~* "www") {
        	 			proxy_pass https://192.168.6.222:9443;
				 	 }
			 		if ($domain ~* "m") {
        	 			proxy_pass https://192.168.6.222:9443;
					 }
        		}

		每次的请求都会先经过系统的nginx转发，主站发起请求-主站nginx转发到251-经过251的nginx转发-到实际运行的服务器上
		http://192.168.6.251:8086/upload  没有转发 访问251file  先有跨域问题在有路径问题  访问先经过filter和servlet	 	http://www.yu.com 

226、		流读取文件
		Thread.currentThread().getContextClassLoader().getResourceAsStream("abc.properties") 	默认是classpath下


227、		newinstance()和new()的区别
		newInstance: 弱类型。低效率。只能调用无参构造。 
    		new: 强类型。相对高效。能调用任何public构造。


228、		xml的解析:dom和sax
			xpath解析：先流读取xml文件获得doc，创建xpath对象，第一参数是xml中的路径，//表示只匹配名称，读取节点xpath.evaluate("/person", doc, XPathConstants.NODESET)  使用xpath.evaluate("background", node，XPathConstants.STRING)读取节点值.



229、		git版本回退：1、在history中的选中某个分支改动，reset（hard），之后再右键team-remote-push，选择分支强制推送，实现回退。
			     2、右键replacewith 选择相应的tag实现回退，实现的是将tag版本覆盖本地的dev分支，这时候dev会和远程有git变动
			     3、可以使用checkout挑出tag到本地，单独操作，也可以新建分支，随意
		
230、  		/** + 回车  快捷注释类

231、		springboot  @RequestParam 实现前台传参绑定类，不过参数名称要和类属性名一致

232、		springboot  bean.setTypeAliasesPackage("com.xiaoyuer.core.**.dmo");通配符配置多路径，com.xiaoyuer.core.dmo和com.xiaoyuer.core.talents.dmo              big  details


232、		sql使用`却别关键字

233、		springboot的接口参数的实现中@PathParam等
		接口测试中：
		@Consumes({ ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8 })	请求指定
		@Produces({ ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8 }) 	返回指定

234、		内关联对象
		<resultMap id="ResultMapRequireInfo" type="com.xiaoyuer.core.dmo.RequireInfo" extends="BaseResultMap">
			<result column="Require_Des" property="requireDes" jdbcType="LONGVARCHAR" />
			<result column="provinceName" property="provinceName" jdbcType="VARCHAR" />
   	 		<result column="cityName" property="cityName" jdbcType="VARCHAR" />
   			<result column="districtName" property="districtName" jdbcType="VARCHAR" />
			<association property="userInfo" javaType="com.xiaoyuer.core.dmo.UserInfo">
				<id column="User_ID" property="id" jdbcType="INTEGER" />
				<result column="User_Name" property="userName" />
				<result column="User_Picture_Att" property="userPictureAtt" />
				<result column="Individual_Type" property="individualType" />
				<result column="Nick_Name" property="nickName" />
			</association>	
		</resultMap>

		关联查询的时候  <id column="Id" property="id" jdbcType="INTEGER" />     数显多条id相同的只能接受一条，除非不查id



235、		在json   post 传输数组或者list对象的时候   [{"nickName": "zhansan",},{"nickName": "zhansan2",}]

236、		proteced 修饰符只能在该类内部使用
   			
237、	前端专场：		
	1）、		{{each talents as item i}} {{/each}}
			{{if item.userValidate==0}}{{/if}}       ftl的另一种写法 

	2）、		$(this).addClass("active");
			$(this).attr('class','active');
			that.siblings().removeClass('active');删除同级节点的active样式
	3）、		var id=$('.xms-sideboxe li').eq(i).attr('id'); 取制定元素的id内容



238、	update中出现select语句的更新操作
	select的结果再通过一个中间表select多一次，就可以避免这个错误
	update message set content='Hello World' where id in( select min_id from ( select min(id) as min_id from mes））


239、	<project xmlns="http://maven.apache.org/POM/4.0.0" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
		xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"></project>	
	pom中有该标签，只需加入maven依赖，即可自动从远程更新jar
	
240、	简易的ajax：
		$.ajax({
		             type: "post",
		             url: "localhost:8080/addTalents",
		             data: {"a":"nihao"},
		             dataType: "json",
		             success: function(data){		             	      
		                      }
		       });
	
241、	linux vim文档时候 insert或者i进入编辑模式    退出esc+:wq
	ubantu进入root sudo su
	输入exit退出root用户

242、	ajax传输数据的时候，后台使用@requestparam接受名字一定要对应，参数中如果不加该标签，传入数据是接受不到的，至少在springboot中接受不到，也就是说，不加标签ajax传输的数据只能tongue标签节后和request.getparammeter接收


243、	jsonarry和list转换	<dependency>
    <groupId>net.sf.json-lib</groupId>
    <artifactId>json-lib</artifactId>
    <version>2.4</version>
	</dependency>
		
244、	${ }不能在js中使用,循环添加一个新建对象，出现同一覆盖值的问题，var dataPrice={};一般要把新建对象放在循环体内
		r["name"]="tom"; 为对象添加属性
		var r=new Object();
		var dataForm=serialize(releaseReqForm);  表单序列化
		delete dataForm.appointPrice;   移除对象属性

	创建对象属性：
		var dataPrice={};
		XYE.each(dataForm.userId,function(i,tem){
		dataPrice['userId']=tem;
	
	浏览器的回退刷新
		<input type="hidden" id="refreshed" value="no">	
		<script type="text/javascript">
		onload=function(){
					var e=document.getElementById("refreshed");
					if(e.value=="no")e.value="yes";
					else{
						e.value="no";location.reload();
					     }
				  }
		</script >

245、	cmd 相关的命令：
		查看当前目录， dir
		cmd输入cls清屏
246、	ftl   
	<#if requireType=="1">
	1111
	<#elseif requireType=="4">
	444444
	</#if>  注意值加""

	<#if user??>
	${(user.name)!""}
	   



	判空		<#if userAddress.area??>

		  	<#else>

			</#if>




247、	再一个方法中操作数据库，如果没有走完，数据库是不会把事务提交的，即在数据库中是实时看不到操作完成的数据的，但是数据已经在缓存中发生了变化



248、	interface中定义的常量可以直接interface.调用
	public interface IOperateAdminRequireLogService {
	public String opAdmin_release_require="requires/release";//小秘书发需求,该flag在requireInfoMapper.selectReqListByUserIdWihtSecListPage中被使用，慎改
	public String opAdmin_re_release_require="requires/reRelease";//小秘书重发需求
	public String opAdmin_modify_require="update";//小秘书修改需求
	public String opAdmin_colse_require="close";//小秘书关闭需求
	public String opAdmin_delete_require="delete";//小秘书删除需
	public String opAdmin_choose_apply="apply/select";//小秘书代选人

	void insertOperateAdminReqLog(int reqId,int userId,int requserId,String remark);
}


249、sosoapi
	sosoapi ip权限   和 用户管理员权限（t_proj_mem中修改成员的信息）

250、		data:{"reqAppointInfo":JSON.stringify(dataForm),"userId":$('#userId').val()},如果走的ajax data数据，没有传就拿不到，和表单提交不一样


251、	${}页面取值只能维持一次请求

252、表单内容序列化
	var dataForm=serialize(releaseReqForm);
	dataForm['phoneScreen']=dataForm.cellShow;

252、代码测试：
	1、主函数中测试，这种只支持一些常规类的创建对象测试，无法注入interface，mapper，applicationContext等，无法进行接口等测试
	2、junit测试，入口属于代码接口测试，在项目中添加library中添加junit，即可进行单元测试
相关maven依赖		<dependency>
    				<groupId>junit</groupId>
    				<artifactId>junit</artifactId>
    				<version>3.8.1</version>
    				<scope>test</scope>
			</dependency>
	在sprinboot中：
		@RunWith(SpringJUnit4ClassRunner.class) // SpringJUnit支持，由此引入Spring-Test框架支持！ 
		@SpringBootTest(classes = XyeServiceCoreApplication.class) // 指定我们SpringBoot工程的Application启动类
		@WebAppConfiguration      //调用javaWEB的组件，比如自动注入ServletContext Bean等，指定加载 ApplicationContext是一个WebApplicationContext
		public class TalentsSearchServiceImplTest {
			@Autowired
			ITalentsSearchService  talentsSearchService;
			@Test
			public void testSelectUsersInfoBycellPhones() {
				BaseModelInfo<usersInfoBean> selectUsersInfoBycellPhones = talentsSearchService.selectUsersInfoBycellPhones(1, 202, "18862241316");
			}
		}
	在普通的ssm工程中：在这里是在war工程中进行测试，也因为各个jar的引用集中，mybattis也是集成在这里。不引入spring-mvc.xml的原因是这里是接口测试，无需controller相关，引入spring.xml是获得容器中的service，引入spring-mybatis.xml是因为接口中需要mapper等，否则接口注入失败
		@RunWith(SpringJUnit4ClassRunner.class)
		@ContextConfiguration(locations = { "classpath:spring.xml","classpath:spring-mybatis.xml" }) /////单个的文件读取	@ContextConfiguration("/applicationContext.xml")  
		public class UserInfoServiceImplTest {
			@Autowired
			IUserInfoService userInfoService;
			@Test
			public void test() {
				UserInfo selectById = userInfoService.selectById(203);
			}
		}
	3、postman测试，这种入口是路径测试
		在spring 接受参数是@pathvariable和@requestparam
		在springboot jboos中节后参数是@pathparam，@queryparam和@requestparam   @path标签和这些标签的匹配比较严格


	4、debug从前端页面到controller进入测试，这种在前后端分离的开发过程中是行不通的


253、默认的spring配置文件是resources下的applicationContext.xml，可以修改配置文件
			<context-param>	
				<param-name>contextConfigLocation</param-name>
				<param-value>classpath*:spring.xml</param-value>
			</context-param>


254、	接口中定义的"变量", 其实就是常量, 接口中的"变量"默认都是 "public static final"类型, 即为常量, 不要使用"常量接口模式", 此模式会导致类中的常量混乱

255、	连等判断 int a = 2==2 ? 1:0;

256、	.val() 方法返回或设置被选元素的值。
	layer web弹层组件，开源的额前段弹框

266、	ecipse下错误: 找不到或无法加载主类，重新添加buildPath中的add源码即可，maven打包异常不覆盖，也适用

267、	linux下配置tomcat的环境变量
	JAVA_HOME=/usr/java/jdk1.8.0_131
	JRE_HOME=${JAVA_HOME}/jre
	PATH=$JAVA_HOME/bin:$PATH
	CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar

268、	/**
	* JAVA获得0-9,a-z,A-Z范围的随机数
	* @param length 随机数长度
	* @return String
	*/
	public static String getRandomChar(int length) {
	char[] chr = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
	'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
	Random random = new Random();
	StringBuffer buffer = new StringBuffer();
	for (int i = 0; i < length; i++) {
	buffer.append(chr[random.nextInt(62)]);
	}
	return buffer.toString();
	}
	public static String getRandomChar() {
	return getRandomChar(10);
	}


269、	<resource>		----打包的类路径classpath
		<directory>src/main/resources</directory>	-----打包的目录，默认全部
		<includes>
		<include>spring-dubbo.xml</include>	-----打包固定的目录或文件
		</includes> 

	</resource>

	<profiles>
		<profile>
			<id>prd</id>
			<properties>
				<env>prd</env>
			</properties>
			<build>
				<filters>
					<filter>../vars/vars.prd.properties
					</filter>
				</filters>
			</build>
		</profile>
		<profiles>
	<resource>
		<directory>${basedir}/src/main/resources</directory>
		<filtering>true</filtering> 	----开启过滤功能
	</resource>
270、	maven多环境 <resources>中，pom中不指定具体的路径，默认 web deployment assembly 中配置的resource 全目录打包，
	配置了<resource>就会严格固定pom中的配置目录

271、	zookeeper+dubbo 框架实现soa
	C:\Users\xiaoyuer\.dubbo  下的zookeeper缓存


272、tomcat的session共享，tomca中配置缓存共享的问题
	org.apache.catalina.LifecycleException: Failed to start component [com.orangefunction.tomcat.redissessions.RedisSessionManager[]]

273、spring配置datasource的方式
	使用jndi需要在tomcat中增加数据源jar和logjar，并在context.xml中新增resourcejndi配置
	1、xml中注入配置datasource，需要指定数据源，目前用的是数据源jar是druid版本，在指定一些常规数据库连接属性即可
	2、 应用配置在高性能的应用服务器上，使用应用服务器本身提供的数据源。应用服务器的数据源，使用JNDI开放调用者使用，Spring为此专门提供引用JNDI资源的JndiObjectFactoryBean类。
		<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">      
    			<property name="jndiName" value="java:comp/env/jdbc/bbt"/>      
		</bean>  

	代码端：	Spring 2.0提供了一个jee命名空间，通过jee命名空间，简化J2EE资源的引用。
				<jee:jndi-lookup id="dataSource" jndi-name=" java:comp/env/jdbc/bbt"/>
	服务器端：	然后在tomcat中的context.xml中配置
				<Resource auth="Container" driverClassName="com.mysql.jdbc.Driver" maxActive="100" maxIdle="40" maxWait="12000" name="jdbc/XiaoyuerProject" password="db_xiaoyuer" type="javax.sql.DataSource" url="jdbc:mysql://192.168.6.251:3306/db_xiaoyuer_xq?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;generateSimpleParameterMetadata=true" username="db_xiaoyuer"/> 
 
	sprinboot中配置@bean 注入datasource，则以配置的为准，默认的取消

	DataSourceBuilder使用该类配置共配置数据源	


274、	<url-pattern>/</url-pattern> 会匹配到/login这样的路径型url，不会匹配到模式为*.jsp这样的后缀型url
	<url-pattern>/*</url-pattern> 会匹配所有url：路径型的和后缀型的url(包括/login,*.jsp,*.js和*.html等)
275、	在springmvc中继承HandlerInterceptorAdapter可以实现拦截器
	sprinboot中使用@ComponentScan(basePackageClasses = XyeManagerApplication.class）同样可以定义扫描的包路径
	
	springmvc中配置拦截器的路径，
	interceptor中处理request.setAttribute("baseUrl", Constants.URL_WEB_HOST_NEWADMIN);这样可以定义访问路径级别的全局的常量
	
	<mvc:interceptors>
    	<mvc:interceptor>
        <!-- 匹配的是url路径， 如果不配置或/**,将拦截所有的Controller -->
        <mvc:mapping path="/**"/>
        <bean class="com.cckj.util.auth.AuthInterceptor"></bean>
    	</mvc:interceptor>
    	<!-- 当设置多个拦截器时，先按顺序调用preHandle方法，然后逆序调用每个拦截器的postHandle和afterCompletion方法 -->
	</mvc:interceptors>

	配置拦截器的路径一定要controller存在的路径，否则也拦不到



276、	EOLINKER接口文档，soso-api接口文档

277、	<context:component-scan> ，属性base-package去扫描指定包下的class和jar文件，扫描到有@Component @Controller@Service等这些注解的类，并注册为Bean类放到Bean工厂
		包含了@Controller ，不需要用<mvc:annotation-driven/>了
		
		1><mvc:annotation-driven/>会自动注册DefaultAnnotationHandlerMapping与AnnotationMethodHandlerAdapter 两个bean
			DefaultAnnotationHandlerMapping ：负责扫描带有@Controller注解的类，给此类设置对应的@RequestMapping
			AnnotationMethodHandlerAdapter ：负责扫描Controller类中的方法，给方法设置对应的@RequestMapping
		2><context:component-scan base-package=""></context:component-scan>
			扫描器会扫描带有@Component@Service@Controller@Component等注解，并实现相应的操作，
			因为这四个注解包含了@Controller，
			所以会将Controller类和方法进行映射,不需要用<mvc:annotation-driven/>了
		
		
		

278、	<Host appBase="webapps" autoDeploy="true" name="localhost" unpackWARs="true">

    ---项目的部署路径              
	<Context docBase="D:\apache-tomcat-7.0.70\webapps\XiaoyuerProject" path="" reloadable="true" source="org.eclipse.jst.jee.server:XiaoyuerProject"/></Host>  --实际访问路径     实际的运用中可以配置图片服务器的虚拟路径
	在图片file写入磁盘的时候，采用的是路径+文件名的方式，路径最后要加上/，写入完整的路径。	

279、	WEB-INF下的文件无法直接访问，可以直接把JSP页面放到WEB-INF外的webapp目录下，可以通过转发的方式访问，我用的是Controller来进行转发，
	<%=request.getContextPath()%>	jsp页面中直接获取项目的工程名	
	路径前加“/”是代表绝对路径，不加“/”是代表相对路径。
	相对目录中 同级怒路直接取	<img src="img/solr.png">

280、	<%@ taglib uri="http://www.xiaoyuer.com/tag" prefix="xiaoyuer"%>
		web.xml中：
	  <jsp-config>
    		<taglib>
      		<taglib-uri>http://www.xiaoyuer.com/tag</taglib-uri>
      		<taglib-location>/WEB-INF/tag/xiaoyuer.tld</taglib-location>
    		</taglib>
  	  </jsp-config>


281、   web.xml 和jar正常  java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener   原因是最终的web工程中jar最终是要在web-inf的lib下的，没有重新添加maven的buildPath

282、	<c:set var="fileUrl" value="http://192.168.6.199:8086"/>
	<form id="itemForm" action="${fileUrl}${pageContext.request.contextPath }/editItemsSubmit" method="post" enctype="multipart/form-data" > 
	跨域提交表单的时候，需要写全http://头，否则不识别跳转blank空页面
	表单提交需要刷新回显
	ajax可以实现异步回显

283、	注释模板：
	shift+alt+J 自动注释  或者/** +enter      Window -->preferences--> Java --> Code Style --> Code Templates  中修改注释模板



284、	soaBean校验：
	1）、普通类实现接口需要实现接口中的所有方法，
	     抽象类实现借口，可以完全覆盖/重写 接口中的方法，也可只重写接口中的某几个方法，子类再继承抽象类时，子类重写的方法即为抽象类中未重写接口中的方法。
	     总的而言，抽象类实现接口可以自选实现的方法
	     普通类继承抽象类需要实现抽象类中的抽象方法
	     ***由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现***


	2)、field.setAccessible(true); 忽略访问修饰符权限
	    field.get(obj),对象实例换取对象的属性值，拿到对象实例的 域成员的值


285、	枚举类的使用
	枚举类一定需要private的构造函数
	public class Test {  
    public enum Color {  
        RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4);  
        // 成员变量  
        private String name;  
        private int index;  
  
        // 构造方法  
        private Color(String name, int index) {  
            this.name = name;  
            this.index = index;  
        }  
  
        // 覆盖方法  
        @Override  
        public String toString() {  
            return this.index + "_" + this.name;  
        }  
    }  
  
    public static void main(String[] args) {  
        System.out.println(Color.RED.toString());  
    }  

}

286、	spring的事务模板，使用匿名内部类并进行封装
	Object tmpResult = this.transactionTemplate.execute(new TransactionCallback()
         {
             public Object doInTransaction(TransactionStatus status)
             {
                    return serviceCallback.invoke();
             }
         }); 
	使用TransactionCallback()可以返回一个值。
	如果使用TransactionCallbackWithoutResult则没有返回值。 

287、	取对象属性操作后，对象本身也在变化

289、	
	Person person = new Person();
	BaseDict2 baseDict2 = person.getBaseDict2();
	baseDict2.setDescription("123123");
	System.out.println(JSON.toJSON(person).toString());

290、	@Autowired，首先在容器中查询对应类型的bean
　　　　如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据
　　　　如果查询的结果不止一个，那么@Autowired会根据名称来查找。
　　　　如果查询的结果为空，那么会抛出异常。解决方法时，使用required=false
	弄到方法上就是在实例化这个类的时候，注入方法形参类型的

	@resource（name=“personDaoBean”）默认byName


291、	可以看出DTO传输对象的设计应该具备这几个特点：
	1.按需放入字段。
	2.保证贫血模型，不要放任何逻辑在里面。



292、
二、	主键、外键和索引的区别
 	主键--唯一标识，不重复，不为空，
 	外键--是另一表的主键, 可重复, 可空，用来和其他表建立联系用的，
 	索引--无重复值，可为空，提高查询排序的速度，可有多个唯一索引
 
 	设置联合主键，自增的主键不能放在最左边
	CREATE TABLE `user` (  
  	`id` int(11) NOT NULL AUTO_INCREMENT,  
  	`username` varchar(255) NOT NULL,  
  	`nack` varchar(255) DEFAULT NULL,  
  	PRIMARY KEY (`username`,`id`)  



293、	Cannot create a session after the response has been committed
	浏览器缓存

294、	git cherry-pick	用于把另一个本地分支的commit修改应用到当前分支。
	gitreflog中可以查看回退版本的信息，可以挑选分支进行操作

295、	tag是基于分支存在的，远程有分支才能pull对应的tag

296、	HttpClient  
        HttpEntity  消息载体，post或者response中消息的载体
	httpclient.execute(httppost)
	处理返回消息体：EntityUtils.toString(response.getEntity(), "UTF-8");
	post请求：传参
	List<namevaluepair> formparams = new ArrayList<namevaluepair>();

297、	redis持久化的方案：
	RDB持久化：指定的时间间隔内将内存中的数据集快照写入磁盘，不过实时的可能会数据丢失，速度快
	AOF持久化：将每一个收到的写命令都通过write函数追加到文件中(默认是 appendonly.aof)，速度慢、体积大，可设置不同的fsync 策略，安全性高


298、	session共享
	代码级别的session共享
	1、走拦截类，但此时request。getsession是不同步的，只能从redis中取出相应的值，存在则已经登录，但是这是redis使用，表面的登录，此时两个服务器的session是不同步的

	tomcat级别的session共享
	2、tomcat级别的session共享，相当于使用redis实现两个服务器的缓存共享


299、	NAT的最典型应用是：在一个局域网内，只需要一台计算机连接上Internet，就可共享Internet连接，使局域网内其他计算机也可以上网。使用NAT协议，
	局域网内的计算机可以访问Internet上的计算机，但Internet上的计算机无法访问局域网内的计算机。


300、	spring的事务管理：
	a. 默认spring事务只在发生未被捕获的 runtimeexcetpion时才回滚；
	b. spring aop  异常捕获原理：被拦截的方法需显式抛出异常，并不能经任何处理，这样aop代理才能捕获到方法的异常，才能进行回滚，默认情况下aop只捕获runtimeexception的异常，但可以通过配置来捕获特定的异常并回滚  ！

	a1.  如果是service层处理事务，那么service中的方法中不做异常捕获，或者在catch语句中最后增加throw new RuntimeException()语句，以便让aop捕获异常再去回滚，并且在service上层（webservice客户端，view层action）要继续捕获这个异常并处理
	b2. 在service层方法的catch语句中增加：TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();语句，手动回滚，这样上层就无需去处理异常（现在我的项目的做法）

301、	select for update 数据库的悲观锁 在高并发长事务情况下容易发生锁表问题
	改善方案，使用数据库的乐观锁，表中增加version字段，每次更新+1，数据库根据version操作即可

302、	使用SqlSessionDaoSupport ，在mybatis的中实现dao实现类，使用可获得sqlsession
	@Repository
	public class UserDAOImpl extends SqlSessionDaoSupport implements UserDAO

  	@Autowired(required = false)
   	 @Qualifier("sqlSessionFactory")
   	 public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
    	    super.setSqlSessionFactory(sqlSessionFactory);
    	}



	使用sqlsession.getMapper(CLASS)使用的是初始的mybatis操作，加载mybatis配置后使用，
	在整合spring以后，直接使用mapper方法即可

	总结：
	1、原生的jdbc操作需要具体拼装sql执行
	2、mybatis初始，可以使用dao，sqlsession.执行（）实现，
	也可使用mapper代理，namespace需要和mapper路径一致，sqlsession.getmapper()，未整合spring，无法扫描到mapper接口的位置
	3、整合spring之后，直接使用mapper方法调用

303、	数据库的update使用时 where 条件需要使用主键或者索引，防止长事务锁表

304、	hessian实现远程方法的调用:HessianServiceExporter或者HessianProxyFactory，基于二进制的数据传输对象，二进制RPC协议的轻量级远程调用框架，Hessian远程调用框架是构建在Http协议之上的
	如果在远程调用时，用到了自定义的实体，必须序列化
	在hessian接口调用时候，可设置超时时间，必须要考虑超时情况下，客户端和服务端数据回滚情况，尤其是金融相关问题，两边可以打上tag，实时验证。
	在调用时需要分别配置服务端和客户端的配置，客户端主要是加入容器bean，服务端是拦截路径交给hessian处理转至相应的serviceimpl处理，返回

	客户端――>序列化写到输出流――>远程方法(服务器端)――>序列化写到输出流 ――>客户端读取输入流――>输出结果
	目前想到的和dubbo的区别是，hessian只能连接单一远程服务，但是dubbo可以有zookeeper提供多个提供者

	获取对远程的调用的代理，通过代理服务实现远程服务的调用，创建基于接口的代理给引用


305、	泛型
	List<T> getList<T param1,T param2>	可以限制返回结果的类型以及两个参数的类型一致。

	List<?>一般就是在泛型起一个限制作用。	public void test(? extends Fruit){};

306、	aop
	两种动态代理的模式：1、jdk动态代理	jdk实现的代理要求被代理类基于统一的接口，基于反射机制实现

			    2、cglib动态代理

	1.默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了
	2.当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB

	动态代理的核心就是代理对象的生成	Proxy.newProxyInstance(classLoader, proxyInterface, handler)
	切面aspect的中可包含多个通知（Advice）

	通知执行顺序：前置通知→环绕通知连接点之前→连接点执行→环绕通知连接点之后→返回通知→后通知→(如果发生异常)异常通知→后通知
	强制cglib代理	<aop:config>的 proxy-target-class属性设为true

	代理其实是在原实例前后加了一层处理，堆原来的类进行了包装，并使用代理类来执行

	AOP就实现了把这些业务需求与系统需求分开来做。这种解决的方式也称代理机制。	
	多个不具有继承关系的对象引入一个公共行为，会造成代码重复，这时提现aop的好处
	


307、这个异常处理无效
	try {
		throw new IOException(
				"Did not receive successful HTTP response: status code = ");
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	

	ExceptionUtils.getMessage(e)获得异常类型


308、	直接读取xml文件，加入容器
	一、简单的用ApplicationContext做测试的话,获得Spring中定义的Bean实例(对象).可以用:
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	RegisterDAO registerDAO = (RegisterDAO)ac.getBean("RegisterDAO");

	如果是两个以上:
	ApplicationContext ac = new ClassPathXmlApplicationContext(new String[]{"applicationContext.xml","dao.xml"});

	或者用通配符:
	ApplicationContext ac = new ClassPathXmlApplicationContext("classpath:/*.xml");

	
309、	金融封装的map传出参数 
	Map<String, Object> m = acBaseDao.queryForMap("acService.acctTrans.tableAutoColumnNextval", map);
 	 Long id = Long.valueOf(String.valueOf(m.get("id")));

310、	jvm知识：
	1）、堆和方法区是线程共享的，Java栈和本地方法栈是线程私有的



311、	https：
	加密算法一般分为两种，对称加密和非对称加密。所谓对称加密（也叫密钥加密）就是指加密和解密使用的是相同的密钥。
	而非对称加密（也叫公钥加密）就是指加密和解密使用了不同的密钥。


312、	nio
	传统的socket io需要为每个连接创建一个线程，开销巨大
	使用NIO，可用一个含有限数量的线程的线程池，甚至一个线程来为任意数量的连接服务。由于线程数量小于连接数量，所以每个线程进行IO操作的时候就不能阻塞，如果阻塞的话，有些连接就得不到处理，NIO提供了这种非阻塞的能力。
	io：面向流，阻塞
	nio：面向缓冲区，非阻塞	
	Java NIO的选择器：一个单独的线程很容易来管理多个通道



313、	不想编译报错，处理可以抛出RuntimeException，
	Throwable是java.lang包中一个专门用来处理异常的类。
	它有两个子类，即Error（运行环境方面的异常） 和Exception（显示-编译/隐式-运行异常），它们分别用来处理两组异常。

314、	spring的事务管理：为了确保数据的完整性和一致性。
	原子性：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。
	Spring事务管理的核心接口是PlatformTransactionManager 				
	TransactionStatus status = this.transactionManager.getTransaction(TransactionDefinition definition); 返回接口的实现类，
	definition中定义的了一些基本的事务属性，根据指定的传播行为返回当前活动的事务或创建一个新的事务


	1、配置事务管理器
		<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    			<property name="dataSource" ref="dataSource" />
		</bean>
	

	2、两种事务管理方式：
		1.编程式事务管理
			可使用PlatformTransactionManager，spring中使用了TransactionTemplate模板操作
				<bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate">
        				<property name="transactionManager" ref="transactionManager"></property>
        				<!--定义事务隔离级别,-1表示使用数据库默认级别-->
        				<property name="isolationLevelName" value="ISOLATION_DEFAULT"></property>
        				<property name="propagationBehaviorName" value="PROPAGATION_REQUIRED"></property>
    				</bean>
				
			代码级别的rollback

	
		2.声明式事务管理
			一种是基于tx和aop命名空间的xml配置文件，
				 <tx:advice id="advice" transaction-manager="transactionManager">
        				<tx:attributes>
           				<tx:method name="insert" propagation="REQUIRED" read-only="false"  rollback-for="Exception"/>
        				</tx:attributes>
    				</tx:advice>

    				<aop:config>
        				<aop:pointcut id="pointCut" expression="execution (* com.gray.service.*.*(..))"/>
        				<aop:advisor advice-ref="advice" pointcut-ref="pointCut"/>
    				</aop:config>

			一种是基于@Transactional注解
  				<tx:annotation-driven transaction-manager="transactionManager"/>
				
			@Transactional(rollbackFor=Exception.class)
   			 public void insert(String sql, boolean flag) throws Exception {
        			dao.insertSql(sql);
        			// 如果flag 为 true ，抛出异常
        			if (flag){
            			throw new Exception("has exception!!!");
        			}
    			}





315、	拦截器再往上抛出异常，可由统一自定义异常处理
	springmvc的统一异常处理需要实现HandlerExceptionResolver接口
	spring的handle在处理时发现异常后，HandlerExceptionResolver的列表会被赋值，然后进行处理
	这个统一异常处理类需要加入spring容器

	ControllerExceptionResolver implements HandlerExceptionResolver
	{

	public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,
        Exception ex)
    {
    
        ModelAndView mv= new ModelAndView();

        return mv;
    }

	}
	拦截其中重定向后return true，则重定向无效


316、	svn删除恢复
	找到删除该文件或者文件夹的版本，在Logmessage里右键Revertthechangesfromthisrevision。


317、	sql表数据转储其他库时，先建表，后倒入数据，可保持数据结构一致


318、	simpledateformat只是日期格式的转换
	Calendar才是日期的操作类

	yyyy-MM-dd HH:mm:ss  大小写哈哈

319、	maven本地工程依赖失效，install总的pom工程即可

320、	日志：
	logger.error("用户{},获取月份信息失败", "nini"); 日志快捷传参
	
======================================================================================整理分割线========================================================================================


321、	动态代理：
	import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class InvocationHandlerTest implements InvocationHandler {

    private Object target;

    Object bind(Object i) {
        target = i;
        Object warpedItf;
        warpedItf = Proxy.newProxyInstance(target.getClass().getClassLoader(), i.getClass().getInterfaces(), this);
        return warpedItf;
    }
参数中的接口，提供代理方法和具体的返回类型，handler是代理核心实现，这里可以将Proxy.newProxyInstance也封装进来

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("before method excute!");
        method.invoke(target, args);
        System.out.println("after method excute!");
        return null;
    }
    
    public static void main(String[] args) {
        Cls c = new Cls();
        InvocationHandlerTest pxy = new InvocationHandlerTest();
        Itf itf = (Itf)pxy.bind(c);
        itf.printSth("Hello");
    }

}

动态代理2
public class InvocationHandlerTest implements InvocationHandler {

    private Object target;

    Object bind(Object i) {
        target = i;
        Object warpedItf;
        warpedItf = Proxy.newProxyInstance(target.getClass().getClassLoader(), i.getClass().getInterfaces(), this);
        return warpedItf;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("before method excute!");
        method.invoke(target, args);			//注意这里类时属性参数
        System.out.println("after method excute!");
        return null;
    }
    
    public static void main(String[] args) {
        Cls c = new Cls();
        InvocationHandlerTest pxy = new InvocationHandlerTest();
        Itf itf = (Itf)pxy.bind(c);
        itf.printSth("Hello");
    }

}


动态代理的作用：
主要用来做方法的增强，让你可以在不修改源码的情况下，增强一些方法，
在方法执行前后做任何你想做的事情（甚至根本不去执行这个方法），
因为在InvocationHandler的invoke这个方法中，你可以直接获取正在调用方法对应的Method对象，
具体应用，比如，添加日志，做事物控制等。



322、消息队列
	个人认为消息队列的主要特点是异步处理，主要目的是减少请求响应时间和解耦。
	所以主要的使用场景就是将比较耗时而且不需要即时（同步）返回结果的操作作为消息放入消息队列。
	同时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦和。


	基于的设计模式是观察者模式
	redis继续list形式以进出栈的形式实现队列

	生产消费模型、发布者/订阅者模型。

	spring整合mq连接异常，需要在mq.xml中配置相应的本地连接参数

	(1)、点对点方式（point-to-point）
		点对点的消息发送方式主要建立在 Message Queue,Sender,reciever上，Message Queue 存贮消息，Sneder 发送消息，receive接收消息.
		具体点就是Sender Client发送Message Queue ,而 receiver Cliernt从Queue中接收消息和"发送消息已接受"到Quere,确认消息接收。
		消息发送客户端与接收客户端没有时间上的依赖，发送客户端可以在任何时刻发送信息到Queue，而不需要知道接收客户端是不是在运行
	(2)、发布/订阅 方式（publish/subscriber Messaging）
		发布/订阅方式用于多接收客户端的方式.作为发布订阅的方式，可能存在多个接收客户端，并且接收端客户端与发送客户端存在时间上的依赖。
		一个接收端只能接收他创建以后发送客户端发送的信息。作为subscriber ,在接收消息时有两种方法，destination的receive方法（同步），和实现message listener 接口的onMessage 方法(异步)。


	消息模型只有两种：	○ Point-to-Point(P2P)(一旦被消费，消息就不再在消息队列中) 
				○ Publish/Subscribe(Pub/Sub)






323、手机的动静分开部署：
	部署在webapp和root区别
	区别是：前者带工程文件名访问，存在工程名目录，后者不带工程名目录，访问的工程名是根路径/
	对于手机这种动静分离的做法，将手机后台放在webapp下，静态文件放在root下，访问更上即可，路径访问的优先原则，默认全路径匹配，

324、	
	<a class="react label-bar pr" href="http://m.yu.com/xye-phone-html/usercenter/paydetails.html">
	加不加http://    不加就会默认加上项目路径访问，加就全路径访问


325、单独读取xmlContext作为上下文容器
	ApplicationContext ctx = new FileSystemXmlApplicationContext("classpath:applicationContext-*.xml");  
        JmsTemplate jmsTemplate = (JmsTemplate) ctx.getBean("jmsTemplate"); 

326、	web.xml配置全局错误页面
		调试错误跳转页面出现一个问题,即在web.xml中配置的<error-page></error-page>不起作用，在web.xml中配置代码通常有两种方式：
		1、根据错误代码
		<error-page>
		<error-code>404</error-code>
		<location>/404.jsp</location>
		</error-page>
		2、根据异常类型（相对优先原则）
		<error-page exception-type="java.lang.NullPointerException" location="/nullpointer.jsp"/>
		注1：对于resin服务器也可以将错误跳转配置在resin-web.xml文件中，效果一样。
 	
		对于无法跳转的解决：
		1.确保location属性中填写的错误页面是绝对路径
		2.确保error.jsp的大小>1024字节
		3.确保在error.jsp页面中添加<%@ page isErrorPage="true"%> 


327、	反射相关
		Person person = new Person();		
		Field declaredField = person.getClass().getDeclaredField("name");			
		Method method = person.getClass().getMethod("setName", new Class[] {declaredField.getType()});
		method.invoke(person,new Object[] {1001});
		Long namehaha = person.getName();
		System.out.println(namehaha);


	<bean id="person" class="test.Person">
		<property name="name" value="xiaoming212"/>
	</bean> 
	注入的时候bean中需要无参构造，name属性还是根据setter（）方法注入的，类似反射的setter+属性首字母大写，保证setter方法一致就可以了
	

328、	hessian接口的调用基于http的访问，路径管理还是比较麻烦的，访问单一
	server端
	<bean name="/eBankReceiptManagerExpService" class="org.springframework.remoting.caucho.HessianServiceExporter">
  		<property name="service" ref="eBankReceiptManagerService" />
  		<property name="serviceInterface" value="com.xiaoyuer.pay.service.intf.IEBankReceiptManagerService" />
    	</bean>


	交给DispatcherServlet处理
  	<servlet>
		默认加载web-inf下的servlet.xml
  	</servlet>


	client端
	<bean id="eBankReceiptManagerExtService" class="org.springframework.remoting.caucho.HessianProxyFactoryBean">
  		<property name="serviceUrl" value="${xye.paycore.server}/remoting/eBankReceiptManagerExpService" />
  		<property name="serviceInterface" value="com.xiaoyuer.pay.service.intf.IEBankReceiptManagerService" />
  		<property name="readTimeout" value="30000"/>
    	</bean>





329、	sql相关
	like concat(concat('%',#{name,jdbcType=VARCHAR}),'%'）

330、	basemodelinfo 序列化  远程接口调用的对象都需要序列化 内部的类也需要序列化


331、	ajax 的返回的 json数据
		response.addHeader("Access-Control-Allow-Methods", "POST,GET");
		response.addHeader("Access-Control-Allow-Credentiais", "true");
		response.setContentType("text/javascript;charset=utf-8");	设置为json数据返回 
		Utils.resultJson(response, obj.toJSONString());



	流文件的附件下载	
	windows路径跳转
		String realName="收支明细_"+DateUtil.getCurrentDate("yyyyMMddHHmmss")+".xls";
		    response.reset();//设置为没有缓存
		    response.setContentType("application/x-download;charset=GBK");		设置为下载application/x-download  
		    response.setHeader("Content-disposition", "attachment; filename="+ new String(realName.getBytes("utf-8"), "ISO8859-1"));	 /*attachment是以附件下载的形式，inline是以线上浏览的形式。当点击“保存”的时候都可以下载，当点击“打开”的时候attachment是在本地机里打开，inline是在浏览器里打开。*/		
		    OutputStream output = response.getOutputStream();
		    byte[] buf = new byte[1024];
		    int r = 0;
			ByteArrayInputStream bin = new ByteArrayInputStream(byteOut.toByteArray());
			while ((r = bin.read(buf, 0, buf.length)) != -1) {
			     output.write(buf, 0, r);
			    }    
			 response.getOutputStream().flush();
			 response.getOutputStream().close();
	
	
332、	自关联表查询sql
	SELECT 'outComeSumAmt' AS CODE, oott.outComeSumAmt AS fund  FROM
		(
			SELECT 123 AS outComeSumAmt
		) AS oott


333、	IO流的：
	1.字节流读取的时候，读到一个字节就返回一个字节； 字符流使用了字节流读到一个或多个字节（中文对应的字节数是两个，在UTF-8码表中是3个字节）时。先去查指定的编码表，将查到的字符返回。 
	2.字节流可以处理所有类型数据，如：图片，MP3，AVI视频文件，而字符流只能处理字符数据。只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都用字节流。



334、	事务相关 Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。

335、	文件的流读取，char[3]类型 是每次读取固定长度的串写入，多次执行
 	if((c=fr.read(a))!=-1)	{
					fw.write(a,0,c);
				}

336、	声明式事务
		1、tx配合aop标签
		2、代理
		3、拦截器
	
	编程式事务
		注解@Transactional 需要开启通用注解标签<context:annotation-config />
		<!-- 第四种配置事务的方式，注解 -->
		<tx:annotation-driven transaction-manager="transactionManager"/>

	Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。
	SpringMVC启动时的配置文件，包含组件扫描、url映射以及设置freemarker参数，让spring不扫描带有@Service注解的类。
	为什么要这样设置？因为servlet-context.xml与service-context.xml不是同时加载，如果不进行这样的设置，那么，spring就会将所有带@Service注解的类都扫描到容器中，等到加载service-context.xml的时候，
	会因为容器已经存在Service类，使得cglib将不对Service进行代理，直接导致的结果就是在service-context中的事务配置不起作用，发生异常时，无法对数据进行回滚。


	*******事务回滚的更新测试******
	@Transactional 先执行更新1  在try住更新2回滚， 全部回滚
		       先执行更新1  在try住更新2回滚， 再更新3 全部回滚









337、	拦截器的优化	一般在拦截器中定义全局的ctx，建议定义在afterCompletion中，这样在异常处理返回后页面中还能获取到值，在controller中的异常一般是500错误，可在web.xml中定义错误页面返回
	提现的明细记录问题，事务优化，对于跨系统之间事务，会涉及到一些不是很重要的操作，对于非重要的操作，整个try住，即使异常也不能影响主要事务的进行

338、	jsp页面保留两位小数:
	引入标签	    	<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt"%>
	使用标签		<fmt:formatNumber value="${item.amount}"  pattern="0.00" maxFractionDigits="2" type="number"/>
	$.each(data,function(i,tem){ });

339、	追踪日志的日后 注意cause by
	pom中引用统一jar的snapshot大小写必须一致，默认一般是大写

340、	select 'accountFix' as code, uba.account_fix as fund map返回类型{code=incomeSumAmt, fund=1104.84} 转json	{"code":"incomeSumAmt","fund":"1104.84"} 在取属性组装单entry 的 map
	UNION 需要查看 column字段的对应


341、	 pluginManagement的配置和plugins的配置是一样的，只是用于继承，使得可以在子pom中使用父pom：

342、	jersy测试框架好恶心，入参必须要加上相应的标签
    	
343、	try finally 一般用来关闭文件流操作等


344、	dubbo的源码分析：
		InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候会执行该方法。
		项目用到了ApplicationContextAware，通过它Spring容器会自动把上下文环境对象调用ApplicationContextAware接口中的setApplicationContext方法，容器加载完后会把上下文set到类中，可以方便使用
   
335、	互联网媒体类型
	例如： Content-Type: text/html;charset:utf-8;
 	常见的媒体格式类型如下：
    		text/html ： HTML格式
    		text/plain ：纯文本格式      
    		text/xml ：  XML格式
    		image/gif ：gif图片格式    
    		image/jpeg ：jpg图片格式 
    		image/png：png图片格式
   	以application开头的媒体格式类型：
   		application/xhtml+xml ：XHTML格式
   		application/xml     ： XML数据格式 	和text/xml的区别是编码不同
   		application/atom+xml  ：Atom XML聚合格式    
   		application/json    ： JSON数据格式
   		application/pdf       ：pdf格式  
   		application/msword  ： Word文档格式
   		application/octet-stream ： 二进制流数据（如常见的文件下载）
   		application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）
   	另外一种常见的媒体格式是上传文件之时使用的：
   		multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式

	javascript的mime有三个：
		text/javascript,application/javascript,application/x-javascript
		text/javascript:传统的javascript程序，RFC4329规定了“text/javascript”类型，因为它普遍被使用
		application/javascript：javascript程序并不是真正的文本文件，所以推荐使用这个
		application/x-javascript：和application/javascript差不多，只是多了个x，x前缀表示这是实验性的，不是标准的类型

		content-type:application/x-msdownload	打开save as对话框	直接在浏览器显示文件信息
		content-disposition			打开save as对话框	下载文件，但不会打开save as对话框
		content-type:application/octet-stream	打开save as对话框	直接在浏览器显示文件信息

	配合response.setHeader用法，没啥好研究的，照着用就可以

336、	****CROS协议解决跨域问题******
	自建filter，加入http的头信息，实现跨域访问,
	response.setHeader("Access-Control-Allow-Origin", "*")
	但是服务器端 Access-Control-Allow-Credentials = true时，参数Access-Control-Allow-Origin 的值不能为 '*' 。;
	但是也可以引用org.apache.catalina.filters.CorsFilter现成的jar，web.xml中做相关的配置即可，解决了上诉问题
	
	服务器端 Access-Control-Allow-Credentials = true时，参数Access-Control-Allow-Origin 的值不能为 '*' 、



	后端处理：一般是放在filter中处理的
	    response.setHeader("Access-Control-Allow-Origin", "*");  
            response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE");  
            response.setHeader("Access-Control-Max-Age", "3600");  
            response.setHeader("Access-Control-Allow-Headers", "x-requested-with");  	



337、	distinct  和group by  一样


338、	用表单提交，不要用ajax。ajax无法实现导出excel。

	ajax 其实只是一个javascript中的一个组建 XmlHttpRequest, 他的作用是数据交互, 返回数据是组建内部处理的, 下载是需要浏览器识别http头的,所以肯定只能用iframe
	可以使用表单提交，和地址重定向location.href就行,导出需要http的头，是属于页面级别的。

	导出excel为什么不能用ajax请求？
	因为导出excel，实际上是文件下载，后台需要往前端（浏览器）写文件流（浏览器解析）的。
	而Ajax请求获取数据都是“字符串”，整个交互传输用的都是字符串数据，它没法解析后台返回的文件流，但浏览器可以。
 
	ajax，看名字asyn JavaScript and xml，是不能传输2进制数据的，怎么可能导出，直接请求servlet或者action（struts2）或者controller（spring mvc），
	将导出的文件流放入到response的outputStream中，同时设置好header和contentType就可以了

	Ajax与Form表单提交的区别：
	Ajax提交不会自动刷新页面，需要手动处理。
	Form表单提交在数据提交后会刷新页面，如果是Post提交，点击刷新浏览器会提示 是否再次提交。


339、	转二进制	// 序列化
            baos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(baos);
            oos.writeObject(object);
            byte[] bytes = baos.toByteArray();
            return bytes;

340、	git stash 后切换分支后 apply stash 可能有冲突
	git stash 后 dev有改动 在apply回来会有冲突
	stash是本地的恢复操作，目前一般使用是：本地stash 切换分支，回来时本地文件没变apply回来


341、	静态代码块 static 在第一次调用时候会执行 不允许访问非静态成员 
	
	加载类的集中方式：
		new StaticCode();//生成了一个匿名的对象（过后不能再使用），加载类  
		StaticCode.show();//通过类名调用静态方法，加载类  
		StaticCode s = new StaticCode();//生成了一个对象，加载类  
		StaticCode s = null;//没有生成类，与StaticCode类没有关系，不加载类  


342、	try catch多个异常时：顺序匹配，匹配到后面的就跳过
	在写异常处理的时候，一定要把异常范围小的放在前面，范围大的放在后面，
	Exception这个异常的根类一定要刚在最后一个catch里面，
	如果放在前面或者中间，任何异常都会和Exception匹配的，就会报已捕获到...异常的错误。

343、	transient关键字只能修饰变量，不再是对象持久化的一部分，不再能被序列化（静态变量也不能）传输

344、	页面级别的特殊字符转换转换
	value="${requireInfo.reqTitle ? replace("\"","&#34;")}" 转换页面中的字符串

345、	DocumentBuilderFactory解析xml用 工具类的级别
	DocumentBuilder builder = factory.newDocumentBuilder();
 	Document doc = builder.parse(f);
  	解析xml文件
	使用tagname 和nameitem相关解析，没有节点灵活
	





346、	在springjdbc的dmo类中 关系映射，@Column(name="DATE_UPDATE")的参数绑定和数据库中的默认0是相冲突的，初始化属性是null

347、	Person person = (Person) new SuperMan()
	向下转型，向上无需转型


348、	
	服务化使用rest访问的必须要添加token访问权限，不能随意访问
@PreMatching
public class TokenFilter implements ContainerRequestFilter {

	@Context
	HttpServletRequest request;
	@Context
	private HttpServletResponse response;

	@Override
	public void filter(ContainerRequestContext requestContext) throws IOException {
		String token = request.getParameter("token");
		if (!TokenUtil.validToken(token)) {
			BaseModel failModel = new BaseModel();
			failModel.setCode(FunsionCode.FAILED_CODE_90101);
			failModel.setErrMsg(FunsionCode.FAILED_MSG_90101);
			Response result = Response.ok().entity(JSONObject.toJSON(failModel)).header(HttpHeaders.CONTENT_TYPE,
					ContentType.APPLICATION_JSON_UTF_8).build();
			requestContext.abortWith(result);
		}
	}
}

349、	springmvc，就参数绑定来说，加modelattribute标签和不加标签都可以
	其他的功能，相对而言都不怎么实用
	<mvc:view-controller path="/" view-name="/index.jsp"/>
	配合视图解析器会用，配置欢迎页
	在web.xml中的欢迎页中也可以使用

	
350、	正向代理：类似挂vpn从服务端获取数据，	特点：多个客户端
	反向代理：使用负载均衡配多个服务端	特点：多个服务端	

351、	相对路径会出现问题	 绝对路径和全路径	不会	 
	js路径的继承 相对地址 	默认继承访问当前页面的地址，末路径匹配		


352、	Class.forName().newInstance()和 new对象的区别：
	1、使用newInstance可以解耦。使用newInstance的前提是，类已加载并且这个类已连接，这是正是class的静态方法forName（）完成的工作。newInstance实际上是把new         这个方式分解为两步，即，首先调用class的加载方法加载某个类，然后实例化。
	2、newInstance: 弱类型。低效率。只能调用无参构造。 new: 强类型。相对高效。能调用任何public构造。 
	3、newInstance()是实现IOC、反射、面对接口编程和依赖倒置等技术方法的必然选择，new只能实现具体类的实例化，不适合于接口编程。 
	4、 newInstance() 一般用于动态加载类。 

353、	转换流的最强功能就是基于 字节流 + 编码表 。没有转换，没有字符流


354、	sql中的${} 和#{} sql注入


	1、#{}能够很大程度上防止sql注入，作为字符串处理;${}方式无法防止sql注入;

	2、mybaties排序时使用order by 动态参数时需要注意，使用${}而不用#{};  表名也用${}
	   如果你要做动态的排序，比如 order by column，要用${},因为如果你使用了#{},会拼上字符串，那么打印出来的将会是
	   select * from table order by 'name' ,这样是无法排序。

								
	3、#将传入的数据都当成一个字符串，$将传入的数据直接显示生成在sql中。

	4、select * from user where id=${id} and username=#{username}

	在经过编译后，得到如下语句

	select * from user where id=2 and username=?

	如果是#{}的形式是编译成?，而如果${}是编译成直接的数据。

	区别：

	#{}: 是以预编译的形式，将参数设置到SQL语句中;PreparedStatement:防止SQL注入

	${}: 取出的值直接拼装在SQL语句中;会有安全问题
	
	sql攻击案例：
		select * from ${tableName} where name = #{name}  

		我们的参数 tableName 为 user; delete user; --，

		select * from user; delete user; -- where name = ?;  
		
355、	reloadable="true" 监听类路径下的class文件

356、	dubbo的源码分析：
		dubbo的工作流程。RPC的亮点在于将远程调用的细节隐藏起来，使得调用远程服务像调用本地服务一样简单，而实现上面的功能就是代理。
		dubbo由于有服务端信息的本地缓存，提供者的地址列表，所以当注册中心挂掉后调用端依然能够工作，也就是说调用端不是强依赖服务端。

		短连接的操作步骤是：建立连接――数据传输――关闭连接…建立连接――数据传输――关闭连接
		长连接的操作步骤是：建立连接――数据传输…（保持连接）…数据传输――关闭连接


		<dubbo:protocol name="dubbo" port="20880" /> 解析成相应的对象，name目前来看映射的是id属性

		ApplicationEvent	是个抽象类，里面只有一个构造函数和一个长整型的timestamp。
		ApplicationListener	是一个接口，里面只有一个onApplicationEvent方法。

		如果在上下文中部署一个实现了ApplicationListener接口的bean,那么每当在一个ApplicationEvent发布到 ApplicationContext时，
		这个bean得到通知。其实这就是标准的Oberver设计模式。当一个ApplicationContext被初始化或刷新触发，这时候，监听到的是ContextRefreshedEvent事件（容器初始化完成），和InitializingBean（本bean初始化完成）不同，
		
		用Object[0]来代替null 很多时候我们需要传递参数的类型，而不是传null，所以用Object[0]	实际传递的是带泛型的null	new Class<?>[0]
		在dubbo中的xml解析，不写id 会默认dubbo 或者interface 相关源码有默认id值

		spring的xml中自定义bean 都需要一个实现了BeanDefinitionParser接口的解析parser


357、	Person[] persons = new Person[3];

358、	jenkins的源码库浏览器，默认是自动，选择其他也行 但要配上相应的浏览器地址


359、	在计算一年的时间毫秒数时候，365*24*3600*1000超出了int的最大范围（-2147483648-2147483647），会溢出计算以long类型计算即可

360、	在读取属性文件的时候，可以通过文件路径或者类路径读取，但是形如/D:/apache-tomcat-sso/webapps/XiaoyuerAdmin-war/WEB-INF/lib/fastdfs-client-java-1.27-SNAPSHOT.jar!/fdfs_client.conf
	这种路径文件路径是读取不到的，因为没有jar没有目录结构，同样类路径也读取不到
	// 优先从文件系统路径加载
      		if (new File(filePath).exists()) {
       		in = new FileInputStream(filePath);
		 }
      	// 从类路径加载
      		in = classLoader().getResourceAsStream(filePath);
 
361、	processData：默认是true，重在在于是当成处理对象还是字符串
	要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型"application/x-www-form-urlencoded"。
	如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。这是后ajax无法传json数据


362、	实现了Iterable<s>接口的类就可以遍历了,遍历类型就是s

363、	JavaSPI ***源码级别，这里的具体serviceloader的代理实现，暂不研究***
	spi Service Provider Interface 服务提供接口 		动态加载机制，一种服务发现机制
	在模块装配的时，基于接口从配置文件中装配实现类 SPI的应用之一是可替换的插件机制，javaspi就是提供这样的一个机制：为某个接口寻找服务实现的机制。工具类：java.util.ServiceLoader
	就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。 同时实现了两个spi接口的类，如果不做限制，都会执行
	重点的思想是使用jar的形式，可插拔
	ServiceLoader<ISpiTestService> loads = ServiceLoader.load(ISpiTestService.class);//这里拿到的是实现接口的实现类，具体的实现类在classpath下的META-INF/services/下
		for (ISpiTestService iSpiTestService : loads) {
			iSpiTestService.say();
			System.out.println("end-------");
		}


	类加载器的有趣味解读，总结就是先加载类，再实例化一个类的对象
	在 Java 中，Class<T> 和 ClassLoader 是造物之始。万物皆是“某类T” 的存在物，而“某类T” 是“万类之类 Class<T>” 的存在物，类别也是一种存在物，存在物即 Object。实例 t -> 类别 T -> 所有类别的抽象 Class<T> -> Object。要创造类别 T 的实例，先通过某种方式(ClassLoader)找到该物的“种子”(Class<T> 对象)，然后通过该种子来创造具体的物 t。要生成一个 Integer 对象，先找到 Class<Integer> , 然后 newInstance 出 Integer 的实例。
	java本身并不实现，会到META-INF下去寻找相应接口名文件中的实现类去实现  

364、	统一个接口的并发操作，每次的请求都是一个线程，

	具体的是两个同样的工程同时发送同样的请求，同时经过数据库唯一判断，并执行后续操作，就会发现问题，这事不要用update 对象的方法，
	可以数据库加上乐观锁，两个version版本一致才执行操作

	两次的请求
	update obj1  a=2
	update obj1  a=3

	update a+1
	update a+1
	
365、	hashmap中的get方法返回null，表示不存在该键或者键对应的value是null	
	hashmap的原理是基于hash运算计算存储位置，统一hash位置的多个entry根据key.equals（）取值


366、	mv级别的重定向:
	ModelAndView mv = new ModelAndView("redirect:/404.htm");

367、	加上事务标签后，抛出异常，能是可以接受到的
	git合并记录的历史看总的pom工程

368、	一代版本一代jar，
	 logger.info ("订单:{}动作 重复 类型:{}",orderCode,type);
	异常日志如下
	catch (Exception e) {
    		logger.error("订单{}退款失败",orderCode，e);
		
	}
369、	ConcurrentMap继承map接口，实现类是ConcurrentHashMap，并发级别的map
	public class Locale {  
    	private final static Map<String, Locale> map = new HashMap<String,Locale>();  
   	public static Locale getInstance(String language, String country,  
            String variant) {  
        //...  
        String key = some_string;  
        Locale locale = map.get(key);  
        if (locale == null) {  
            locale = new Locale(language, country, variant);  
            map.put(key, locale);  
        	}  
        	return locale;  
    	}  
	}  
	***在一个类中的static的map中，同时多个请求过来，在经过null判断后，会返回同key不同value的情况***
	ConcurrentHashMap，putIfAbsent()是有返回值的，使用 putIfAbsent 方法时切记要对返回值进行判断，
	“如果（调用该方法时）key-value 已经存在，则返回那个 value 值。如果调用时 map 里没有找到 key 的 mapping，返回一个 null 值

370、	public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)
	判断某个class有没有相应的注解

371、	在filter中加入MDC变量容器，这样在日志管理可以统一处理变量，但是记得一定要在最后finally中移除掉相应的变量	

372、	在dubbo的extensionloader中，只会处理@spi标签的接口，通过loadFile(extensionClasses, SERVICES_DIRECTORY);加载指定的实现类来，完成spi的服务提供

	不足之处是把所有的实现都给你了。你也许只想用某个特殊的实现类呢？

373、	循环中的break是中断

374、	//数据量大的job任务，加入分批处理
		QueryPage queryPage =new QueryPage();
		queryPage.setTotal(总数量num);
		if(queryPage.init()){
			初始化执行次数，开始位置和每次执行数据
		}

375、	在try{}catch的执行体中，尾处有异常被捕获，头部的操作还是保留了，除非设置回滚相关

376、	spring的事务管理，有几种隔离级别方式，
	NESTED嵌套事务；内部事务是外部事务的子事务，外部的异常能触发所调用的NESTED事务回滚,内部事务的异常回滚不影响外部事务
	REQUIRES_NEW,连个独立的事务，互不影响
	REQUIRED 链接一体的事务，内外事务回滚一致
		

373、使用注解aop的相关条件
	1、依赖相关的spring和aop的jar
	2、被拦截的类和aop的aspect类都必须加入spring的容器
	3、配置先关的拦截规则：
	@Aspect
	public class AopAdviser {
		@Pointcut("execution(* test.Person.go(..))")  
		public void say(){
		};
	
		@Before("say()")
		public void lie(){
		System.out.println("前置执行");
		};
	
		@After("say()")
		public void gone(){
		System.out.println("后置执行");
		};
	}
	spring中开启注解标签<aop:aspectj-autoproxy/>  
	aop是spring动态代理的一种体现：
	需要被代理的类，需要有个实现了invocationhandler的处理核心handler（针对方法前后添加相关操作），最后再有proxy生成代理的对象，

374、	实现invocationHandler接口的代理处理的核心类中，有三个重点的东西：
	1、构造函数，将代理对象传入
	2、invoke方法，实现aop的增强的所有逻辑
	3、getproxy方法，获取代理类

	所以动态代理的方法实现三个要点：被代理类，代理处理核心handler，生成代理类

	简单的代理生成，养成使用代理工厂的思想，将一套东西封装起来
	public class Proxyfactory {
	public Object target;//目标类，一般需要实现接口
	public Proxyfactory(Object target){
		this.target=target;
	}
	
	public  Object newProxyInstance(){
		//返回代理实例
		return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {
			@Override
			public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
				System.out.println("kaishiqian");
				method.invoke(target, args);
				System.out.println("kaishihou");
				return null;
			}
		});
	}
}

375、	Objects.requireNonNull(h);判断可是否为空，是抛出空指针异常

376、	classPathXmlApplicationContext.start(); 
		synchronized (Testmain.class) {

			while (true) {

							try {
								Testmain.class.wait();
							} catch (InterruptedException e) {
								System.out.println(e);
							}
		
						}

			}
	自定义启动类，启动dubbo     加上System.in.read(); 也行 详见dubbo 的官方文档

	使用线程和输入流是因为：保持服务提供，使用线程或者流的阻塞模拟

	<dubbo:protocol name="dubbo" port="20886"/> provider必要的属性

	

377、	常用的你得知道吧 dubbo 
	-DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下。

	-Dmaven.test.skip=true，不执行测试用例，也不编译测试用例类。

378、	hierarchical项目分层管理，常用的操作
	projects presentation：工程查看
	top level elements：工程或者目录
	package presentation：包查看


379、	对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；
	如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
	在匿名内部类中只能使用final变量，
	
380、	匿名内部类的使用中 	基于面向对象的思想，外部final变量作为参数传入进行对象构造，在调用对象的方法
	final Person person = new Person();
		person.setName("法海");
		person.setAge("101");
		new ISpiTestService() {
			
			@Override
			public void say() {
				person.setName("ad");
				Object json = JSONObject.toJSON(person);时
				System.out.println(json.toString());
			}
		}.say();

	匿名内部类直接使用相关接口，定义实现方法，传入final变量，一次性使用
	将final变量作为参数传入匿名内部类，构建成功
	

381、	首次的request请求到服务器，都会生成一个session，返回sessionid到客户端，之后的每次请求都会带sessionid到服务端获取相应的session

382、	spring的兼容问题：默认兼容之前版本的xsd
	spring的兼容问题spring-context-3.0.xsd低版本的问题

383、	hashset的去重功能还是可以使用的
	hashmap是无序 treemap有序
	Arrays.asList() 数组转list	
384、	本地的maven pom的配置在本地工程中已经完成了实现（当需要打包外显的时候才指定），所以直接部署tomcatserver即可，
	springboot是默认加载appplication.properties文件倒容器中直接${}读取即可
	一般的ssm工程中，使用maven的-p dev激活profile属性，在其<build>节点中过滤var到过滤器中，然后在<bulid>构建节点中<filtering>true</filtering>开启过滤器即可
385、	拦截器中的路径全匹配
	controller中路径不存在，进不了拦截器
	posthandler调用是在，dispatcherservlet进行视图渲染之前调用，这过程中可以处理mv，和prehandler执行顺序相反，
	afterconpletion在dispatcherservlet进行视图渲染之后开始执行，主要进行清理工作

386、	默认使用的target下的classpath和容器中的web-inf下的class一样的，暂不深究
	deployment assembly 容器中指定的默认的classpath	
	java build path java的编译路径指定classpath

387、	jsonobject对象put会覆盖相同key的内容，string转对象时候，相同key属性默认最后一个赋值

388、	默认conroller默认访问路径    @RequestMapping默认

389、	遇到的日志异常位置：
	tomcat的日志的问题 catalina.out和localhost文件的异常位置
	目前的错误日志问题手动抛出runtimeexcepton是在localhost文件下，jsp页面的错误也在localhost文件下

390、	String path = request.getContextPath();  
  
	String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";  
  
	<base href="<%=basePath%>">  
	获取项目的访问路径

391、	数据库左关联一定要吧需要关注的对象放在左边，重点在以谁为准

392、	UNION会自动删除重复项，刷选出部分字段的时候要注意了，如果刷选出来的两个字段的值完全相同就会剩下一个。

	UNION ALL 和 UNION 不同之处在于 UNION ALL 会将左右两个查询的结果的所有的资料都列出来，无论资料值有无重复。

393、	post请求的时候 传到后端的参数中文乱码：
	tomcat 中的编码   <Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="9443" URIEncoding="UTF-8"/>
394、	TreeMap默认实现的是对key进行排序 使用插入排序使用linkedhashmap
	按照一定的顺序排序后，使用MD5加密，可以实现验签的功能

395、	SELECT * FROM require_info WHERE delete_mark=0  ORDER BY id LIMIT 0,10 使用的limit顺序在最后
396、	Collections.max(list)  集合的最大值获取
	
	session.invalidate()退出登录时候清空session

397、	普通http请求和hessian  
	hessian也是轻量级的 ws服务，好处是不需要关心过程，调用时就像调用本地一样，毕竟是RMI，http的话，需要自己做好对象的解析，

398、	java类中的始终导入文件不进去，build path中的相关移除重新导入

399、	union all 的没有字段 null补齐

400、	@responseBody效果等同于response.getwriter.writer(jsonString)流输出

401、	-- 增加联合索引
	ALTER TABLE income_expense_detail ADD UNIQUE NO_ID_STATUS (ORDER_NO,ACCOUNT_NO,ITEM_ORDER_ID,TYPE);
402、	使用WebApplicationContextUtils在servlet中获取context

403、	使用sql工具先操作后查看语句，预览执行语句

404、	LIST<map<k,v>>  Mybatis返回的Map是这样的一种格式：Map<字段名称，字段值> 一个Map对象代表一行数据！ 	

405、	批量处理sql数据的问题 update table1  表关联即可

406、	pagecallback和servercallback 
		支付的pagecallback 关闭浏览器，redirect到浏览器的表单提交无法提交，request生命周期结束，无法页面表单提交回调
		回调区别在于是否要经过redirect的页面重定向
406、	pagecallback和servercallback 
		支付的pagecallback 关闭浏览器，redirect到浏览器的表单提交无法提交，request生命周期结束，无法页面表单提交回调
		回调区别在于是否要经过redirect的页面重定向
		
407、	使用treemap来实现加密时候的顺序一致问题

408、	eval `ssh-agent`		//启用ssh-agent
		ssh-add D:/id_rsa_zhanjun.zhanjun	//添加本地的私钥，使用的类似linux，系统的路径要使用反斜杠
		git branch -r 			//查看远程分支
		git remote prune origin 	//刷新远程不存在的分支


409、	键约束和索引

索引：
	大大加快数据的检索速度; 
	唯一性索引列允许空值。
	普通索引和唯一性索引：都可以提高查询效率，后者的值唯一，后者主要的作用是防止重复
	

外键：	ALTER TABLE pc ADD CONSTRAINT fk_cpu_model
	FOREIGN KEY (cpumodel)
	REFERENCES parts(model);
	ON UPDATE CASCADE;		//主表更新，字表也更新
	如果我们试着CREATE一台Pc，
	它所使用的CPU的型号是Parts表中不存在的，那么MySQL会禁止这台PC被CREATE出来。

	创建索引，例如CREATE INDEX <索引的名字> ON tablename (列的列表); 修改表，例如ALTER TABLE tablename ADD INDEX [索引的名字] (列的列表); 
	创建表的时候指定索引，例如CREATE TABLE tablename ( [...], INDEX [索引的名字] (列的列表) );
	
	创建唯一性索引，例如CREATE UNIQUE INDEX <索引的名字> ON tablename (列的列表); 修改表，例如ALTER TABLE tablename ADD UNIQUE [索引的名字] (列的列表); 
	创建表的时候指定索引，例如CREATE TABLE tablename ( [...], UNIQUE [索引的名字] (列的列表) );

410、	mysql的导出： 备份sql转储（注意database的勾选项）和导出数据（不包含表结构）

411、	
	复杂的关联语句 待定	
    <select id="getStatisticData" parameterType="int" resultMap = "statisticResult">
        select p.ID PAPER_ID,p.TITLE,p.CONTENT,p.SUM_ANSWER,q.ID QUESTION_ID,q.TITLE QUESTION_TITLE,q.TYPE,
        i.ID QUESTION_ITEM_ID,i.TEXT,i.CHECKED_NUM 
        from paper p 
        left join question q on p.ID =  q.SURVEY_ID 
        left join question_item i on q.ID = i.QUESTION_ID 
        where p.ID = #{id}
    </select>
    <resultMap type="main.java.com.gazi.survey.bean.SurveyInfo" id="statisticResult">
        <id property = "id" column = "PAPER_ID"/>
        <association property ="paper" javaType = "Paper">
            <id property = "id" column = "PAPER_ID"/>
            <result property = "title" column = "TITLE"/>
            <result property = "content" column = "CONTENT"/>
            <result property = "sumAnswer" column = "SUM_ANSWER"/>
        </association>
        <collection property="questionInfoList" ofType = "main.java.com.gazi.survey.bean.SurveyInfo$QuestionInfo">
            <id property = "id" column = "QUESTION_ID"/>
            <association property = "question" javaType = "Question">
                <id property = "id" column = "QUESTION_ID"/>
                <result property = "title" column = "QUESTION_TYPE"/>
                <result property = "type" column = "TYPE"/>
            </association>
            <collection property="questionItemList" ofType = "QuestionItem">
                <id property = "id" column = "QUESTION_ITEM_ID"/>
                <result property = "text" column = "TEXT"/>
                <result property = "checkedNum" column = "CHECKED_NUM"/>
            </collection>
        </collection>
    </resultMap>
		
412、	其实id跟result标签可以通用，只是id有特殊标识可以在影射的时候更快的匹配到，如果我没猜错的话这个id标识其实不是主键也能用

413、	<resultMap type="com.xiaoyuer.core.dmo.PersonAddressRelation"  id="BaseResultMapByTaxbureauId" extends="BaseResultMap" >
    	<association property="adminUser"  javaType="com.xiaoyuer.core.dmo.AdminUser">
  		<id property="id" column="Tax_Person_Id"></id>
  		<result property="userName" column="User_Name"/>
  	</association>
	暂时看来只是内部的排序，提高效率用，查询缓存，作为缓存key，

414、	在post请求中传递的参数中有带空格的，需要用url编码%20替换掉

415、	打包找打包的配置  pom.xml和 右击属性
	区别于打war和本地的target下的class使用，两种不同的使用场景
	<resource>
		<directory>../vars/${pay_env}/datasource</directory>
		<targetPath>WEB-INF/classes/config</targetPath>
	</resource>
416、	left join 和 where 的条件的限制不一样，前者是弱限制，后者是强限制

426、	　匹配方法只有三种，要么是路径匹配（以“/”字符开头，并以“/*”结尾），要么是扩展名匹配（以“*.”开头），要么是精确匹配，三种匹配方法不能进行组合，不要想当然使用通配符或正则规则。
　　	  如<url-pattern>/user/*.action</url-pattern>是非法的
	  另外注意：<url-pattern>/aa/*/bb</url-pattern>是精确匹配，合法，这里的*不是通配的含义
	
	匹配顺序：
	1、精确匹配，
	2、路径匹配，先最长路径匹配，再最短路径匹配servlet-mapping1：<url-pattern>/user/*</url-pattern>，servlet-mapping2：<url-pattern>/*</url-pattern>。当一个请求http://localhost:8080/appDemo/user/users.html来的时候，servlet-mapping1匹配到，不再用servlet-mapping2匹配
	3、扩展名匹配
	4、缺省匹配，以上都找不到servlet，就用默认的servlet，配置为<url-pattern>/</url-pattern>
	

	“/*”属于路径匹配，并且可以匹配所有request，由于路径匹配的优先级仅次于精确匹配，所以“/*”会覆盖所有的扩展名匹配，很多404错误均由此引起，所以这是一种特别恶劣的匹配模式，一般只用于filter的url-pattern
	“/”是servlet中特殊的匹配模式，切该模式有且仅有一个实例，优先级最低，不会覆盖其他任何url-pattern，只是会替换servlet容器的内建default servlet ，该模式同样会匹配所有request。
	配置“/”后，一种可能的现象是myServlet会拦截诸如http://localhost:8080/appDemo/user/addUser.action、http://localhost:8080/appDemo/user/updateUser的格式的请求，但是并不会拦截http://localhost:8080/appDemo/user/users.jsp、http://localhost:8080/appDemo/index.jsp，这是应为servlet容器有内置的“*.jsp”匹配器，而扩展名匹配的优先级高于缺省匹配，所以才会有上述现象。
	/*在filter中使用的较多

	而且当有一个servlet匹配成功以后，就不会去理会剩下的servlet了。  这个蛮重要的

	注意Filter的匹配规则与servlet一样，但对于filter，不会像servlet那样只匹配一个servlet，因为filter的集合是一个链，所以只会有处理的顺序不同，而不会出现只选择一个filter。Filter的处理顺序和filter-mapping在web.xml中定义的顺序相同。 
	精确路径 > 最长路径>扩展名

	<resources mapping="/resources/**" location="/resources/" />
    	<resources mapping="/images/**" location="/images/" />
    	<resources mapping="/js/**" location="/js/" />
	mapping：映射

	location：本地资源路径，注意必须是webapp根目录下的路径。
	
	两个*，它表示映射resources/下所有的URL，包括子路径（即接多个/）
	WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录
	
	静态资源映射不需要考虑jsp，容器自带*.jsp的匹配，相对/优先级别高，
 	即:/是匹配不带*.jsp的，
	   /*是全路径匹配，会匹配到*.jsp路径

427、	远程的代码库分支占用,本地是不能推送的  

428、	UNION ALL 的Order by，是依据最终的字段排序的
	mysql中的日期格式化	DATE_FORMAT(created_time, '%Y-%m-%d %H:%i:%s')

429、	<dubbo:registry check="false"/> 需要取消zookeeper的地址后才生效：关闭注册中心的检查，感觉没什么作用

430、	mysql中的数字格式化
	FORMAT（）目前是String类型展示，金额大会出现逗号
	round（）数字形式的格式化，没有逗号分割
	
431、	VerifyImage.java 	VerifyResult.java  图形验证
	1、使用的是随机生成Stringcode
	2、使用图片流将String转成相应的图片输出，使用的jar多为java.awt包下的内容
	3、生成的图片中的String存到缓存中，用于校验输入
	4、使用servlet配置在web.xml中生成和返回
	5、相关的代码已经上传github


432、	@Transactional
	建议是打在实现类的public（必须）方法上，不建议在类上声明使用，非必要的方法不需要使用事务管理
	和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，
	比如，可以将需要进行事务管理的代码块独立为方法等等。
	
	事务只有配置在public方法上，且是被外部调用时才有效，也就是说：事务配置在private和protected方法上肯定是没有用处的；
	事务配置在public方法上，但该public方法被内部调用时事务也是无效的。
	目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理

	问题解决。1. 使用public访求；2. 写在外部类中，可被调用； 3. 使用注入的方式进行该方法的执行。

	3.非事务声明方法调用事务声明方法，则事务失效。使用了@Transactional的方法，被同一个类里面的方法调用， @Transactional无效。比如有一个类Test，它的一个方法A，A再调用Test本类的方法B（不管B是否public还是private），
	但A没有声明注解事务，而B有。则外部调用A之后，B的事务是不会起作用的。（经常在这里出错）

	4.一个service中声明事务方法，调用了另外一个service中的声明事务方法，则被调用的方法事务也还起作用，事务不太建议放到2个见service中。下面的例子，下面的事务是起作用的，跟上面第3条写的注意区分：
	5、目前只能从外部方法开始另一个事务，否则内部调用的常规方法   先这样理解
	service内部的多个方法默认等效一个事务管理的常规方法，从外部的有效，内部想要有效需要注入自身的接口实现（不推荐），
	
	
	@Transactional放在类级别上等同于该类的每个公有方法都放上了@Transactional
	@Transactional只对公有法有效

	即使打上@Transactional标签的方法运行中抛出异常，是会往上级走的，上级需要处理

433、	增值服务的归集 多个httpclient请求 异常问题  间隔1秒 原因是支付端同时受到请求生成的orderno违反唯一索引

434、	使用枚举类型的简单例子
	public enum Color {  
    	RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4);  
    	// 成员变量  
    	private String name;  
    	private int index;  
    	// 构造方法  
    	private Color(String name, int index) {  
        this.name = name;  
        this.index = index;  
    	}  
		} 
		
435、	redis的缓存同步
	1.只做Mysql的增、删、改，同等需要删除Redis里的数据。
	2.读取Redis数据，只要不存在，就读取Mysql，并且装入Redis中。

	读数据：先读取缓存，若不存在则从DB中读取，并将结果写入到缓存中；下次数据读取时便可以直接从缓存中获取数据。
	改数据：直接失效缓存数据，再修改DB内容（避免突发情况：避免DB修改成功，但由于网络或者其他问题导致缓存数据没有清理，造成了脏数据）
436、	reset实现代码回退、还原  包括分支的tag也可以

437、	maven 提示可导 但是进不来 java buildpath重新设置下

438、	反射生成Java对象实例
	通过类对象调用newInstance()方法，适用于无参构造方法：
	
	通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，适用于无参和有参构造方法。
   	例如：String.class.getConstructor(new Class[] { String.class, int.class }).newInstance("Hello",10);

	java.lang.ClassLoader：类装载器类，将类的字节码装载到 Java 虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。
	Proxy类与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中。 

439、	使用匿名内部类访问外部方法的局部变量必须是final类型，但是访问成员变量不用

440、	gmt_create、gmt_modified使用DATETIME类型（精确到ss） date类型精确到dd
	SELECT IFNULL(orderstatus,0) FROM platform_order WHERE id=26721   id不存在 无法为空，无法转为0

441、	查看端口的占用情况：
	netstat -aon|find port
	a表示显示所用的连接    n表示显示出ip地址和端口号  不加n，显示是计算机的netbios名称和端口号
	可能查询到local和远程的调用方，以local为主

442、	Cast(字段名 as 转换的类型 ) sql中的数转换
	DATE_ADD(t.pay_date,INTERVAL 90 DAY) sql 中的日期加
	DATE_SUB(d,INTERVAL expr type) 	
 	DATE_FORMAT(ubm.deal_date,'%Y-%m-%d %H:%i:%S') 日期格式化

443、	在filter中需要注入相应的bean，

	在filter中获取spring的bean
	@Override 
	public void init(FilterConfig config) throws ServletException { 
	ServletContext context = config.getServletContext(); 
	ApplicationContext ac = WebApplicationContextUtils .getWebApplicationContext(context); 
	userService1 = (UserService)ac.getBean("userService"); 
	}

	在Spring Security，过滤器类也是定义在xml中的spring bean， 因此可以获得Spring的依赖注入机制和生命周期接口。 
	spring的DelegatingFilterProxy提供了在 web.xml和application context之间的联系。可以直接使用spring中的bean，暂时这样理解
	也可以理解为过滤器的代理
	作用是自动到Spring容器查找名字为shiroFilter（filter-name）的bean并把所有Filter的操作委托给它。

	shiro 中的session 中 request.getSeesion()与subject.getSeesion()获取session后，对session的操作是相同的。
444、	java项目中的源文件和生成文件：
	ac_service 中的目录结构问题   bin中是生成的  package下的才是最新的

445、	git的基于a点回退，但是a之后又有b点的提交，切换新分支，根据commitId挑选

446、	本地线程变量
	ThreadLocal并不能替代同步机制,线程同步时共享了同一个变量,但ThreadLocal变量是线程之间相互独立的，
	ThreadLocal不是用来解决对象共享访问问题的，而主要是提供了线程保持对象的方法和避免参数传递的方便的对象访问方式 
	ThreadLocal的应用场合，最适合的是按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。
	我觉得threadlocal更多是解决了同一个线程里参数的传递问题。 

	概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，比如定义一个static变量，同步访问，而ThreadLocal采用了“以空间换时间”的方式。
	前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。

	函数调用栈比较深以及代码入口的多样性，使用threadlocal实现线程内的资源共享，每个线程都有自己的资源副本
	若多个线程之间需要共享资源，以达到线程间的通信时，就使用同步机制；若仅仅需要隔离多线程之间的关系资源，则可以使用ThreadLocal


447、	右击class中的类名获取包名,右击文件是获取/路径的	

448、	多线程相关：
	多线程中的Future.get()没有结束会一直阻塞

	线程池中调用	ExecutorService
	 shutdown调用后，不可以再submit新的task，已经submit的将继续执行。
        shutdownNow试图停止当前正执行的task，并返回尚未执行的task的list。

	ListenableFuture可以监听的Future，是Future的扩展增强。我们知道Future表示一个异步计算任务，当任务完成时可以得到计算结果。如果我们希望一旦计算完成就拿到结果展示给用户或者做另外的计算，就必须使用另一个线程不断的查询计算状态。
	使用ListenableFuture.addCallback()检测Future,如果完成就自动调用回调函数，这样可以减少并发程序的复杂度
	可以使用RateLimiter  并发限流器
	如果我们关心线程池执行的结果，则需要使用submit来提交task，使用Future处理，
	如果我们不关心这个任务的结果，execute方法（实际是继承Executor接口）来直接去执行任务，

	实现线程的三种方法需要总结
	1、继承tread类
	2、实现runnable接口
	3、实现callable接口，搭配线程池使用，可以实现带返回结果future

449、	springboot中的：
	WebMvcConfigurationSupport 与WebMvcConfigurerAdapter 都可以配置MVC,WebMvcConfigurationSupport 支持的自定义的配置更多更全，WebMvcConfigurerAdapter有的WebMvcConfigurationSupport 都有

450、	线程的相关：

	一个进程中同时有多个线程在运行
	实现Runnable接口比继承Thread类所具有的优势：
	2）：可以避免java中的单继承的限制
	4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类


	在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。
	因为每当使用java命令执行一个类的时候，实际上都会启动一个ＪＶＭ，每一个ｊＶＭ实际在就是在操作系统中启动了一个进程。 
	thread类中的setPriority方法可以设置优先级

	sleep()和yield()的区别
	sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；，sleep进入阻塞状态，
	yield()让出 CPU 占有权，时间是不可设定的，同级别的让步，让步到就绪状态，使当前线程重新回到可执行状态

	yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程
	另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield()  方法执行时
	①、sleep方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而yield方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态。
	②、sleep方法声明抛出了InterruptedException，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。而yield方法则没有声明抛出任务异常。
	sleep相对于wait：
	sleep可以在任何地方使用。而wait，notify，notifyAll只能在同步控制方法或者同步控制块中使用。
	sleep必须捕获异常，而wait，notify，notifyAll的不需要捕获异常。

	wait(),notify(),notifyall(),  在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这3个方法都是Object类中的方法。
	
	线程执行wait()后，就放弃了运行资格，处于冻结状态；线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify()执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程。notifyall(), 唤醒线程池中所有线程。
	
	Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。


	isDaemon 是否是守护线程，守护主线程，主消失 守护消失，不用手动触发
	Callable的future模式：并发模式的一种，可以有两种形式，即无阻塞和阻塞，分别是isDone和get。其中Future对象用来存放该线程的返回值以及状态
	Thread.sleep()对当前正在运行的线程睡眠
	实际测试的时候synchronized加在方法上的，方法体内sleep，另一个线程是等待的，进不来

	join在当前的线程中加入该线程，主线程等待子线程的结束
	
	结束线程的安全方案：
	正常执行完run方法，然后结束掉；
    	控制循环条件和判断条件的标识符来结束掉线程。

	多线程的并发操作中，为了保证变量的唯一性和准确性，需要对加入同步锁
	
	synchronized关键字一般用过来修饰方法，锁住相关的方法，也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类
	同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。

	synchronized锁住的是代码还是对象。答案是：synchronized锁住的是括号里的对象，而不是代码。对于非static的synchronized方法，锁的就是对象本身也就是this。实现同步必须是同一个对象（是锁方法所在的对象），如果不是同一个对象，那么多个线程同时运行synchronized方法或代码段
	用synchronized关键字的时候，能缩小代码段的范围就尽量缩小，减小锁的粒度，使代码更大程度的并发

	上面代码用synchronized(Sync.class)实现了全局锁的效果。
	

	synchronized锁在方法上也相当于锁住了整个实例对象，sleep过程中其他的所方法也不能执行

	static synchronized方法，static方法可以直接类名加方法名调用，方法中无法使用this，所以它锁的不是this，而是类的Class对象，所以，static synchronized方法也相当于全局锁，相当于锁住了代码段，锁住了整个类对象
	
	lock锁相对于synchronized同步锁：
	那么lock和synchronized的区别对比如下：
	1）synchronized 在成功完成功能或者抛出异常时，虚拟机会自动释放线程占有的锁；Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
	2）synchronized是java内置关键字，在jvm层面，Lock是个java类；
	2）lock接口锁可以通过多种方法来尝试获取锁包括立即返回是否成功的tryLock(),以及一直尝试获取的lock()方法和尝试等待指定时间长度获取的方法，相对灵活了许多比synchronized;
	3) 通过在读多，写少的高并发情况下，我们用ReentrantReadWriteLock分别获取读锁和写锁来提高系统的性能，因为读锁是共享锁，即可以同时有多个线
	4）synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）
	5）synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；使用tryLock()返回结果
	6）不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。
	
	线程池 
	ExecutorService executorService = Executors.newFixedThreadPool();使用静态类工厂创建线程池，也可以用装饰监听MoreExecutors.listeningDecorator(），一般用到的方法是submit()返回结果future
	使用ExecutorService线程池，最后shutdownNow（）和shutdown（），后者不再接受新的线程请求，处理完所有线程关闭，前者立即关闭
	线程锁的相关概念：
	公平锁以请求锁的顺序来获取锁，非公平锁则是无法保证按照请求的顺序执行
	线程中的集中锁的分类：
	1、重入锁
	2、可中断锁
	3、公平锁
	4、读写锁
	
	多线程特殊写法，但是不推荐
	直接重写方法也行
			new Thread(){
					public void run(){
						for (int i = 0; i < 10; i++) {
							System.out.println("123123");
						}
					}
				};


	





451、	实现md5加密的：
	public static String md5Encode(String inputStr) {  
        MessageDigest md5 = null;  
        try {  
            md5 = MessageDigest.getInstance("MD5");  
            byte[] bytes = inputStr.getBytes("UTF-8");  
            byte[] md5Bytes = md5.digest(bytes);  
            StringBuffer hexValue = new StringBuffer();  
            for (int i = 0; i < md5Bytes.length; i++) {  
                  
                int value = ((int) md5Bytes[i]) & 0xff;  
                  
                if (value < 16) {  
                    hexValue.append("0");  
                }  
                hexValue.append(Integer.toHexString(value));  
                  
            }  
            return hexValue.toString();  
              
        } catch (Exception e) {  
            return "";  
        }    
    }  
	总的过程是使用md5加密返回16长度的byte[]，使用16进制转换将每个byte转为两位的16进制，这样最终生成的固定长度的32位字符串

451、	内存相关：
	
	在jstack分析工具中，查找相关的线程，标记为daemon的线程是守护线程，一般查找问题定为的是主线程

	设置jvm的内存  可以在eclipse中的配置jdk的 default vm argument 中设置 ；也可以在eclipse.ini中设置，也可以右击工程run as 最下面配置项中的arguments中配置vm
	jvm的相关概念：
	两种类型的内存：
	堆（heap）：-Xms 初始分配内存 -Xmx最大分配内存，服务器一般设置-Xms、 -Xmx相等以避免在每次GC 后调整堆的大小
	非堆：也叫永久保存的区域，运行时gc不会释放其空间
	-XX:PermSize设置非堆内存初始值，XX:MaxPermSize设置最大非堆内存的大小

	使用jstack 定为死循环，线程阻塞、死锁问题”
	找到cpu中使用率较高的进程，或者制定端口的pid去查看
	C:\Users\xiaoyuer>jstack -l  13452 >> 123.txt  必须制定到uses目录下
	1、cmd输入jps 查找进行中的java进程
		-q：仅输出VM标识符，不包括classname,jar name,arguments in main method 
		-m：输出main method的参数 
		-l：输出完全的包名，应用主类名，jar的完全路径名 
  	2、jstack 进程id 查看进程中的线程， 日志中可以看到相关线程的运行状态，其中daemo是守护线程
	3、在日志中查找相关的代码情况，线索就是相应的包目录，

	******查看WAITING的线程，重点查看包含自己代码行的方法调用栈。******

452、	shiro相关：
	SecurityManager：我们知道其在Shiro中的地位，类似于一个“安全大管家”，相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher，是Shiro的心脏，所有具体的交互都通过SecurityManager进行控制，它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理

	shiro三大核心模块：Subject（用户）、SecurityManager(框架心脏)、Realm（Shiro与应用安全数据间的“桥梁”）

	shiro.xml中配置ShiroFilterFactoryBean时候，在容器中注入的是filterbean，拦截/*请求，未登录，跳转loginUrl,unauthorizedUrl是没有权限跳转的路径

	securityManager中继承了多个功能模块（继承链由顶端向下）：
	1、CachingSecurityManager			主要提供缓存支持，管理缓存操作
	2、RealmSecurityManager				可理解为数据处理组件，比如Realm根据用户名数据库，和输入的用户密码比对，验证登录，还有授权数据等）
	3、AuthenticatingSecurityManager	实现接口Authenticator，处理用户登陆验证的 SecurityManager 的 抽象实现，仅仅代理Authenticator
	4、AuthorizingSecurityManager		实现了Authorizer接口的抽象类，该类主要代理Authorizer进行授权
	5、SessionsSecurityManager			实现类SessionManager的方法。代理了SessionManager来处理相关的session操作。
	6、DefaultSecurityManager			默认的SessionManager的具体实现，该实现类会合适的初始化依赖组件。如subjectFactory、SubjectDAO
	7、DefaultWebSecurityManager		WebSecurityManager实现被使用在web应用程序中或者需要http请求的应用程序中（如SOAP，http remoting, etc）

	shiro的session是自己实现的，项目中是用的是redis作为缓存的框架

	解析ini中的section，最终将每个section解析成为linkedmap使用   map<String,section> 配合scanner解析
	ini.sections    Map<String, Section> sections
	  
	在ShiroFilterFactoryBean.createInstance实例化的过程中 FilterChainManager manager = createFilterChainManager()讲默认的filter和自定义的filter加载进来，使用的是manager.addFilter()


	// 参数chainName形如 /admin/list**
	// 参数chainDefinition形如 authc,perms[admin:manage]  每个前置元素表示的是一个filter，默认的和自定义的都会继承AccessControlFilter
	[]中的只是作为filter的参数传递进去，并做相应的处理

	// foo[bar, baz]       	returned[0] == foo
				returned[1] == bar, baz 
	/ 保存用户配置的url与filter之间的映射关系
	applyChainConfig(chainName, filter, chainSpecificFilterConfig);
 
 	filterChainDefinitions 从上到下，从左到右，如果有匹配的拦截器就会阻断并返回
  
 	在SecurityUtils.getSubject().login(token);获取的时候会获取securityManager实例中的realm，调用realm实例中的认证方法
  
  	loginfilter中的返回false后会调用WebUtils.issueRedirect(request, response, loginUrl)跳转到loginUrl

	<bean id="shiroManager" class="com.sojson.core.shiro.service.impl.ShiroManagerImpl"/>
	<property name="filterChainDefinitions" value="#{shiroManager.loadFilterChainDefinitions()}"/> 
	在xml中，相当于使用了一个bean实例调用了其方法返回了结果，但是在方法中需要使用ini4j的解析器，解析出String格式的ini信息
	

	一些常用的java类
	SimpleAuthorizationInfo		用于存放该用户的权限和角色信息，授权的专用类
	SimpleAuthenticationInfo	用于认证成功后返回的认证信息	

	
	用户查看	session中使用的是传递sessionid找到redis中的session信息，在找到session中的用户信息

	踢出功能  	session存在 但是session中设置的status失效

	根据前段的页面 使用的shiro标签 判断相应的权限控制展示



	shiro 框架：
	在return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);    有一个执行成功就可以了

	缓存使用
	如果在项目中并未使用shiro的jsp标签库，那么使用集中式的缓存方案也未尝不妥；但是，如果大量使用shiro的jsp标签库，那么采用本地缓存才是最佳选择。

	ehcache是内部缓存，速度快，跟随java程序存在，项目重启缓存消失，但是redis是独立的缓存，可以持久化

	cachemanager和sessionmanager，前者负责缓存实现，比如大量的登录信息和权限信息，后者是服务端的session保存

	项目的欢迎页是配置在web.xml中，使用jsp页面的重定向manage/index实现跳转


	@RequiresPermissions 标签
	首页和登录成功返回：
	先访问的是欢迎页中的index.jsp，重定向manage/index,登录拦截求拦截登录，成功后再根据redirectUrl跳转相应的地址，没有则默认数据库中的主页地址
	filter中的servletrequest可以向下强转为httpservletrequest使用

	redis中的lpush 和lrange  往链表里添加元素，类似栈
	
	shiro中配置的自定义filter一般都需要继承accesscontroller，实现统一的认证授权方法
	捕获subject.login（）方法的异常返回相关的信息
	
	配种filter链的时候，filter后面可以附带参数，后端用mappedValue接收，这里引申出权限的两种方案，

	1、在filter链中带上相应的权限，后端校验使用(subject.isPermitted(permission))使用，这个方法会调用realm的授权方法，在filter中就重定向到无权限页面
	2、使用@RequiresPermissions指定需要的权限，配合realm类

	/manage/** = upmsSessionForceLogout,authc["a","b","c"]

	cookie携带，页面是https，ajax也是https请求 即可，和nginx的转发无关
 
	
	
	文件，图片的上传和下载

	dubbo的优雅停机
	调用权限认证的入口
	1、subject.hasRole(“admin”) 或 subject.isPermitted(“admin”)：自己去调用这个是否有什么角色或者是否有什么权限的时候；
	2、@RequiresRoles("admin") 或者@RequiresPermissions（）：在方法上加注解的时候；
	3、[@shiro.hasPermission name = "admin"][/@shiro.hasPermission]：在页面上加shiro标签的时候，即进这个页面的时候扫描到有这个标签的时候。

	在配置filter工厂ShiroFilterFactoryBean，会将loginurl等参数set进相应的filter中
	
	使用httpclient的时候，httpget请求获取信息，
	
	@ExceptionHandler和@ControllerAdvice能够集中异常，使异常处理与业务逻辑分离

	获取subject对象
	
	shiro中loginfilter中的redirect后获取session，顺带考虑下sso的相关问题
	
	SecurityUtils中的securitymanager需要使用
	
	ThreadContext中的线程变量中存的是map类型，value就是shiro中的subject

	shiro中的subject
	
	shiro中的缓存和session方案还需看看

	subject.isAuthenticated() 登录成功为true
	
	sessionmanager中配置sessiondao（使用缓存管理session），
	
	cachemanager，只是返回了一个rediscache， 实现两个接口，manager只返回cache对象，cache对象中封装redis操作，需要配置使用redis来管理rediscache

	remenberme的cookie秘钥需要使用ase算法生成存进去，记住动能子subject中能获取principal对象
	
	remenberme标记和认证标记是互斥的，
	
	shiro中配置缓存，和缓存管理器，都需要实现相应的接口，最终操作的还是cache的对象，使用redis的操作，序列化存放比较多，但是不方便查看
	使用JedisManager，每次操作从jedispool中获取一个jedis实例操作，
	@PostContruct 是spring中的一个注解，会在项目启动时执行该方法
	实现了cache缓存后，认证的信息会先从缓存中读取，不一定每次都读取realm中的授权方法

	配置session也是相关的session操作放进相关的property即可，
	
	还缺少shiro中的sso相关




















	
453、	在tomcat中的web.xml中配置欢迎页，先判断静态页面存不存在，存在根据路径还有可能被前端控制器拦截转向动态的页面

454、	maven和源码相关：
	在maven的配置选项中勾选源码下载
	jar包中的class中文乱码   修改workspace下的编码utf-8 和 content tyes下的text 为uf8，重开工程即可

455、	maven多环境
	<build>
		<filters>
			<filter>../vars/vars.pre.properties</filter>
		</filters>
	</build>
	<resource>
                <filtering>true</filtering>
        </resource>	
	pom.xml中，集中开启过滤器，在resource标签中开启

465、	继承PropertyPlaceholderConfigurer，可以对properties中的某些属性进行加密解密

467、	dubbo两次加载导致端口占用的问题：
	autoDeploy="false" deployOnStartup="false"	
	 			

468、 linux安装mysql：
	linux下安装 mysql https://www.linuxidc.com/Linux/2016-09/135288.htm
	注意和centos的系统版本匹配 
	不行重新yum  clean all 
	yum install mysql-community-server
	service mysqld start 启动

	grant 权限 on 数据库.数据表 to '用户' @ '主机名';

	例：给 xiaogang 分配所有的权限

	grant all on *.* to 'xiaogang'@'%';

	这个时候 xiaogang 就拥有了 所有权限了
	 show grants for current_user() ; 当前登录用户的权限

	SHOW GLOBAL VARIABLES LIKE 'port' 查看mysql的端口号
	mysql中的创建密码，password("123123") ，自带加密

	mysql中的root用户权限消失，重命名var/lib/mysql  然后重启，重启生成目录，然后将原先的重要数据(ibdata1，和db相关)copy过去即可，再次重启service mysqld restart

	问题：
	今天开发中在Centos7中安装MySQL5.6版本后，在表中新建了一个weicheng的账户，并且设置了密码，但是在用weicheng账号登陆mysql发现，如果使用“mysql -uweicheng -p”登陆会报错，即使密码正确也不能登录，最后发现，直接用“mysql -uweicheng”不输入密码也可以登陆。
	后来，查询了资料原因是:应为数据库里面有空用户,通过
	select * from mysql.user where user='';
	查询如果有，然后通过
	use mysql;
	delete from user where user = '';
	删除了多余的空白账户， 然后，通过
	flush privileges;
	重载一次权限表,最后用
	service mysqld restart
	重启mysql服务，问题得到解决，至此mark一下！
	Tip：
	1、一定要记住重启mysql服务，否则不会生效，自己就是因为没有重启msyql导致一直得不到解决！
	2、msyql的用户表在mysql数据库中的user表中，主要字段有host，user，password等，作为mysql用的管理的主要表。

	MYSQL：使用\G参数改变输出结果集的显示方式

469、	maven install  默认是将src/main/java 和 src/main/reources打包
	勾选maven下载项的源码选项，点击class文件查看文件所在位置，添加相关的resource文件
	jar包的引用，一般打成的格式是和meta-inf同级的目录是直接可以访问的

470、	String.format("%s%s ", fieldName) 字符串的拼接问题，%s代表一个站位符

471、	动态的数据元切换：
	动态数据源的切换，即xml中配置的datasource，是一定要继承AbstractRoutingDataSource类的，再aop的标签类，根据方法动态放入配置的数据源
	动态切换数据源和service的事务关系：
	原因在于：出现多数据源动态切换失败的原因是因为在事务开启后，数据源就不能再进行随意切换了，也就是说，一个事务对应一个数据源。
	<tx:annotation-driven transaction-manager="transactionManager" order="2"/>  
	修改事务管理器的数据源为动态数据源，指定事务注解的排序为2，我们会指定切换数据源的注解为1，这样在事务之前切换数据源，否则在事务之后切换的的话，无效。
	定义数据源的aop标签加载顺序是1，保证数据源在事务之前
	@Aspect  
	@Order(1)  


	配置spring的事务模板的时候，transactionTemplate需要指数据库的事务管理器transactionManager
	<bean id="netpayTransactionTemplate"
		class="org.springframework.transaction.support.TransactionTemplate">
		<property name="transactionManager">
			<bean
				class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
				<property name="dataSource" ref="dataSource" />
			</bean>
		</property>
	</bean>

	这样才能进行数据库事务的相关操作


	<tx:advice id="transactionAdvice" transaction-manager="transactionManager">
 	<tx:attributes>
   	<tx:method name="add*" propagation="REQUIRED"/>
  	</tx:attributes>
 	</tx:advice> 
 	<!-- 配置数据库注解aop -->
 	<bean id="dataSourceAspect" class="com.we.database.DataSourceAspect"/>
	 
	<aop:config>
  	<aop:pointcut id="transactionPointcut" expression="execution(* com.wewe.licai.service..*Impl.*(..))"/>
  	<aop:advisor pointcut-ref="transactionPointcut" advice-ref="transactionAdvice" order="2"/>
 
  	<!--数据源选择切面,保证在事务开始之前执行-->
  	<aop:advisor pointcut-ref="transactionPointcut" advice-ref="dataSourceAspect" order="1" />
 	</aop:config>
	实现接口MethodBeforeAdvice该拦截器会在调用方法前执行

        实现接口   AfterReturningAdvice该拦截器会在调用方法后执行

        实现接口  MethodInterceptor该拦截器会在调用方法前后都执行，实现环绕结果。
 	数据源的切换，aop的代码实现，aop实现过程中可以根据方法名选择数据源，也可以自定义标签加载相应的数据源
	<aop:advisor>  	配置的advice需要实现以上的相关接口
	<aop:aspect>	使用标签指定相关的方法
	都可以实现aop的配置

472、	nginx和hosts文件的相关:
	http://www.yu.com/xye-open/gateWay/systemGateWay.htm请求先经过本地的host文件解析到本地的请求，在经过nginx转发ip路径到相应的服务器，但是服务器的请求requesturl还是原地址www.yu.com的
	
	目前请求先进过host域名解析在经过ningx转发

473、	and	(pc_code!='7007' OR pc_code IS NULL)    	null的直接就不在比较的范围内

474、	web项目的工程名 properties中web projects setting中修改

475、	普通类继承抽象类，必须实现父类的抽象方法，也可以重写父类的非抽象方法

476、	AntPathMatcher路径的匹配工具类
	class文件是编译出来的，代码问题失败也会编译进去

477、	tomcat相关：


	防止项目加载两次
	<Host appBase="webroot" autoDeploy="true" name="localhost" unpackWARs="true">
       
       	<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" pattern="%h %l %u %t &quot;%r&quot; %s %b" prefix="localhost_access_log." suffix=".txt"/>

478、	高并发相关：
	soa的两次同时请求
	在分布式的接口重试调用考虑接口的幂等性的问题：
	1、缓存解决方案：非业务性
		在要求幂等性协议的接口上，调用方传递一个全局唯一id，server方通过aop拦截参数id，数据缓存中查找，存在返回，不存在就进行业务的处理，处理成功，存入缓存，有失效时间
	2、数据库解决方案：
		业务性的去重，比如业务判断，建立联合唯一索引
		数据库的乐观锁
	
    	<Context docBase="../webapps/XiaoyuerProject" path="/" reloadable="true" source="org.eclipse.jst.jee.server:XiaoyuerProject"/></Host>


479、	git-zheng相关：
	fluent-validator 是一款百度开源的简洁验证框架，了解一下可以了
	Result result = FluentValidator.checkAll()
		.on("go", new NotNullValidator("cjhanu"))
		.on("go", new LengthValidator(3, 5, "changdu "))
		.doValidate().result(toSimple());
	使用的 toSimple方法是import static com.baidu.unbiz.fluentvalidator.ResultCollectors.toSimple 导入进来的

	继承AbstractRoutingDataSource类，配合aop原理，切到使用自定义标签的方法上，拿出自定义数据源的标签中的数据源的值，放到相应的treadlocal中，每次执行sql都会选取对应的数据源执行操作，动态数据源切换

	但是这个由于有多个数据源导致我们只能管理默认的数据源的事务！，涉及回滚的时候，尽量读从库，写主库，主备份到从
	实现数据源的切换注意事务的问题，必须要指定事务管理器在aop标签之后


	实现jsp等静态文件的项目共享，可以打成jar包依赖，然后在servlet初始化时解压jar到相应的目录即可：JarUtil.decompress(jarPath, resources);

	ZhengAdminUtil implements InitializingBean, ServletContextAware  只要将类注入spring中，初始化的时候进行相关操作即可

	和meta-inf同级的静态文件是可以直接访问的，类似于web-app文件下

	serveletContext.getRealPath得到根路径，tomcat中比如是	c:\tomcat\webapp\test

480、	eclipse中的bookmark功能 暂留可能会用


481、	rocketmq：
		1、下载源码后进入主目录，执行mvn -Dmaven.test.skip=true clean package install assembly:assembly   -p release-all  -U
    		在target目录下拿到压缩包，使用相关的即可
		2、Unrecognized VM option 'MaxMetaspaceSize=1024m' rocketmq4.2.0版本使用的是jdk1.8，需要统一版本

		原理相关：
		1.其中的nameserver相当于zookeeper，服务的发现，
		2.nameserver和broker之间是，b发30s心跳发送和2min检测断开
		3.客户端指定nameserver的地址，与其长连接，连接后定时查看topic路由信息，默认时间30s
		4.broker的持久化，。采用的是ext4文件系统，同步刷盘：写入后告知生产者；异步：收到消息就告知生产者，再异步从内存写入到磁盘
		6.消费者中同一个Group中的实例，在集群模式下，以均摊的方式消费；在广播模式下，每个实例都全部消费。
		7.广播消费，一条消息被多多个同组中的consumer消费，
		8.messagequeue是一个长度无限的数组，offset是下标
		9.消费去重，保证幂等性，重复情况少，一般建议业务去重


		
		mq 的 .RemotingConnectException     需要设置producer.setVipChannelEnabled(false);  

		mq目前看producer是先start 后发送信息，
		consumer是先注册监听后start



	监听者监听不到消息，换用tomcat不要重复启动
    	<Host appBase="webRoot" autoDeploy="true" name="localhost" unpackWARs="true">
        	<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" pattern="%h %l %u %t &quot;%r&quot; %s %b" prefix="localhost_access_log." suffix=".txt"/>
		<Context docBase="../webapps/xye-paycore-war" path="/xye-paycore" reloadable="true" source="org.eclipse.jst.jee.server:xye-paycore-war"/>
	</Host>
    	
  	从微信公众号匠心零度的结论看，由于tomcat的热部署原因引起的，启动了多个同样消费端，消息均分配，则会丢失消息，将autoDeploy="true"，应该改为false


482、	装饰模式：
	//装饰器模式的写法，必须将被装饰的对象初始化到装饰类中
	HttpServletRequestWrapper的使用  
	HttpServletRequestWrapper 是HttpServletRequest的装饰器。
	一般在filter中装饰request对象，进入servlet中，相当于封装了相应的request

483、	springbean中的三种初始化和销毁方法
	1、使用@PostConstruct注解初始化，使用@PreDestroy注解销毁Bean
	2、实现InitializingBean, DisposableBean这两个接口，并复写afterPropertiesSet()和destroy()方法
	3、使用init-method和destroy-method配置方法，在xml中注入时补全

484、	<context:annotation-config> 开启已在spring容器中注册过的bean（无论是通过xml的方式还是通过package sanning的方式）上面的注解。
	<context:component-scan>除了具有<context:annotation-config>的功能之外，<context:component-scan>还可以在指定的package下扫描以及注册javabean ，这一个标签足够了，上面的不需要
	<mvc:annotation-driven/> 是mvc 必须的标签


485、	xstream:xml 和 java对象之间的转换工具类   
	XStream
	XStream.alias("INFO", InfoReq.class);	相当于将类路径的标签转换为自定义的标签，节点重命名

	xstream.aliasField("author", Blog.class, "writer");     不使用别名，还是要使用具体的class

	使用隐式集合:	xstream.addImplicitCollection(Person.class, "list");
		<list><element><element /></list>   变为 <element><element />


	XStream的优点很多，但是也有一些小bug，比如在定义别名中的下划线“_”转换为xml后会变成“__”这个符号。
 	IOUtils.copy(fis, toClient);可以直接实现文件从输入流到输出流的文件写入
 	try {
            toClient = new BufferedOutputStream(response.getOutputStream());
            fis = new BufferedInputStream(new FileInputStream(myfile));
            IOUtils.copy(fis, toClient);  //通过ioutil 对接输入输出流，实现文件下载
            toClient.flush();
        } catch (Exception e) {
            throw new RuntimeException("文件下载失败");
        } finally {
            //关闭流
            IOUtils.closeQuietly(fis);
            IOUtils.closeQuietly(toClient);
        }
	

486、	
	SEVERE: Error configuring application listener of class org.springframework.web.context.ContextLoaderListener

	解决方案：
	1. 打开工程属性对话框，到Deployment Assembly页面，将maven依赖添加进来

487、	jar不是从库中拿，而是从本地获取
	<dependency>
	    <groupId>org.hamcrest</groupId>
	    <artifactId>hamcrest-core</artifactId>
	    <version>1.5</version>
	    <scope>system</scope>
	    <systemPath>${basedir}/WebContent/WEB-INF/lib/hamcrest-core-1.3.jar</systemPath>
	</dependency>

	${basedir} pom.xml中的同级目录

488、	
	String property = System.getProperty("user.dir");
	在tomcat中部署显示     D:\apache-tomcat-sso\bin
	在eclipse中显示	       D:\eclipse
	C:\Users\xiaoyuer\git\xye-netpay\xye-netpay-pom\xye-netpay-service/file/  windows系统的路径显示，在项目后的地址为/


489、	TokenInterceptor 中一次token一次使用 相连的两个方法  使用场景就是session先存一个 后面再用一个，用的是自定义注解，实现session中值的连续使用

490、	nginx配置文件 和ssl证书     安装OpenSSL  相关的命令生成key和crt文件	https://www.cnblogs.com/chasewade/p/7661290.html

491、	配置path的作用
	1.程序的执行需要使用外部指令javac，但是javac指令仅仅能在JDK安装目录下的bin目录下运行，因此java程序只能写入bin目录。这样bin目录会很乱，不易管理。 
	2. 程序开发过程中，不能将源代码写入JDK的安装目录，因此需要将源程序保存到任意位置的指定目录(英文目录)，所以需要使javac指令在任意目录下可以运行。


492、	pagacallback的回调	redirect的请求是依赖于浏览器的
	servercallback的回调 是基于http请求，两种请求是网银同时回调的.这边处理一般server延迟2秒执行

493、	直接在页面js启动加载
	<script>
		function jump(){
			var url = '${payGateWayRequestUrl}';
			location.replace(url);
		}
		window.setTimeout(function(){jump()},1);
	</script>



494、java String的split方法容易犯的错误
		今天用split方法分割一个类似"9580|9570|9571"的字符串,用Arrays.asList将String[]转成List,结果却是这样
		[9,5,8,0,|,9,5,7,0,|,9,5,7,1]
		列出几个要点
		首先java doc里已经说明, split的参数是reg, 即正则表达式, 如果用"|"分割, 则需使用"\\|"
		用* 分隔字符串运行将抛出java.util.regex.PatternSyntaxException异常，用加号 + 也是如此, 因此也应加入"\\"
		如果字符串中包含"\",首先这个字符串中的"\"需要转义, 即为"\\", 用split时需要写成split("\\\\"), 例子如下System.out.println(Arrays.asList("aaa\\bbb\\bccc".split("\\\\")));
		可以这样思考, 要写成用"\"分割,则首先需要转义"\\", 同时要让"\\"在正则表达式中有意义, 还需在第一个"\"和第二个"\"前面再加一个"\", 就变成了四个"\".

495、	for (NetPayRefund netPayRefund : refundWxScan) 多个遍历的使用相同的单一变量名ok

496、	linux上的tomcat启动使用的是sit_yunwei的权限操作的，那么运行的java代码也只有运维的权限，不能在/usr/local下创建目录

497、	日志分类，主要关注运行catalina.out,和启动的localhost.log
		catalina.out即标准输出和标准出错，所有输出到这两个位置的都会进入catalina.out，这里包含tomcat运行自己输出的日志以及应用里向console输出的日志。
		catalina.{yyyy-MM-dd}.log是tomcat自己运行的一些日志，这些日志还会输出到catalina.out，但是应用向console输出的日志不会输出到catalina.{yyyy-MM-dd}.log。
		localhost.{yyyy-MM-dd}.log主要是应用初始化(listener, filter, servlet)未处理的异常最后被tomcat捕获而输出的日志，而这些未处理异常最终会导致应用无法启动。
		
498、	在a merge b    b->a,本源合并  

499、	编码转换
			utf-8系统接收中兴的gbk编码问题，直接在文件流中转即可，看了半天
			BufferedReader in = new BufferedReader(new InputStreamReader(
								urlCon.getInputStream(),"GBK"));
						StringBuffer strBuff = new StringBuffer();
						String line;
						while ((line = in.readLine()) != null) {
							strBuff.append(line);
						}
						return strBuff.toString();


			DS205[平台商户未签约支付渠道1004]  gbk的流使用utf8解码，自然是乱码的字符串，然后再用乱码字符串进行utf8编码，本来就不识别的码的字符串，自然转不成正确的字符串


			String.getBytes("encoding")的意思:
			odd=new String(odd.getBytes(),"GBK"); 使用utf8编码在用gbk解码肯定乱码
			把JVM内存中unicode形式的String按encoding制定的编码，
			JVM内部的String，Char都是用unicode存储(没有任何编码)

			26 	12个字+4数字
			42	15个字+4数字
			字符串：平台商户未签约支付渠道1004    gbk 26个字节
			GBK转成utf8后乱码，gbk字节使用utf8解码：?????δ?? ???????1004
			再将乱码使用utf8编码 得到42 个字节，得到的不是原来的字节了
			所以对传输的东西，使用相应的编码解码
			
500、	小秘书的数据源选择
		根据环境选择数据源   使用jndi-JndiObjectFactoryBean，使用配置的数据源-DataSourceBuilder

		@Bean(destroyMethod="")
			public DataSource jndiDataSource() throws IllegalArgumentException, NamingException {
				Properties pro = new Properties();
				InputStream input =Application.class.getClassLoader().getResourceAsStream("application.properties");
				try {
					pro.load(input);
				} catch (Exception e) {
					logger.error("STARTUP ERROR WHEN LOADING application.properties", e);
				}
				
				String debug = String.valueOf(pro.get("dev.debug"));
				if("0".equals(debug)){
					JndiObjectFactoryBean bean = new JndiObjectFactoryBean();
					bean.setJndiName("java:comp/env/jdbc/xye-manager");
					bean.setProxyInterface(DataSource.class);
					bean.setLookupOnStartup(false);
					bean.afterPropertiesSet();
					dataSource=(DataSource)bean.getObject();
				}else{
					driverName = String.valueOf(pro.get("spring.datasource.driver-class-name"));
					url = String.valueOf(pro.get("spring.datasource.url"));
					userName = String.valueOf(pro.get("spring.datasource.username"));
					password = String.valueOf(pro.get("spring.datasource.password"));
					DataSourceBuilder factory = DataSourceBuilder  
						.create(Application.class.getClassLoader())  
						.driverClassName(driverName)  
						.url(url).username(userName)  
						.password(password);  
				dataSource= factory.build();
				}

501、dubbo在springboot中，不使用内嵌的tomcat启动
		SpringApplication.run(XyeServiceCoreApplication.class, args);	//静态的run方法，使用内嵌的tomcat启动，至于能不能用在无tomcat的jar启动，暂不测试
		new springapplicationbuilder(a.class).web(false).run(args)，jar启动其中中不使用tomcat，启动springboot工程，搭配下面的使用
		com.alibaba.dubbo.container.Main.main(args);//dubbo的推荐的main函数启动

		springapplicationbuilder.sources()在原本的流程中是用来指定外置tomcat的入口，war启动指定入口，main是java启动入口
		@Override
		protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
			return application.sources(XyeServiceCoreApplication.class);
		}
		
		相对于上面的非web启动方式，这个方法也行哦
		SpringApplication springApplication = new SpringApplication(XyeServiceCoreApplication.class);
		springApplication.setWebEnvironment(false);
		springApplication.run(args);
		com.alibaba.dubbo.container.Main.main(args);
		
	
		springboot启动不错吧
		@SpringBootApplication  
		public class Application {  
		  public static void main(String[] args) {  
				// SpringApplication.run(Application.class, args);  //方法1静态的run方法，容器tomcat启动
				// SpringApplication application = new SpringApplication(Application.class);  //方法2启动
				// application.setShowBanner(false);  
				// application.run(args);  
					new SpringApplicationBuilder().showBanner(true).sources(Application.class).run(args);  //方法3启动
			}  
		}  
	
		
		首先在classpath下创建dubbo.properties
		写入dubbo.service.shutdown.wait = 毫秒数
		然后再pom文件里的打包标签里把dubbo.properties加进去
		打jar包测试，结果OK
		优雅停机，先consumer请求，再执行kill 命令，停止provider端的机器，结果就是55秒后才停机，不能kill -9，
		
502、	使用https,可以使用jdk自带的keystool工具生成


503、	quartz的实现方式：
			1、本地的job，基本上是xml中配置为主
				<bean id="statDayJob" class="com.xiaoyuer.scheduledtimer.StatDayScheduledTimer"/>
				<bean id="statDayJobTrigger" 
						class="org.springframework.scheduling.quartz.CronTriggerFactoryBean">
					<property name="jobDetail" ref="statDayJobDetail"/>
					<property name="cronExpression" value="0 20 06 * * ?"/>
				</bean>
				<bean id="statDayJobDetail"
						class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
					<property name="targetObject" ref="statDayJob" />
					<property name="targetMethod" value="excute" />
					<property name="concurrent" value="false" />
				</bean>
				

				
				<bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
					<property name="triggers">
						<list>
							<ref bean="userGoalJobTrigger" />
							<ref bean="statDayJobTrigger"/>
						</list>
					</property>
					<property name="autoStartup" value="true" />
				</bean>
		
		2、这里配置了主要的bean之后，手工代码添加，可以控制job的触发，缺点是需要建表，管理job任务
			<bean name="quartzScheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean" >
			<property name="dataSource" ref ="dataSource" />       
			<property name="applicationContextSchedulerContextKey" value="applicationContextKey"/>
			<property name="configLocation" value="classpath:quartz.properties"/>			
			</bean>
    
			这里讲job的任务信息，持久化到了数据库中
			
			<bean id="jobDetail" class="org.springframework.scheduling.quartz.JobDetailFactoryBean" >
				<property name="jobClass">
					<value>com.xiaoyuer.pay.quartz.service.MyQuartzJobBean</value>        //继承QuartzJobBean
				</property>
			   <property name="durability" value="true" />	
			</bean>
			配置两个job用的bean，用来添加jobdetail，添加关联的tragger
			
			
			创建CronTrigger和JobDetail，二者为包含关系：
			方式一：CronTrigger包含JobDetail，JobDetail用MethodInvokingJobDetailFactoryBean工厂Bean包装普通的Java对象或bean；
			
			方式二：CronTrigger包含JobDetail，JobDetail用JobDetailFactoryBean包装QuartzJobBean的继承子类（即Job类）的实例；
				
			 
			创建调度工厂，根据数据存储方式，分为两种：
			方式一：内存RAMJobStore：把job的相关信息存储在内存里，如果用spring配置quartz的job信息的话，所有信息是配置在xml里，当spirng context启动的时候就把xml里的job信息装入内存。
			<bean name="startQuertz" lazy-init="false" autowire="no" class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
				  <property name="triggers">
					   <list>
							<ref bean="job01Trigger" />
					   </list>
				  </property>
			 </bean>
			方式二：数据库：读取配置在数据库里的job初始化信息，并且把job通过java序列化到数据库里，这样就使得每个job信息得到了持久化，即使在jvm或者容器挂掉的情况下，也能通过数据库感知到其他job的状态和信息；quartz集群各节点之间是通过同一个数据库实例(准确的说是同一个数据库实例的同一套表)来感知彼此的。 
			<bean id="quartzScheduler" lazy-init="false" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"> 
				  <property name="dataSource" ref="dataSource" />
				  <property name="autoStartup" value="true" />
				  <property name="applicationContextSchedulerContextKey"  value="applicationContextKey" />
				   <property name="configLocation" value="classpath:quartz.properties"/>
				  <property name="triggers">
					   <list>
							<ref bean="job02Trigger" />
					   </list>
				  </property>
			 </bean>
			 
			 quartz job的内容https://www.cnblogs.com/xuxueli/p/4866449.html  观望给了相应的数据库的sql
			 quartz官网直接获得相关的代码sql
			 
			CronTriggerImpl trigger = new CronTriggerImpl();
            trigger.setCronExpression(cronExpression);
            TriggerKey triggerKey = new TriggerKey(name, group);
            trigger.setJobName(jobDetail.getKey().getName());
            trigger.setKey(triggerKey);
            scheduler.addJob(jobDetail, true);// 加入一个任务到Quartz框架中, 等待后面再绑定Trigger
            scheduler.scheduleJob(trigger);
			
			SimpleTriggerImpl 和上面一致，只是添加不同的tragger
			
			(ApplicationContext)jobexecutioncontext.getScheduler().getContext().get("applicationContextKey");获得上下文
			在simpleService.judgeMethod(triggerName, group);方法向远程调用方法，通过httpclient发送请求到远程
			
			
			
			
	每个任务JobDetail可以绑定多个Trigger，但一个Trigger只能绑定一个任务，这种绑定关系由四种接口来执行： 

	Scheduler#scheduleJob(JobDetail, Trigger)  
		该接口的作用是在将任务加入Quartz的同时绑定一个Trigger，Quartz会在加入该任务后自动设置Trigger的JobName与JobGroup为该JobDetail的name与group； 

	Scheduler#scheduleJob(Trigger)  
		该接口的作用是将该Trigger绑定到其JobName与JobGroup指向的任务JobDetail。这时的name与group需要在Trigger绑定前由Quartz的使用者来设置与调用 

	Scheduler#rescheduleJob(String, String, Trigger)  
		替换一个指定的Trigger, 即解除指定Trigger与任务的绑定，并将新的Trigger与任务绑定，Quartz会自动调整新Trigger的JobName与JobGroup，而旧的Trigger将被移除 

	Scheduler#triggerJob(String, String)  
		创建一个立即触发的Trigger，并将其与name与group指定的任务绑定 
		
    JobDetail有个属性叫durable，表明该任务没有任何trigger绑定时仍保存在Quartz的JobStore中，默认为false。 
    若JobDetail的durable属性为false，则任务将会从Quartz移除。 
				
	下面这个接口其实可以理解为先addJob(JobDetail, false),再调用scheduleJob(Trigger),此时Quartz会自动校正与设置trigger3的JobName与JobGroup属性  
	scheduler.scheduleJob(jobDetail, trigger3);  
	// 因为任务已在上一条语句中已加入, 所以不能再使用scheduleJob(JobDetail, Trigger)
			
			
503.加上static限定的字段，是所谓的类字段，也就是说这个字段的拥有者不是对象而是类。无论创建多少对象，static数据都只有一份，这里用了初始化的功能	
			
			
504、一个类中可以有多个静态代码块
	  public static Map<String, String> ppCodeMap = new HashMap<String, String>(3);
		static
		{
			ppCodeMap.put(PP_CODE_ONE, "现金支出"); // 现金支出
			ppCodeMap.put(PP_CODE_THREE, "委托代扣"); // 委托代扣
		}
			
505、optimize table 优化mysql表的空间，可重置自增值，缺点是会锁表
	 UNION ALL 的语句后面不能加;。
	 
506、开启vpn会使rocketmq的broker的ip地址发生变化
		异步调用的会有线程等待和socket连接
		
507、request.getSession().setAttribute("accountNo", accountNo); 中的值相比在modelmap中优先返回

508、sql相关
		
		SELECT `AUTO_INCREMENT`,t.TABLE_NAME FROM  INFORMATION_SCHEMA.TABLES t  WHERE TABLE_SCHEMA = 'db_xiaoyuer' AND t.AUTO_INCREMENT=0 AND t.AUTO_INCREMENT IS NOT NULL;

		--  取消主键自增
		SELECT
		 CONCAT(
				'ALTER TABLE ',
			b.table_name,
				' CHANGE ',
				d.column_name,
				' ',
				d.column_name,
				' ',
				d.COLUMN_TYPE,
				' NOT NULL',
				';'
			)
		FROM
			information_schema.TABLES b
			
			LEFT JOIN (SELECT * FROM INFORMATION_SCHEMA.Columns c WHERE   c.table_schema='db_xiaoyuer' AND c.column_key='PRI')d ON b.table_name= d.table_name
		WHERE
			b.table_name IN (SELECT t.TABLE_NAME  FROM  INFORMATION_SCHEMA.TABLES t  WHERE t.TABLE_SCHEMA = 'db_xiaoyuer' AND t.AUTO_INCREMENT=0 AND t.AUTO_INCREMENT IS NOT NULL) AND b.table_schema='db_xiaoyuer';
			
		-- 增加主键自增
		SELECT
		 CONCAT(
				'ALTER TABLE ',
			b.table_name,
				' CHANGE ',
				d.column_name,
				' ',
				d.column_name,
				' ',
				d.COLUMN_TYPE,
				' NOT NULL',
				' AUTO_INCREMENT'
				';'
			)
		FROM
			information_schema.TABLES b
			
			LEFT JOIN (SELECT * FROM INFORMATION_SCHEMA.Columns c WHERE   c.table_schema='db_xiaoyuer' AND c.column_key='PRI')d ON b.table_name= d.table_name
		WHERE
			b.AUTO_INCREMENT IS NULL AND b.table_schema='db_xiaoyuer' AND b.table_name NOT IN （）
			
			
	SELECT * FROM pp_trade_ass_confirm_paid pcp LEFT JOIN log_user_trade lt ON pcp.order_no = lt.serial_number 关联的字段需要加索引

	200 != NULL 中这条记录不参与比较
	
	insert into table (字段...)select ... 可以的，查询的列要对应上
	
	REPLACE替换函数，sql字符串的截取
	SELECT SUBSTRING('订单：XQDD-520141119091355验收成功',4)
	SELECT SUBSTRING_INDEX(SUBSTRING('订单：XQDD-520141119091355验收成功',4),'验',1)
	
	组合索引，优先全匹配，然后是第一位匹配，加上索引的数据都是计算哈希值存入表中，查询，直接根据数据hash值找，提高查询效率



sql的字符串截取
	

509、在spring容器中所有实现了FactoryBean<T>的工厂接口的，都是通过getObject方法返回相应的bean的，也是实现bean注册进入容器的

	@Override
	@SuppressWarnings("unchecked")
	public void afterPropertiesSet() {
		if (this.name == null) {
			this.name = this.beanName;
		}
		if (this.group == null) {
			this.group = Scheduler.DEFAULT_GROUP;
		}
		if (this.applicationContextJobDataKey != null) {
			if (this.applicationContext == null) {
				throw new IllegalStateException(
					"JobDetailBean needs to be set up in an ApplicationContext " +
					"to be able to handle an 'applicationContextJobDataKey'");
			}
			getJobDataMap().put(this.applicationContextJobDataKey, this.applicationContext);
		}

		JobDetailImpl jdi = new JobDetailImpl();
		jdi.setName(this.name);
		jdi.setGroup(this.group);
		jdi.setJobClass((Class) this.jobClass);
		jdi.setJobDataMap(this.jobDataMap);
		jdi.setDurability(this.durability);
		jdi.setRequestsRecovery(this.requestsRecovery);
		jdi.setDescription(this.description);
		this.jobDetail = jdi;
	}

	@Override
	public JobDetail getObject() {
		return this.jobDetail;
	}
	
	
510、通联钱包，用户确认验收，随后服务者提现，session丢失   open走了一次hessian接口 request中的cookie丢失

511、BeanNameAware bean中指定的id使用该方法，完成beanName的注入

512、BeanNameAware		作用：让Bean获取自己在BeanFactory配置中的名字（根据情况是id或者name）。 
	 BeanFactoryAware：	作用：让Bean获取配置他们的BeanFactory的引用。
	 
	 subList是返回一个镜像而不是新示例,得保证原来的list不能更改。
	在使用时，如果更改了原来的list,sublist的任何操作都会报错

					
	
	<welcome-file-list>
		<welcome-file>index.jsp</welcome-file>
	</welcome-file-list>  

	配置根路径的请求欢迎页 不进mvc的

513、
	this.pageContext.setAttribute("ninini", userInfo);//这里是用在jsp的标签tag中
	和request.getSession().getAttribute(），优先pagecontext，如果pagecontext为null，则取后者
	
	在主站登录的问题中，http中的session是invalidate，但是https中的session是不同步的，所以没有注销
	
	
514、按照字节截取字符串
		/**
		 * 	src：byte源数组
			srcPos：截取源byte数组起始位置（0位置有效）
			dest,：byte目的数组（截取后存放的数组）
			destPos：截取后存放的数组起始位置（0位置有效）
			length：截取的数据长度
		 * @param a
		 * @param b 起始长度
		 * @param c	字节长度
		 * @return
		 * @throws UnsupportedEncodingException
		 */
		public static String getByteString(String a,int b,int c) throws UnsupportedEncodingException{
			byte[] bytes = a.getBytes("GBK");
			byte aaa[]=new byte[1024];
			System.arraycopy(bytes, b, aaa, 0, c);
			String string = new String(aaa, "GBK").trim();
			return string;
		}
		
515、	对request进行包装，使用Wrapper包装类，灵活改动原来的类的方法
		RequestWrapper requestWrapper = new RequestWrapper(request);
        chain.doFilter(requestWrapper, resp);

516、	nginx是按照最全的路径匹配的,如果没有匹配到，则优先按照从左往右，最全域名先匹配
		if ($http_host ~* "^(.*?)\.yu\.com$") {
			set $domain $1;
	    }
		  location / {
		 	if ($domain ~* "www") {
        	 	proxy_pass https://192.168.6.222:9443;
			  }
			 if ($domain ~* "m") {
        	 	proxy_pass https://192.168.6.222:9443;
			 }
        }  
		
		#location /ids {
            #proxy_pass http://192.168.6.251:8150/ids;
        #}
		 #location /login {
           #proxy_pass http://192.168.6.251:8150/ids/login;
        #}
		
		location /ids {
            proxy_pass https://192.168.6.222:9446/ids;

        }
		location /ids/login {
           proxy_pass https://192.168.6.222:9446/ids/login;
		}

517、sso单点登录流程，这个是主要思想
	1.项目启动，AuthenticationFilter中初始化Configuration和AuthInterceptor(鉴权事宜)，并且存入servletContext中
	2.初次登录，直接redirect跳转ids_server端，判断cookie中没有登录相关name的cookie value，直接跳转登录页面，登录后，相同的https://www.yu.com/ids/login路径还是跳转登录页面				
	3.点击登录，常规的登录次数和密码校验后，一般获取的域名是.yu.com,获取tockenFlag对应的cookie，存在，删除对应的redis值，开始单点登录	
	4.生成一个随机数ticketId返回，并且在redis中设置对应的限时值(vId + "%_%" + userInfo.getUserCode())，并将返回的url统一设置成auth认证url，然后在.yu.com下写上tockenFlag对应的cookie值，在session中添加userinfo的信息，
	5.认证返回后直接到AuthenticationServlet(只做登录和退出用)，调用之前的Configuration和AuthInterceptor，开始鉴权，见得到的ticket发送到server端验证，验证成功，返回对应的usercode,然后按需，存放相应的redis和cookies值，这里是xyeAuthId，认证后的标记，这样登录就成功了
	6.后面的htm请求会经过filter，根据url对应使用三种权限校验，redis中存放的vid相关的信息，每次请求redis没有则清空cookie，存在就刷新redis的缓存时间,
			
518、dubbo的时间有超时限制，可以调节

519、	maven相关的打包命令	使用 mvn clean install -Dmaven.test.skip=true pom工程 

520、	set 中的hash冲突，先通过hashcode定位存放的位置，在根据equals判断是否相等，相同的话就不存了，不相同就散列其它的地址

521、hashmap的原理	
	利用key的hashCode重新hash计算出当前对象的元素在数组中的下标
	存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中
	获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。
核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。


522、Spring MVC 的Servlet，它将加载WEB-INF/springDispatcherServlet-servlet.xml  servlet名-servlet.xml

523、	非null的，size为0的list，遍历直接跳过

524、	opnotice可以记录远程调用的结果，进表后，不成功的后面的job再轮询调用

525、	@ResponseBody直接用，response.getwriter忽略

526、	下划线转驼峰，user_info   userInfo

527、	@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配，其中@Qualifier不能单独使用。
		
		@Resource  
		如有指定的name属性，先按该属性进行byName方式查找装配；其次再进行默认的byName方式进行装配；如果以上都不成功，则按byType的方式自动装配。都不成功，则报异常。

528、	dev 开启属性过滤后，才加入容器的，application中的需要单独加入才行
		allin.pay.card.merId=$[allin.pay.card.merId]
		
		
529、		-- 使用相对的路径读取文件
			String privateKeyFile ="filters/xye-ac.properties";
			InputStream resourceAsStream = RequireOrderAllinpayServiceImpl.class.getClassLoader().getResourceAsStream(privateKeyFile);  
			路径不加classpath					


			-- 使用文件路径读取
			String configFile ="tlqb/private.key";
			URL classPath = Thread.currentThread().getContextClassLoader().getResource("");
			String proFilePath = classPath.toString();
								
			//移除开通的file:/六个字符
			proFilePath = proFilePath.substring(6); 
								
			//如果为window系统下,则把路径中的路径分隔符替换为window系统的文件路径分隔符
			proFilePath = proFilePath.replace("/", java.io.File.separator);
								
			//兼容处理最后一个字符是否为 window系统的文件路径分隔符,同时建立 properties 文件路径
			//例如返回: D:\workspace\myproject01\WEB-INF\classes\config.properties
			if(!proFilePath.endsWith(java.io.File.separator)){
				proFilePath = proFilePath + java.io.File.separator + configFile;
				} else {
				proFilePath = proFilePath + configFile;
			}
			FileInputStream publicKeyStream = new FileInputStream(proFilePath );
			PublicKey publickey = SecurityUtils.loadPublicKey(publicKeyStream);

			
530、	在tomcat中配置jvm的内存变量
		set "JAVA_OPTS=-Xms512m -Xmx512m -XX:ParallelGCThreads=8 -XX:PermSize=128m -XX:MaxPermSize=256m"
		
531、	Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；
		Union All：对两个结果集进行并集操作，包括重复行，不进行排序；
		
		
532、	当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，
		DELETE操作不会减少表或索引所占用的空间。
		drop语句将表所占用的空间全释放掉。
		(5)TRUNCATE 和DELETE只删除数据， DROP则删除整个表（结构和数据）。
		(7)delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。
		(8)truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚

		
533、	将directory目录下的全目录内容打包到classes下
		在elclise中直接启动时编译是以本地代码为准的，dev其他路径的环境参数只针对maven 打包后的有效
			<resource>
				<directory>src/main/resources/${env}</directory>
				<includes>
					<include>application.properties</include>
					<include>tlqb/*</include>
				</includes>
			</resource>
			
			<env></env> 空,打出来的就是空的/路径
			<resource>
				<directory>../vars/${pay_env}/tlqb</directory>
				<!-- 目标路径 -->
				<targetPath>WEB-INF/classes/tlqb</targetPath>
			</resource>
			
		-- 对应jenkins发布的版本号	
		> /usr/bin/git checkout -f 658390e95d5da0389444221d8960b0d0d252c25c
		Commit message: "钱包需求变更"
		
				
		dev 和其他环境的打包问题，默认的是使用本地的代码，只有maven打包的时候才会选择相应的环境
		
			
534、	linux
		ps -ef | grep nginx
		ps -ef |grep tomcat		一样的查询功能
		lsof -i:80
		whereis nginx
		/usr/nginx/sbin/nginx -t
		
		rocketmq的启动和停止
		1、rocketmq的启动 
			进入rocketMQ解压目录下的bin文件夹 
			启动namesrv服务：nohup sh bin/mqnamesrv & 
			日志目录：{rocketMQ解压目录}/logs/rocketmqlogs/namesrv.log

			启动broker服务：nohup sh bin/mqbroker & 
			日志目录：{rocketMQ解压目录}/logs/rocketmqlogs/broker.log 
			以上的启动日志可以在启动目录下的nohub.out中看到 

		2、rocketmq服务关闭
		关闭namesrv服务：sh bin/mqshutdown namesrv
		关闭broker服务 ：sh bin/mqshutdown broker

		 
		 	
535、	分的保留0位  和元的保留2位是一样的，精确到分位
		tax =Arith.format(Double.valueOf(price)/100D * Double.valueOf(ddr),0).longValue();
		tax =Arith.format(price/100 * Double.valueOf(ddr),0).longValue();
		
536、	一个 HTTP 请求报文由请求行（request line）、请求头部（header）、空行和请求数据 4 个部分组成，
		通过读取请求报文头中 Cookie 属性的JSESSIONID 的值，在服务端的一个会话 Map 中，根据这个 JSESSIONID 获取对应的HttpSession 的对象。

		HTTP 请求报文由 3 部分组成（ 请求行+请求头+请求体 ）
		HTTP 的响应报文也由三部分组成（ 响应行+响应头+响应体 ）

		GET 将提交到服务器的数据添加到 URL 中了，可见；虽然POST 的数据，你肉眼看不到，你抓个包看看，在 HTTP 包的包体中

		幂等的意味着对同一 URL 的多个请求应该返回同样的结果。

		session 机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息

		般用来实现 Session 的方法有两种：
		（1）URL 重写。
		Web Server 在返回 Response 的时候，检查页面中所有的 URL，包括所有的连接，和
		HTML Form 的 Action 属性，在这些 URL 后面加上“;jsessionid=XXX”。
		下一次，用户访问这个页面中的 URL。jsessionid 就会传回到 Web Server。
		（2）Cookie

		forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
		redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等
		
		页面请求就会页面，服务端请求就回服务端，浏览器请求页面，页面中js再加载回调的地址
		通联的支付页面，页面倒计时，reload我们的路径地址，服务器的redirect应该也是可以的
		
	
		
		